<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notes</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Georgia&family=Courier+Prime&family=Comic+Neue&family=Playfair+Display&family=Roboto+Mono&family=Lora:ital,wght@0,400;0,600;1,400&family=Merriweather:ital,wght@0,400;0,700;1,400&family=Open+Sans:wght@300;400;600&family=Montserrat:wght@300;400;500;600&family=Poppins:wght@300;400;500;600&family=Raleway:wght@300;400;500;600&family=Source+Code+Pro:wght@400;500&family=Fira+Code:wght@400;500&family=Dancing+Script:wght@400;500;600&family=Pacifico&family=Caveat:wght@400;500;600&family=Architects+Daughter&family=Patrick+Hand&family=Shadows+Into+Light&family=Permanent+Marker&family=Satisfy&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            display: flex;
            height: 100vh;
            background: #fafafa;
            color: #333;
            overflow: hidden;
            transition: background 0.3s, color 0.3s;
        }

        /* Dark Mode Styles */
        body.dark-mode {
            background: #1a1a1a;
            color: #e0e0e0;
        }

        body.dark-mode .sidebar {
            background: #222;
            border-right-color: #333;
        }

        body.dark-mode .sidebar-header {
            border-bottom-color: #333;
        }

        body.dark-mode .sidebar-header h1 {
            color: #e0e0e0;
        }

        body.dark-mode .section-title {
            color: #888;
        }

        body.dark-mode .add-btn {
            color: #aaa;
            border-color: #444;
        }

        body.dark-mode .add-btn:hover {
            background: #e0e0e0;
            color: #222;
            border-color: #e0e0e0;
        }

        body.dark-mode .notebook-header:hover {
            background: #2a2a2a;
        }

        body.dark-mode .notebook-header.active {
            background: #333;
        }

        body.dark-mode .notebook-name {
            color: #e0e0e0;
        }

        body.dark-mode .note-item {
            color: #ccc;
        }

        body.dark-mode .note-item:hover {
            background: #2a2a2a;
        }

        body.dark-mode .note-item.active {
            background: #333;
            color: #fff;
        }

        body.dark-mode .main-content {
            background: #1a1a1a;
        }

        body.dark-mode .toolbar {
            background: #222;
            border-bottom-color: #333;
        }

        body.dark-mode .tool-btn {
            color: #ccc;
        }

        body.dark-mode .tool-btn:hover {
            background: #333;
        }

        body.dark-mode .tool-btn.active {
            background: #444;
            color: #fff;
        }

        body.dark-mode .toolbar-label {
            color: #888;
        }

        body.dark-mode .toolbar-divider {
            background: #333;
        }

        body.dark-mode .font-select {
            background: #333;
            border-color: #444;
            color: #e0e0e0;
        }

        body.dark-mode .canvas-container {
            background: #2a2a2a;
        }

        body.dark-mode .drawing-canvas {
            background: transparent;
        }

        body.dark-mode .grid-overlay {
            background-image: radial-gradient(circle, #555 1px, transparent 1px);
        }

        body.dark-mode .text-box {
            border-color: #666;
            color: #e0e0e0;
        }

        body.dark-mode .text-box:focus {
            border-color: #888;
        }

        body.dark-mode .text-box.selected {
            border-color: #007AFF !important;
            background: rgba(0, 122, 255, 0.1);
        }

        body.dark-mode .status-bar {
            background: #222;
            border-top-color: #333;
            color: #888;
        }

        body.dark-mode .modal-content,
        body.dark-mode .version-modal {
            background: #2a2a2a;
        }

        body.dark-mode .modal-content h2,
        body.dark-mode .version-modal-header h3 {
            color: #e0e0e0;
        }

        body.dark-mode .modal-input {
            background: #333;
            border-color: #444;
            color: #e0e0e0;
        }

        body.dark-mode .modal-btn.secondary {
            background: #444;
            color: #e0e0e0;
        }

        body.dark-mode .version-modal-header {
            border-bottom-color: #444;
        }

        body.dark-mode .version-item:hover {
            background: #333;
        }

        body.dark-mode .version-time {
            color: #e0e0e0;
        }

        body.dark-mode .home-page {
            background: #1a1a1a;
        }

        body.dark-mode .home-section-title {
            color: #e0e0e0;
        }

        body.dark-mode .pinned-note-card,
        body.dark-mode .notebook-card {
            background: #2a2a2a;
            border-color: #333;
        }

        body.dark-mode .pinned-note-card:hover,
        body.dark-mode .notebook-card:hover {
            border-color: #555;
            background: #333;
        }

        body.dark-mode .pinned-note-title,
        body.dark-mode .notebook-card-name {
            color: #e0e0e0;
        }

        body.dark-mode .pinned-note-notebook,
        body.dark-mode .notebook-card-count {
            color: #888;
        }

        body.dark-mode .nav-home {
            color: #ccc;
        }

        body.dark-mode .nav-home:hover {
            background: #333;
        }

        body.dark-mode .nav-home.active {
            background: #333;
            color: #fff;
        }

        body.dark-mode .eraser-cursor {
            background: rgba(42, 42, 42, 0.8);
            border-color: #666;
        }

        /* Dark Mode - Graph View */
        body.dark-mode .graph-view {
            background: #0a0a0f;
        }

        body.dark-mode .graph-header h2 {
            color: #fff;
        }

        body.dark-mode .graph-header p {
            color: rgba(255,255,255,0.6);
        }

        body.dark-mode .graph-search-input {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.2);
            color: #fff;
        }

        body.dark-mode .graph-search-input::placeholder {
            color: rgba(255,255,255,0.4);
        }

        body.dark-mode .graph-btn {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.2);
            color: #fff;
        }

        body.dark-mode .graph-btn:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.3);
        }

        body.dark-mode .graph-checkbox {
            color: rgba(255,255,255,0.7);
        }

        body.dark-mode .graph-container {
            background: radial-gradient(circle at 50% 50%, #1a1a2e 0%, #0a0a0f 100%);
            border-color: #333;
        }

        body.dark-mode .graph-info-panel {
            background: rgba(20, 20, 30, 0.95);
            border-color: rgba(255,255,255,0.1);
        }

        body.dark-mode .graph-info-title {
            color: #fff;
        }

        body.dark-mode .graph-info-content {
            color: rgba(255,255,255,0.7);
        }

        body.dark-mode .graph-info-content .info-label {
            color: rgba(255,255,255,0.5);
        }

        body.dark-mode .graph-info-content .connection-item {
            border-color: rgba(255,255,255,0.1);
        }

        body.dark-mode .graph-info-content .connection-item:hover {
            background: rgba(255,255,255,0.05);
        }

        body.dark-mode .graph-view-toggle {
            background: rgba(255,255,255,0.1);
        }

        body.dark-mode .graph-toggle-btn {
            color: rgba(255,255,255,0.6);
        }

        body.dark-mode .graph-toggle-btn:hover {
            color: rgba(255,255,255,0.9);
            background: rgba(255,255,255,0.1);
        }

        body.dark-mode .graph-toggle-btn.active {
            background: rgba(139, 92, 246, 0.3);
            color: #fff;
        }

        body.dark-mode .notes-overview-container {
            background: radial-gradient(circle at 50% 50%, #1a1a2e 0%, #0a0a0f 100%);
            border-color: #333;
        }

        body.dark-mode .note-preview-card {
            background: rgba(30, 30, 45, 0.95);
            border-color: rgba(255,255,255,0.1);
            box-shadow: none;
        }

        body.dark-mode .note-preview-card:hover {
            box-shadow: 0 8px 32px rgba(139, 92, 246, 0.2);
        }

        body.dark-mode .note-preview-header {
            background: rgba(139, 92, 246, 0.15);
            border-color: rgba(255,255,255,0.1);
        }

        body.dark-mode .note-preview-title {
            color: #fff;
        }

        body.dark-mode .note-preview-meta {
            color: rgba(255,255,255,0.5);
        }

        body.dark-mode .note-preview-text {
            color: rgba(255,255,255,0.7);
        }

        body.dark-mode .note-preview-content::after {
            background: linear-gradient(transparent, rgba(30, 30, 45, 0.95));
        }

        body.dark-mode .notes-zoom-level {
            background: rgba(255,255,255,0.1);
            color: #fff;
        }

        body.dark-mode .graph-node-tooltip {
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            border-color: transparent;
        }

        /* Status Badge Styles */
        .status-badge {
            display: inline-block;
            padding: 1px 6px;
            border-radius: 3px;
            font-size: 0.6rem;
            font-weight: 500;
            letter-spacing: 0.2px;
            margin-left: 8px;
            margin-right: 4px;
            vertical-align: middle;
            opacity: 0.85;
        }

        .status-badge.in-progress {
            background: rgba(245, 158, 11, 0.15);
            color: #D97706;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }

        .status-badge.finished {
            background: rgba(16, 185, 129, 0.15);
            color: #059669;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .status-badge.needs-review {
            background: rgba(59, 130, 246, 0.15);
            color: #2563EB;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        body.dark-mode .status-badge.in-progress {
            background: rgba(245, 158, 11, 0.15);
            color: #FBBF24;
            border-color: rgba(245, 158, 11, 0.4);
        }

        body.dark-mode .status-badge.finished {
            background: rgba(16, 185, 129, 0.15);
            color: #34D399;
            border-color: rgba(16, 185, 129, 0.4);
        }

        body.dark-mode .status-badge.needs-review {
            background: rgba(59, 130, 246, 0.15);
            color: #60A5FA;
            border-color: rgba(59, 130, 246, 0.4);
        }

        /* Status badge on pinned cards */
        .pinned-card .status-badge {
            display: block;
            margin-left: 0;
            margin-top: 8px;
            margin-bottom: 4px;
            font-size: 0.65rem;
            width: fit-content;
        }

        /* Status Selector */
        .status-select {
            background: #fff;
            color: #444;
            border: 1px solid #e0e0e0;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            font-family: inherit;
            min-width: 140px;
        }

        .status-select:focus {
            outline: none;
            border-color: #333;
        }

        body.dark-mode .status-select {
            background: #333;
            border-color: #444;
            color: #e0e0e0;
        }

        body.dark-mode .status-select:focus {
            border-color: #666;
        }

        /* Outline Sidebar */
        .outline-sidebar {
            position: absolute;
            right: 0;
            top: 0;
            width: 220px;
            height: 100%;
            background: #fafafa;
            border-left: 1px solid #e8e8e8;
            padding: 16px;
            overflow-y: auto;
            z-index: 10;
            display: none;
        }

        .outline-sidebar.visible {
            display: block;
        }

        .outline-header {
            font-size: 0.7rem;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
            margin-bottom: 12px;
        }

        .outline-item {
            padding: 6px 8px;
            font-size: 0.8rem;
            color: #666;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.15s ease;
            margin-bottom: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .outline-item:hover {
            background: #f0f0f0;
            color: #333;
        }

        .outline-item.h1 {
            font-size: 0.85rem;
            font-weight: 600;
            padding-left: 8px;
        }

        .outline-item.h2 {
            font-size: 0.8rem;
            font-weight: 500;
            padding-left: 20px;
        }

        .outline-item.h3 {
            font-size: 0.75rem;
            padding-left: 32px;
        }

        body.dark-mode .outline-sidebar {
            background: #1a1a1a;
            border-left-color: #333;
        }

        body.dark-mode .outline-header {
            color: #888;
        }

        body.dark-mode .outline-item {
            color: #ccc;
        }

        body.dark-mode .outline-item:hover {
            background: #2a2a2a;
            color: #fff;
        }

        /* Header text styles on canvas */
        .text-box.header-1 {
            font-size: 32px !important;
            font-weight: 700;
            line-height: 1.2;
        }

        .text-box.header-2 {
            font-size: 24px !important;
            font-weight: 600;
            line-height: 1.3;
        }

        .text-box.header-3 {
            font-size: 18px !important;
            font-weight: 600;
            line-height: 1.4;
        }

        /* Header nav sidebar (Notion-style, right side) */
        .header-nav {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: flex-end;
            pointer-events: auto;
            padding: 10px 6px;
            background: transparent;
        }

        .header-nav-item {
            height: 3px;
            border-radius: 2px;
            background: rgba(0,0,0,0.18);
            cursor: pointer;
            transition: background 0.15s, width 0.15s;
        }

        .header-nav-item.h1 {
            width: 28px;
        }

        .header-nav-item.h2 {
            width: 20px;
        }

        .header-nav-item.h3 {
            width: 12px;
        }

        .header-nav-item:hover {
            background: rgba(0,122,255,0.7);
        }

        .header-nav-item.active {
            background: #007AFF;
        }

        .header-preview {
            position: fixed;
            z-index: 30;
            max-width: 260px;
            background: #fff;
            color: #222;
            border: 1px solid #e0e0e0;
            padding: 8px 12px;
            border-radius: 6px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            font-size: 0.8rem;
            pointer-events: none;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        body.dark-mode .header-nav-item {
            background: rgba(255,255,255,0.18);
        }

        body.dark-mode .header-nav-item:hover {
            background: rgba(96,165,250,0.7);
        }

        body.dark-mode .header-nav-item.active {
            background: #60A5FA;
        }

        body.dark-mode .header-preview {
            background: #222;
            color: #e0e0e0;
            border-color: #333;
        }

        /* Import modal */
        .import-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .import-modal.active {
            display: flex;
        }

        .import-modal-content {
            background: #fff;
            border-radius: 12px;
            padding: 24px;
            min-width: 320px;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
        }

        .import-modal-content h3 {
            margin: 0 0 16px 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .import-progress {
            background: #f0f0f0;
            border-radius: 6px;
            height: 8px;
            overflow: hidden;
            margin: 12px 0;
        }

        .import-progress-bar {
            background: #007AFF;
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }

        .import-status {
            font-size: 0.85rem;
            color: #666;
            margin-top: 8px;
        }

        .import-modal-buttons {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            justify-content: flex-end;
        }

        .import-modal-btn {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .import-modal-btn.primary {
            background: #007AFF;
            color: #fff;
        }

        .import-modal-btn.secondary {
            background: #f0f0f0;
            color: #333;
        }

        body.dark-mode .import-modal-content {
            background: #2a2a2a;
        }

        body.dark-mode .import-modal-content h3 {
            color: #e0e0e0;
        }

        body.dark-mode .import-progress {
            background: #444;
        }

        body.dark-mode .import-status {
            color: #aaa;
        }

        body.dark-mode .import-modal-btn.secondary {
            background: #444;
            color: #e0e0e0;
        }

        /* Sidebar Styles */
        .sidebar {
            width: 260px;
            background: #fff;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #e8e8e8;
        }

        .sidebar-header {
            padding: 24px 20px;
            border-bottom: 1px solid #e8e8e8;
        }

        .sidebar-header h1 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
            letter-spacing: -0.3px;
        }

        .notebooks-section {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .section-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 4px;
            font-size: 0.7rem;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
            gap: 4px;
        }

        .section-title span:first-child {
            flex: 1;
        }

        .notebook-sort-select {
            background: transparent;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 3px 6px;
            font-size: 0.65rem;
            color: #666;
            cursor: pointer;
            outline: none;
            text-transform: none;
            letter-spacing: normal;
        }

        .notebook-sort-select:hover {
            border-color: #999;
        }

        body.dark-mode .notebook-sort-select {
            background: transparent;
            border-color: #444;
            color: #aaa;
        }

        body.dark-mode .notebook-sort-select:hover {
            border-color: #666;
        }

        .notebook-pin-btn {
            opacity: 0;
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 0.75rem;
            padding: 2px 4px;
            transition: all 0.15s ease;
        }

        .notebook-header:hover .notebook-pin-btn {
            opacity: 1;
        }

        .notebook-pin-btn.pinned {
            opacity: 1;
            color: #f5a623;
        }

        .notebook-pin-btn:hover {
            color: #f5a623;
        }

        .add-btn {
            background: transparent;
            color: #666;
            border: 1px solid #e0e0e0;
            width: 22px;
            height: 22px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .add-btn:hover {
            background: #333;
            color: #fff;
            border-color: #333;
        }

        .notebook {
            margin-bottom: 2px;
        }

        .notebook-header {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .notebook-header:hover {
            background: #f5f5f5;
        }

        .notebook-header.active {
            background: #f0f0f0;
        }

        .notebook-icon {
            margin-right: 10px;
            font-size: 0.9rem;
            opacity: 0.6;
        }

        .notebook-name {
            flex: 1;
            font-size: 0.875rem;
            font-weight: 450;
            color: #444;
        }

        .notebook-toggle {
            color: #bbb;
            transition: transform 0.2s ease;
            font-size: 0.7rem;
        }

        .notebook-toggle.open {
            transform: rotate(90deg);
        }

        .notes-list {
            margin-left: 12px;
            display: none;
            border-left: 1px solid #eee;
            margin-top: 2px;
        }

        .notes-list.open {
            display: block;
        }

        .note-item {
            padding: 5px 12px 5px 12px;
            margin: 0.5px 0;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            color: #666;
            transition: all 0.15s ease;
            display: block;
        }

        .note-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .note-item-status-row {
            display: flex;
            justify-content: center;
            margin-top: 3px;
            margin-bottom: 0;
        }

        .note-item-status-row .status-badge {
            margin: 0;
        }

        .note-item:hover {
            background: #f5f5f5;
            color: #333;
        }

        .note-item.active {
            background: #e8e8e8;
            color: #333;
            font-weight: 500;
        }

        .delete-btn {
            opacity: 0;
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.15s ease;
        }

        .delete-btn:hover {
            color: #e53935;
            background: rgba(229, 57, 53, 0.1);
        }

        .note-item:hover .delete-btn,
        .notebook-header:hover .delete-btn {
            opacity: 1;
        }

        /* Nested Notes */
        .note-item-container {
            position: relative;
            cursor: grab;
        }

        .note-item-container:active {
            cursor: grabbing;
        }

        .note-item-container.dragging {
            opacity: 0.5;
        }

        .note-item-container.drag-over {
            border: 2px dashed #007aff;
            background: rgba(0, 122, 255, 0.05);
        }

        .note-item .note-toggle {
            font-size: 0.75rem;
            margin-right: 8px;
            transition: transform 0.2s, color 0.15s, background 0.15s;
            color: #666;
            background: #f0f0f0;
            width: 18px;
            height: 18px;
            border-radius: 4px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .note-item .note-toggle:hover {
            background: #e0e0e0;
            color: #333;
        }

        .note-item .note-toggle.open {
            transform: rotate(90deg);
        }

        .note-item .note-toggle.hidden {
            visibility: hidden;
        }

        body.dark-mode .note-item .note-toggle {
            color: #aaa;
            background: #3a3a3a;
        }

        body.dark-mode .note-item .note-toggle:hover {
            background: #4a4a4a;
            color: #fff;
        }

        .sub-notes-list {
            display: none;
            padding-left: 16px;
            border-left: 1px solid #e0e0e0;
            margin-left: 12px;
        }

        .sub-notes-list.open {
            display: block;
        }

        body.dark-mode .sub-notes-list {
            border-left-color: #444;
        }

        .note-item .add-subnote-btn {
            opacity: 0;
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 0.7rem;
            padding: 2px 5px;
            border-radius: 4px;
            transition: all 0.15s ease;
            margin-right: 4px;
        }

        .note-item:hover .add-subnote-btn {
            opacity: 1;
        }

        .note-item .add-subnote-btn:hover {
            color: #333;
            background: rgba(0,0,0,0.05);
        }

        body.dark-mode .note-item .add-subnote-btn:hover {
            color: #fff;
            background: rgba(255,255,255,0.1);
        }

        /* Breadcrumb Navigation */
        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: #666;
            padding: 8px 16px;
            background: #f8f8f8;
            border-bottom: 1px solid #e8e8e8;
        }

        body.dark-mode .breadcrumb {
            background: #252525;
            border-bottom-color: #333;
            color: #888;
        }

        .breadcrumb-item {
            cursor: pointer;
            transition: color 0.15s;
        }

        .breadcrumb-item:hover {
            color: #333;
        }

        body.dark-mode .breadcrumb-item:hover {
            color: #fff;
        }

        .breadcrumb-separator {
            color: #ccc;
        }

        body.dark-mode .breadcrumb-separator {
            color: #555;
        }

        .breadcrumb-current {
            color: #333;
            font-weight: 500;
        }

        body.dark-mode .breadcrumb-current {
            color: #e0e0e0;
        }

        /* Sub-note Links on Canvas (Notion-style) */
        .subnote-block {
            position: absolute;
            display: flex;
            align-items: center;
            padding: 12px 16px;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
            pointer-events: auto;
            z-index: 5;
            min-width: 180px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        }

        .subnote-block:hover {
            background: #f8f8f8;
            border-color: #333;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            transform: translateY(-1px);
        }

        .subnote-block-icon {
            width: 24px;
            height: 24px;
            background: #f0f0f0;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-size: 14px;
        }

        .subnote-block-content {
            flex: 1;
            min-width: 0;
        }

        .subnote-block-name {
            font-size: 0.9rem;
            font-weight: 500;
            color: #333;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .subnote-block-hint {
            font-size: 0.7rem;
            color: #999;
            margin-top: 2px;
        }

        .subnote-block-arrow {
            color: #ccc;
            margin-left: 8px;
            font-size: 1rem;
        }

        body.dark-mode .subnote-block {
            background: #2a2a2a;
            border-color: #444;
        }

        body.dark-mode .subnote-block:hover {
            background: #333;
            border-color: #666;
        }

        body.dark-mode .subnote-block-icon {
            background: #3a3a3a;
        }

        body.dark-mode .subnote-block-name {
            color: #e0e0e0;
        }

        body.dark-mode .subnote-block-hint {
            color: #666;
        }

        body.dark-mode .subnote-block-arrow {
            color: #555;
        }

        /* Media Embed Blocks */
        .media-embed {
            position: absolute;
            background: #fff;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            pointer-events: auto;
            z-index: 3;
            min-width: 200px;
            min-height: 80px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            resize: none;
        }

        .media-embed:hover {
            border-color: #999;
        }

        .media-embed.selected {
            border-color: #007AFF;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.2);
        }

        /* Resize handle */
        .media-embed-resize {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 50%, rgba(0,0,0,0.1) 50%);
            border-radius: 0 0 6px 0;
            z-index: 10;
        }

        .media-embed:hover .media-embed-resize {
            background: linear-gradient(135deg, transparent 50%, rgba(0,0,0,0.25) 50%);
        }

        .media-embed-resize::after {
            content: '';
            position: absolute;
            bottom: 3px;
            right: 3px;
            width: 8px;
            height: 8px;
            border-right: 2px solid rgba(0,0,0,0.3);
            border-bottom: 2px solid rgba(0,0,0,0.3);
        }

        body.dark-mode .media-embed-resize {
            background: linear-gradient(135deg, transparent 50%, rgba(255,255,255,0.1) 50%);
        }

        body.dark-mode .media-embed:hover .media-embed-resize {
            background: linear-gradient(135deg, transparent 50%, rgba(255,255,255,0.25) 50%);
        }

        body.dark-mode .media-embed-resize::after {
            border-right-color: rgba(255,255,255,0.4);
            border-bottom-color: rgba(255,255,255,0.4);
        }

        .media-embed-content {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            overflow: hidden;
        }

        .media-embed img {
            width: 100%;
            height: 100%;
            object-fit: fill;
            display: block;
        }

        .media-embed video {
            width: 100%;
            height: 100%;
            object-fit: fill;
        }

        .media-embed iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        .media-embed-controls {
            position: absolute;
            top: 4px;
            right: 4px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.15s;
            pointer-events: auto;
            z-index: 10000;
        }

        .media-embed:hover .media-embed-controls {
            opacity: 1;
        }

        .media-embed-btn {
            width: 24px;
            height: 24px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .media-embed-btn:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        .media-embed-btn.active {
            outline: 2px solid rgba(255,255,255,0.12);
            box-shadow: 0 0 0 2px rgba(0,122,255,0.12) inset;
            background: rgba(0,122,255,0.9);
        }

        .media-embed-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: #666;
            font-size: 0.85rem;
        }

        .media-embed-error {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: #e53935;
            font-size: 0.85rem;
        }

        body.dark-mode .media-embed {
            background: #2a2a2a;
            border-color: #444;
        }

        body.dark-mode .media-embed:hover {
            border-color: #666;
        }

        body.dark-mode .media-embed-content {
            background: #333;
        }

        body.dark-mode .media-embed-loading,
        body.dark-mode .media-embed-error {
            color: #999;
        }

        /* Audio embed styles */
        .media-embed audio {
            width: 100%;
            margin-top: 10px;
        }

        .media-embed-audio-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        /* Drag and drop overlay */
        .canvas-container.drag-over {
            position: relative;
        }

        .canvas-container.drag-over::after {
            content: 'Drop media here';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 122, 255, 0.1);
            border: 3px dashed #007AFF;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: #007AFF;
            font-weight: 500;
            z-index: 1000;
            pointer-events: none;
        }

        body.dark-mode .canvas-container.drag-over::after {
            background: rgba(0, 122, 255, 0.2);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #fafafa;
        }

        /* Graph View */
        .graph-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 24px;
            background: #f8f9fa;
            position: relative;
            overflow: hidden;
        }

        .graph-header {
            margin-bottom: 16px;
            z-index: 10;
        }

        .graph-header h2 {
            color: #1a1a1a;
            margin: 0 0 4px 0;
            font-size: 1.5rem;
        }

        .graph-header p {
            color: rgba(0,0,0,0.6);
            margin: 0 0 16px 0;
            font-size: 0.9rem;
        }

        .graph-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .graph-search-input {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 8px 12px;
            color: #333;
            font-size: 0.9rem;
            width: 200px;
        }

        .graph-search-input::placeholder {
            color: #999;
        }

        .graph-search-input:focus {
            outline: none;
            border-color: #8b5cf6;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.2);
        }

        .graph-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 8px 12px;
            color: #333;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .graph-btn:hover {
            background: #f0f0f0;
            border-color: #ccc;
        }

        .graph-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #555;
            font-size: 0.85rem;
            cursor: pointer;
        }

        .graph-checkbox input {
            accent-color: #8b5cf6;
        }

        .graph-container {
            flex: 1;
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            background: radial-gradient(circle at 50% 50%, #ffffff 0%, #f0f0f5 100%);
            border: 1px solid #e0e0e0;
        }

        #graph-canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #graph-canvas:active {
            cursor: grabbing;
        }

        .graph-info-panel {
            position: absolute;
            right: 40px;
            top: 100px;
            width: 280px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ddd;
            border-radius: 12px;
            padding: 16px;
            backdrop-filter: blur(10px);
            z-index: 100;
            display: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .graph-info-panel.visible {
            display: block;
        }

        .graph-info-title {
            color: #1a1a1a;
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 8px;
        }

        .graph-info-content {
            color: #555;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        .graph-info-content .info-section {
            margin-bottom: 12px;
        }

        .graph-info-content .info-label {
            color: #888;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .graph-info-content .info-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .graph-info-content .tag {
            background: rgba(139, 92, 246, 0.2);
            color: #a78bfa;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
        }

        .graph-info-content .connection-item {
            padding: 6px 0;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background 0.2s;
        }

        .graph-info-content .connection-item:hover {
            background: rgba(0,0,0,0.03);
        }

        .graph-info-content .connection-item:last-child {
            border-bottom: none;
        }

        .graph-node-tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid #ddd;
        }

        /* Graph View Toggle */
        .graph-view-toggle {
            display: flex;
            background: #e8e8e8;
            border-radius: 8px;
            padding: 2px;
            gap: 2px;
        }

        .graph-toggle-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            background: transparent;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            color: #666;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .graph-toggle-btn:hover {
            color: #333;
            background: rgba(0,0,0,0.05);
        }

        .graph-toggle-btn.active {
            background: #8b5cf6;
            color: #fff;
        }

        /* Notes Overview */
        .notes-overview-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            border-radius: 12px;
            background: radial-gradient(circle at 50% 50%, #ffffff 0%, #f5f5f8 100%);
            border: 1px solid #e0e0e0;
        }

        .notes-overview-grid {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            padding: 40px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-content: flex-start;
        }

        .note-preview-card {
            width: 220px;
            height: 180px;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }

        .note-preview-card:hover {
            transform: scale(1.02);
            border-color: rgba(139, 92, 246, 0.5);
            box-shadow: 0 8px 32px rgba(139, 92, 246, 0.15);
        }

        .note-preview-header {
            padding: 12px;
            background: rgba(139, 92, 246, 0.08);
            border-bottom: 1px solid #eee;
        }

        .note-preview-title {
            color: #1a1a1a;
            font-weight: 600;
            font-size: 0.9rem;
            margin: 0 0 4px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .note-preview-meta {
            color: #888;
            font-size: 0.7rem;
        }

        .note-preview-content {
            flex: 1;
            padding: 10px 12px;
            overflow: hidden;
            position: relative;
        }

        .note-preview-text {
            color: #555;
            font-size: 0.75rem;
            line-height: 1.5;
            max-height: 100%;
            overflow: hidden;
        }

        .note-preview-canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 4px;
        }

        .note-preview-content::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: linear-gradient(transparent, #fff);
            pointer-events: none;
        }

        .notes-zoom-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .notes-zoom-level {
            background: #e8e8e8;
            color: #333;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            min-width: 50px;
            text-align: center;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            align-items: center;
            padding: 12px 24px;
            background: #fff;
            border-bottom: 1px solid #e8e8e8;
            gap: 24px;
            flex-wrap: wrap;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: #e8e8e8;
            margin: 0 8px;
        }

        .tool-btn {
            background: transparent;
            border: 1px solid transparent;
            color: #666;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 0.8rem;
            font-weight: 450;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tool-btn:hover {
            background: #f5f5f5;
            color: #333;
        }

        .tool-btn.active {
            background: #333;
            color: #fff;
        }

        .tool-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Formatting buttons and highlight swatches */
        .format-btn {
            min-width: 36px;
            padding: 6px 10px;
            font-weight: 600;
        }

        .highlight-palette {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .highlight-swatch {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.08);
            padding: 0;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
            cursor: pointer;
        }

        .highlight-swatch.active {
            outline: 2px solid rgba(0,0,0,0.12);
            transform: translateY(-1px);
        }

        .color-picker {
            width: 32px;
            height: 32px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            background: none;
            padding: 2px;
        }

        .thickness-slider {
            width: 80px;
            accent-color: #333;
            height: 4px;
        }

        .font-select {
            background: #fff;
            color: #444;
            border: 1px solid #e0e0e0;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            font-family: inherit;
        }

        .font-select:focus {
            outline: none;
            border-color: #333;
        }

        .zoom-display {
            background: #f5f5f5;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            min-width: 50px;
            text-align: center;
            color: #666;
            font-weight: 500;
        }

        .toolbar-label {
            font-size: 0.7rem;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            font-weight: 500;
        }

        /* Canvas Area */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #fff;
            /* Prevent browser default touch gestures so we can handle pinch-zoom ourselves */
            touch-action: none;
        }

        .canvas-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center center;
            touch-action: none;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
            visibility: hidden;
            background-image: radial-gradient(circle, #b0b0b0 1px, transparent 1px);
            background-size: 30px 30px;
        }

        .grid-overlay.visible {
            visibility: visible;
        }

        .grid-canvas {
            display: none;
        }

        .drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            background: transparent;
            z-index: 2;
            touch-action: none;
        }

        /* Layer canvases */
        .layer-canvas {
            position: absolute;
            top: 0;
            left: 0;
            background: transparent;
            touch-action: none;
        }

        .eraser-cursor {
            position: fixed;
            border-radius: 50%;
            border: 2px solid rgba(0,0,0,0.18);
            background: rgba(255, 255, 255, 0.95);
            pointer-events: none;
            z-index: 999999;
            transform: translate(-50%, -50%);
            display: block; /* always in DOM so transitions work */
            opacity: 0;
            box-shadow: 0 6px 18px rgba(0,0,0,0.18);
            transition: width 0.08s ease, height 0.08s ease, opacity 0.12s ease, transform 0.12s ease;
            mix-blend-mode: normal;
        }

        .eraser-cursor.visible {
            opacity: 1;
        }

        /* Version History Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .modal-overlay.hidden {
            display: none;
        }

        .version-modal {
            background: #fff;
            border-radius: 12px;
            width: 400px;
            max-height: 70vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .version-modal-header {
            padding: 20px;
            border-bottom: 1px solid #e8e8e8;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .version-modal-header h3 {
            font-size: 1rem;
            font-weight: 600;
        }

        .modal-close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
            padding: 0;
            line-height: 1;
        }

        .modal-close-btn:hover {
            color: #333;
        }

        .version-list {
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
        }

        .version-item {
            padding: 12px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .version-item:hover {
            background: #f5f5f5;
        }

        .version-time {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .version-restore-btn {
            background: #333;
            color: #fff;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .version-item:hover .version-restore-btn {
            opacity: 1;
        }

        .version-restore-btn:hover {
            background: #555;
        }

        .no-versions {
            padding: 40px 20px;
            text-align: center;
            color: #999;
        }

        .tool-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Media Dropdown Menu */
        .media-dropdown {
            position: relative;
            display: inline-block;
        }

        .media-dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #fff;
            min-width: 140px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            z-index: 100;
            overflow: hidden;
            margin-top: 4px;
        }

        .media-dropdown-content.show {
            display: block;
        }

        .media-dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            cursor: pointer;
            font-size: 0.85rem;
            color: #333;
            transition: background 0.15s ease;
            border: none;
            background: transparent;
            width: 100%;
            text-align: left;
        }

        .media-dropdown-item:hover {
            background: #f5f5f5;
        }

        .media-dropdown-item svg {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }

        body.dark-mode .media-dropdown-content {
            background: #2a2a2a;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        body.dark-mode .media-dropdown-item {
            color: #e0e0e0;
        }

        body.dark-mode .media-dropdown-item:hover {
            background: #3a3a3a;
        }

        /* Link Embed Modal */
        .link-embed-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .link-embed-modal.show {
            display: flex;
        }

        .link-embed-dialog {
            background: #fff;
            border-radius: 12px;
            padding: 24px;
            width: 400px;
            max-width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .link-embed-dialog h3 {
            margin: 0 0 16px 0;
            font-size: 1.1rem;
            color: #333;
        }

        .link-embed-dialog input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 0.95rem;
            margin-bottom: 16px;
            box-sizing: border-box;
        }

        .link-embed-dialog input:focus {
            outline: none;
            border-color: #007AFF;
        }

        .link-embed-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .link-embed-btn {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.15s ease;
        }

        .link-embed-btn.cancel {
            background: #e0e0e0;
            color: #333;
        }

        .link-embed-btn.cancel:hover {
            background: #d0d0d0;
        }

        .link-embed-btn.embed {
            background: #007AFF;
            color: #fff;
        }

        .link-embed-btn.embed:hover {
            background: #0066DD;
        }

        body.dark-mode .link-embed-dialog {
            background: #2a2a2a;
        }

        body.dark-mode .link-embed-dialog h3 {
            color: #e0e0e0;
        }

        body.dark-mode .link-embed-dialog input {
            background: #333;
            border-color: #444;
            color: #e0e0e0;
        }

        body.dark-mode .link-embed-dialog input:focus {
            border-color: #007AFF;
        }

        body.dark-mode .link-embed-btn.cancel {
            background: #444;
            color: #e0e0e0;
        }

        body.dark-mode .link-embed-btn.cancel:hover {
            background: #555;
        }

        .media-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 499;
        }

        .media-layer .media-embed {
            pointer-events: auto;
        }

        .text-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 500;
        }

        /* In select mode, text layer needs pointer events */
        .text-layer .text-box {
            pointer-events: auto !important;
        }

        /* Layer content containers */
        .layer-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .layer-content .text-box,
        .layer-content .media-embed,
        .text-layer .text-box {
            pointer-events: auto !important;
            cursor: pointer;
        }

        /* Ensure media embed is clickable */
        .media-embed {
            cursor: pointer;
        }

        .text-box {
            position: absolute;
            background: transparent;
            border: 1.5px dashed #999;
            padding: 8px;
            min-width: 100px;
            min-height: 30px;
            outline: none;
            pointer-events: auto;
            resize: both;
            overflow: auto;
            border-radius: 4px;
            z-index: 501;
            cursor: text;
        }

        .text-box:focus {
            border-color: #333;
        }

        .text-box.placed {
            border: 1px solid transparent;
        }

        .text-box.placed:hover {
            border: 1px dashed #ccc;
            background: rgba(0, 0, 0, 0.02);
            cursor: move;
        }

        .text-box.selected {
            border: 2px solid #007AFF !important;
            background: rgba(0, 122, 255, 0.05);
            cursor: move;
        }

        .text-box.dragging {
            opacity: 0.8;
            cursor: grabbing !important;
            user-select: none;
        }

        /* Status Bar */
        .status-bar {
            padding: 10px 24px;
            background: #fff;
            font-size: 0.75rem;
            color: #999;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid #e8e8e8;
        }

        .save-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .save-indicator.saving {
            color: #f59e0b;
            background: rgba(245, 158, 11, 0.1);
        }

        .save-indicator.saving .save-dot {
            animation: pulse 1s ease-in-out infinite;
        }

        .save-indicator.saved {
            color: #10b981;
        }

        .save-indicator.unsaved {
            color: #999;
        }

        .save-indicator.just-saved {
            color: #10b981;
            background: rgba(16, 185, 129, 0.1);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-2px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes toastFadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(10px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        @keyframes toastFadeOut {
            from { opacity: 1; transform: translateX(-50%) translateY(0); }
            to { opacity: 0; transform: translateX(-50%) translateY(10px); }
        }

        .save-indicator.just-saved {
            animation: fadeIn 0.3s ease;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(4px);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #fff;
            padding: 32px;
            border-radius: 16px;
            min-width: 340px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.15);
        }

        .modal-content h2 {
            margin-bottom: 24px;
            color: #333;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .modal-input {
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 24px;
            background: #fafafa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            color: #333;
            font-size: 0.9rem;
            font-family: inherit;
            transition: border-color 0.15s ease;
        }

        .modal-input:focus {
            outline: none;
            border-color: #333;
            background: #fff;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            font-family: inherit;
            transition: all 0.15s ease;
        }

        .modal-btn.primary {
            background: #333;
            color: white;
        }

        .modal-btn.primary:hover {
            background: #555;
        }

        .modal-btn.secondary {
            background: #f5f5f5;
            color: #666;
        }

        .modal-btn.secondary:hover {
            background: #e8e8e8;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #ddd;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #ccc;
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #999;
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 16px;
            opacity: 0.4;
        }

        .empty-state p {
            font-size: 0.9rem;
            font-weight: 400;
        }

        /* Sidebar Navigation */
        .sidebar-nav {
            padding: 16px;
            border-bottom: 1px solid #e8e8e8;
        }

        .nav-item {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.875rem;
            color: #666;
            transition: all 0.15s ease;
            gap: 10px;
        }

        .nav-item:hover {
            background: #f5f5f5;
            color: #333;
        }

        .nav-item.active {
            background: #333;
            color: #fff;
        }

        .nav-item svg {
            width: 16px;
            height: 16px;
        }

        /* Home Page */
        .home-page {
            flex: 1;
            overflow-y: auto;
            padding: 40px;
            background: #fafafa;
        }

        .home-page.hidden {
            display: none;
        }

        .home-header {
            margin-bottom: 64px;
            display: flex;
            align-items: center;
        }

        .home-header-text {
            display: flex;
            flex-direction: column;
        }

        .home-header h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 16px;
        }

        .home-header p {
            color: #999;
            font-size: 0.9rem;
            margin-top: 0;
        }
        
        .back-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.5rem;
            margin-right: 12px;
            color: #666;
            padding: 8px;
            border-radius: 8px;
            transition: background 0.2s;
        }
        
        .back-btn:hover {
            background: #f0f0f0;
            color: #333;
        }
        
        body.dark-mode .back-btn {
            color: #aaa;
        }
        
        body.dark-mode .back-btn:hover {
            background: #333;
            color: #fff;
        }

        .home-section {
            margin-bottom: 40px;
        }

        .home-section-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #999;
            margin-bottom: 16px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .home-section-title .notebook-sort-select {
            text-transform: none;
            letter-spacing: normal;
        }

        /* Dark mode button on home page */
        .home-dark-mode-btn {
            background: none;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 6px 8px;
            cursor: pointer;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .home-dark-mode-btn:hover {
            background: #f0f0f0;
            border-color: #ccc;
            color: #333;
        }

        body.dark-mode .home-dark-mode-btn {
            border-color: #444;
            color: #aaa;
        }

        body.dark-mode .home-dark-mode-btn:hover {
            background: #333;
            border-color: #555;
            color: #fff;
        }

        body.dark-mode .home-dark-mode-btn .sun-icon {
            display: none !important;
        }

        body.dark-mode .home-dark-mode-btn .moon-icon {
            display: block !important;
        }

        /* Toolbar dark mode button icon toggle */
        body.dark-mode #dark-mode-btn .sun-icon {
            display: none !important;
        }

        body.dark-mode #dark-mode-btn .moon-icon {
            display: inline-block !important;
        }

        /* Drag and drop styles for custom sorting */
        .notebook-card.dragging,
        .notebook.dragging {
            opacity: 0.5;
            background: #f0f0f0;
        }

        .notebook-card.drag-over,
        .notebook.drag-over {
            border: 2px dashed #007aff;
            background: rgba(0, 122, 255, 0.05);
        }

        .notebook-card {
            cursor: grab;
        }

        .notebook-card:active {
            cursor: grabbing;
        }

        body.dark-mode .notebook-card.dragging,
        body.dark-mode .notebook.dragging {
            background: #333;
        }

        body.dark-mode .notebook-card.drag-over,
        body.dark-mode .notebook.drag-over {
            border-color: #0a84ff;
            background: rgba(10, 132, 255, 0.1);
        }

        .pinned-card.dragging {
            opacity: 0.5;
        }

        .pinned-card.drag-over {
            border: 2px dashed #007aff;
            background: rgba(0, 122, 255, 0.05);
        }

        .pinned-card {
            cursor: grab;
        }

        .pinned-card:active {
            cursor: grabbing;
        }

        .notebook-card.drop-target,
        .notebook.drop-target {
            border: 2px solid #34c759;
            background: rgba(52, 199, 89, 0.1);
        }

        body.dark-mode .notebook-card.drop-target,
        body.dark-mode .notebook.drop-target {
            border-color: #30d158;
            background: rgba(48, 209, 88, 0.1);
        }

        /* Drop position indicators for wedging between items */
        .drop-before {
            border-top: 3px solid #007aff !important;
        }

        .drop-after {
            border-bottom: 3px solid #007aff !important;
        }

        .note-item-container.drop-before,
        .note-item-container.drop-after {
            background: rgba(0, 122, 255, 0.05);
        }

        /* Drop INTO a note (make it a sub-note) */
        .drop-into,
        .note-item-container.drop-into {
            background: rgba(52, 199, 89, 0.15) !important;
            border: 2px solid #34c759 !important;
            border-radius: 6px;
        }

        body.dark-mode .drop-into,
        body.dark-mode .note-item-container.drop-into {
            background: rgba(48, 209, 88, 0.15) !important;
            border-color: #30d158 !important;
        }

        body.dark-mode .drop-before {
            border-top-color: #0a84ff !important;
        }

        body.dark-mode .drop-after {
            border-bottom-color: #0a84ff !important;
        }
        
        /* Highlight animation for just-moved notes */
        .just-moved {
            animation: justMovedPulse 2s ease-out;
        }
        
        @keyframes justMovedPulse {
            0% {
                background: rgba(52, 199, 89, 0.4);
                box-shadow: 0 0 12px rgba(52, 199, 89, 0.6);
            }
            50% {
                background: rgba(52, 199, 89, 0.2);
                box-shadow: 0 0 6px rgba(52, 199, 89, 0.3);
            }
            100% {
                background: transparent;
                box-shadow: none;
            }
        }
        
        body.dark-mode .just-moved {
            animation: justMovedPulseDark 2s ease-out;
        }
        
        @keyframes justMovedPulseDark {
            0% {
                background: rgba(48, 209, 88, 0.4);
                box-shadow: 0 0 12px rgba(48, 209, 88, 0.6);
            }
            50% {
                background: rgba(48, 209, 88, 0.2);
                box-shadow: 0 0 6px rgba(48, 209, 88, 0.3);
            }
            100% {
                background: transparent;
                box-shadow: none;
            }
        }

        .drag-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.85rem;
            z-index: 10000;
            pointer-events: none;
        }

        body.dark-mode .drag-hint {
            background: rgba(255,255,255,0.9);
            color: #333;
        }

        .pinned-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 16px;
        }

        .pinned-card {
            background: #fff;
            border: 1px solid #e8e8e8;
            border-radius: 12px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
        }

        .pinned-card:hover {
            border-color: #ddd;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        .pinned-card-preview {
            width: 100%;
            height: 100px;
            background: #f5f5f5;
            border-radius: 8px;
            margin-bottom: 12px;
            overflow: hidden;
            pointer-events: none;
        }

        .pinned-card-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            pointer-events: none;
        }

        .pinned-card-title {
            font-size: 0.9rem;
            font-weight: 500;
            color: #333;
            margin-bottom: 4px;
            pointer-events: none;
        }

        .pinned-card-notebook {
            font-size: 0.75rem;
            color: #999;
            pointer-events: none;
        }

        .unpin-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: all 0.15s ease;
            font-size: 0.8rem;
            /* Keep pointer-events for unpin button */
        }

        .pinned-card:hover .unpin-btn {
            opacity: 1;
        }

        .unpin-btn:hover {
            background: #fee2e2;
            border-color: #fecaca;
            color: #dc2626;
        }

        .notebooks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 16px;
        }

        .notebook-card {
            background: #fff;
            border: 1px solid #e8e8e8;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .notebook-card:hover {
            border-color: #ddd;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        .notebook-card-icon {
            font-size: 1.5rem;
            margin-bottom: 12px;
            opacity: 0.6;
            pointer-events: none;
        }

        .notebook-card-name {
            font-size: 0.9rem;
            font-weight: 500;
            color: #333;
            margin-bottom: 4px;
            pointer-events: none;
        }

        .notebook-card-count {
            font-size: 0.75rem;
            color: #999;
            pointer-events: none;
        }

        .notebook-card-pin {
            position: absolute;
            top: 8px;
            right: 8px;
            color: #f5a623;
            font-size: 0.8rem;
            pointer-events: none;
        }

        .notebook-card {
            position: relative;
        }

        .empty-pinned {
            background: #f5f5f5;
            border: 2px dashed #e0e0e0;
            border-radius: 12px;
            padding: 32px;
            text-align: center;
            color: #999;
        }

        .empty-pinned p {
            font-size: 0.85rem;
        }

        /* Pin button in note item */
        .pin-btn {
            opacity: 0;
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.15s ease;
            margin-right: 4px;
        }

        .pin-btn:hover {
            color: #f59e0b;
            background: rgba(245, 158, 11, 0.1);
        }

        .pin-btn.pinned {
            opacity: 1;
            color: #f59e0b;
        }

        .note-item:hover .pin-btn {
            opacity: 1;
        }
    </style>
    
    <!-- External Modules -->
    <script src="js/canvas.js"></script>
    <script src="js/evernote.js"></script>
    <script src="js/graph.js"></script>
</head>
<body>
    <!-- Sidebar -->
    <div class="sidebar">
        <div class="sidebar-header">
            <h1>Notes</h1>
        </div>
        <div class="sidebar-nav">
            <div class="nav-item active" id="nav-home" onclick="showHomePage()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
                Home
            </div>
            <div class="nav-item" id="nav-graph" onclick="showGraphView()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="5" cy="6" r="3"/><circle cx="19" cy="6" r="3"/><circle cx="12" cy="18" r="3"/><line x1="7.5" y1="7.5" x2="10" y2="16"/><line x1="16.5" y1="7.5" x2="14" y2="16"/><line x1="8" y1="6" x2="16" y2="6"/></svg>
                Graph View
            </div>
        </div>
        <div class="notebooks-section">
            <div class="section-title">
                <span>Notebooks</span>
                <select id="notebook-sort" class="notebook-sort-select" onchange="setNotebookSort(this.value)" title="Sort notebooks">
                    <option value="pinned"> Pinned</option>
                    <option value="alphabetical">A-Z</option>
                    <option value="recent">Recent</option>
                    <option value="custom">Custom</option>
                </select>
                <button class="add-btn" onclick="triggerEvernoteImport()" title="Import from Evernote"></button>
                <button class="add-btn" onclick="showModal('notebook')" title="New Notebook">+</button>
            </div>
            <div id="notebooks-container"></div>
            <input type="file" id="evernote-import" accept=".enex" style="display:none" onchange="handleEvernoteImport(event)">
            <!-- AI Portal: Summarize / Ask local LLM -->
            <div id="ai-portal" style="padding:12px;margin-top:12px;border-top:1px solid rgba(0,0,0,0.06);font-family:Inter, sans-serif;">
                <div style="font-weight:700;margin-bottom:8px;">AI Tools</div>
                <textarea id="ai-prompt" placeholder="Summarize notes" style="width:100%;height:64px;margin-bottom:8px;padding:8px;border-radius:6px;border:1px solid #e6e6e6;resize:vertical;font-family:inherit;"></textarea>
                <!-- AI action buttons removed per user request -->
                <div id="ai-result" style="margin-top:8px;font-size:0.9rem;color:#222;white-space:pre-wrap;min-height:24px;"></div>
                <script>
                    (function() {
                        const ta = document.getElementById('ai-prompt');
                        if (!ta) return;
                        // Enter runs AI; Shift+Enter inserts newline
                        ta.addEventListener('keydown', function(e) {
                            if (e.key === 'Enter' && !e.shiftKey) {
                                e.preventDefault();
                                const val = ta.value.trim();
                                if (val) {
                                    if (typeof askCustomPrompt === 'function') askCustomPrompt();
                                } else {
                                    if (typeof summarizeCurrentNote === 'function') summarizeCurrentNote();
                                }
                            }
                        });
                    })();
                    // AI helper functions: send prompt to local AI bridge
                    async function askCustomPrompt() {
                        const ta = document.getElementById('ai-prompt');
                        const resultDiv = document.getElementById('ai-result');
                        const prompt = (ta && ta.value) ? ta.value.trim() : '';
                        if (!prompt) return summarizeCurrentNote();

                        resultDiv.textContent = 'Thinking...';

                        try {
                            const resp = await fetch('http://127.0.0.1:3000/api/ai', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ prompt })
                            });
                            const json = await resp.json();
                            if (!resp.ok) {
                                resultDiv.textContent = 'Error: ' + (json && (json.error || json.detail) ? (json.error || json.detail) : resp.statusText);
                            } else {
                                resultDiv.textContent = (json && json.text) ? json.text : JSON.stringify(json, null, 2);
                            }
                        } catch (e) {
                            resultDiv.textContent = 'Error connecting to local AI bridge: ' + (e && e.message ? e.message : e);
                        }
                    }

                    // Gather current note text boxes and ask the model to summarize
                    async function summarizeCurrentNote() {
                        const resultDiv = document.getElementById('ai-result');
                        const boxes = Array.from(document.querySelectorAll('.text-box'));
                        if (boxes.length === 0) {
                            resultDiv.textContent = 'No text to summarize.';
                            return;
                        }

                        const combined = boxes.map(b => b.textContent.trim()).filter(Boolean).join('\n\n');
                        if (!combined) {
                            resultDiv.textContent = 'No text to summarize.';
                            return;
                        }

                        const prompt = `Please provide a concise summary of the following notes:\n\n${combined}`;
                        // Reuse askCustomPrompt implementation by filling textarea temporarily
                        const ta = document.getElementById('ai-prompt');
                        const prev = ta ? ta.value : '';
                        if (ta) ta.value = prompt;
                        try {
                            await askCustomPrompt();
                        } finally {
                            if (ta) ta.value = prev;
                        }
                    }
                </script>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Home Page -->
        <div class="home-page" id="home-page">
            <div class="home-header">
                <div class="home-header-text">
                    <h2>Welcome back</h2>
                    <p>Your notebooks and pinned notes</p>
                </div>
            </div>
            
            <div class="home-section">
                <div class="home-section-title">Pinned Notes</div>
                <div id="pinned-container" class="pinned-grid"></div>
            </div>
            
            <div class="home-section">
                <div class="home-section-title">
                    <span>All Notebooks</span>
                    <select id="notebook-sort-home" class="notebook-sort-select" onchange="setNotebookSort(this.value)" title="Sort notebooks">
                        <option value="pinned"> Pinned</option>
                        <option value="alphabetical">A-Z</option>
                        <option value="recent">Recent</option>
                        <option value="custom">Custom</option>
                    </select>
                    <button class="home-dark-mode-btn" onclick="toggleDarkMode()" title="Toggle Dark Mode">
                        <svg class="sun-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                        <svg class="moon-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display:none;">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                    </button>
                </div>
                <div id="notebooks-home-container" class="notebooks-grid"></div>
            </div>
        </div>
        
        <!-- Notebook Detail Page (sub-homepage) -->
        <div class="home-page" id="notebook-detail-page" style="display: none;">
            <div class="home-header">
                <button class="back-btn" onclick="goBackFromNotebook()" style="background:none;border:none;cursor:pointer;font-size:1.5rem;margin-right:12px;color:#666;"></button>
                <div>
                    <h2 id="notebook-detail-title">Notebook</h2>
                    <p id="notebook-detail-path">Path</p>
                </div>
            </div>
            
            <div class="home-section" id="subnotebooks-section">
                <div class="home-section-title">
                    <span>Sub-Notebooks</span>
                    <select id="subnotebook-sort" class="notebook-sort-select" onchange="setSubNotebookSort(this.value)" title="Sort sub-notebooks">
                        <option value="alphabetical">A-Z</option>
                        <option value="recent">Recent</option>
                        <option value="custom">Custom</option>
                    </select>
                </div>
                <div id="subnotebooks-container" class="notebooks-grid"></div>
            </div>
            
            <div class="home-section">
                <div class="home-section-title">
                    <span>Notes</span>
                    <select id="notes-sort" class="notebook-sort-select" onchange="setNotesSort(this.value)" title="Sort notes">
                        <option value="alphabetical">A-Z</option>
                        <option value="recent">Recent</option>
                        <option value="custom">Custom</option>
                    </select>
                </div>
                <div id="notebook-notes-container" class="pinned-grid"></div>
            </div>
        </div>
        
        <!-- Graph View -->
        <div class="graph-view" id="graph-view" style="display: none;">
            <div class="graph-header">
                <h2>Knowledge Graph</h2>
                <p>Notes connected by shared terms and patterns</p>
                <div class="graph-controls">
                    <div class="graph-view-toggle">
                        <button class="graph-toggle-btn active" id="toggle-graph-view" onclick="switchGraphMode('graph')" title="Graph View">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><circle cx="12" cy="12" r="3"/><circle cx="4" cy="6" r="2"/><circle cx="20" cy="6" r="2"/><circle cx="4" cy="18" r="2"/><circle cx="20" cy="18" r="2"/><path d="M12 9V6M12 15v3M9 12H6M15 12h3"/></svg>
                            Graph
                        </button>
                        <button class="graph-toggle-btn" id="toggle-notes-view" onclick="switchGraphMode('notes')" title="Notes Overview">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg>
                            Notes
                        </button>
                    </div>
                    <input type="text" id="graph-search" placeholder="Search nodes..." class="graph-search-input">
                    <button class="graph-btn" onclick="resetGraphView()" title="Reset View">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                        Reset
                    </button>
                    <label class="graph-checkbox" id="orphans-checkbox">
                        <input type="checkbox" id="graph-show-orphans" checked> Show unconnected
                    </label>
                    <div class="notes-zoom-controls" id="header-zoom-controls" style="display: none;">
                        <button class="graph-btn" onclick="graphView.zoomNotesView(-0.2)" title="Zoom Out"></button>
                        <span class="notes-zoom-level" id="notes-zoom-level">100%</span>
                        <button class="graph-btn" onclick="graphView.zoomNotesView(0.2)" title="Zoom In">+</button>
                    </div>
                </div>
            </div>
            <div class="graph-container" id="graph-container">
                <canvas id="graph-canvas"></canvas>
            </div>
            <!-- Notes Overview Container -->
            <div class="notes-overview-container" id="notes-overview-container" style="display: none;">
                <div class="notes-overview-grid" id="notes-overview-grid"></div>
            </div>
            <div class="graph-info-panel" id="graph-info-panel">
                <div class="graph-info-title">Select a note</div>
                <div class="graph-info-content"></div>
            </div>
        </div>
        
        <div class="toolbar" id="toolbar" style="display: none;">
            <div class="toolbar-group">
                <button class="tool-btn active" id="draw-btn" onclick="setTool('draw')" title="Draw">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/></svg>
                    Draw
                </button>
                <button class="tool-btn" id="select-btn" onclick="setTool('select')" title="Select (S)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="M13 13l6 6"/></svg>
                    Select
                </button>
                <button class="tool-btn" id="erase-btn" onclick="setTool('erase')" title="Eraser">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 20H7L3 16c-.6-.6-.6-1.5 0-2.1l10-10c.6-.6 1.5-.6 2.1 0l6 6c.6.6.6 1.5 0 2.1L13 20"/><path d="M6 11l8 8"/></svg>
                    Erase
                </button>
                <button class="tool-btn" id="text-btn" onclick="setTool('text')" title="Text">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 7V4h16v3"/><path d="M9 20h6"/><path d="M12 4v16"/></svg>
                    Text
                </button>
                <button class="tool-btn" id="pan-btn" onclick="setTool('pan')" title="Pan">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0"/><path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2"/><path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8"/><path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/></svg>
                    Pan
                </button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <span class="toolbar-label">Headers</span>
                <button class="tool-btn header-btn" id="header-1-btn" onclick="insertHeader(1)" title="Header 1 - Click then click canvas to place">H1</button>
                <button class="tool-btn header-btn" id="header-2-btn" onclick="insertHeader(2)" title="Header 2 - Click then click canvas to place">H2</button>
                <button class="tool-btn header-btn" id="header-3-btn" onclick="insertHeader(3)" title="Header 3 - Click then click canvas to place">H3</button>
                <button class="tool-btn" onclick="toggleOutline()" id="outline-btn" title="Toggle Outline">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px">
                        <line x1="8" y1="6" x2="21" y2="6"/>
                        <line x1="8" y1="12" x2="21" y2="12"/>
                        <line x1="8" y1="18" x2="21" y2="18"/>
                        <line x1="3" y1="6" x2="3.01" y2="6"/>
                        <line x1="3" y1="12" x2="3.01" y2="12"/>
                        <line x1="3" y1="18" x2="3.01" y2="18"/>
                    </svg>
                </button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <span class="toolbar-label">Color</span>
                <input type="color" class="color-picker" id="color-picker" value="#333333">
            </div>
            
            <div class="toolbar-group">
                <span class="toolbar-label">Size</span>
                <input type="range" class="thickness-slider" id="thickness-slider" min="1" max="50" value="3">
                <span id="thickness-value" style="font-size: 0.75rem; color: #666; min-width: 30px;">3px</span>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <span class="toolbar-label">Font</span>
                <select class="font-select" id="font-select">
                    <optgroup label="Sans Serif">
                        <option value="'Inter', sans-serif" style="font-family: 'Inter', sans-serif">Inter</option>
                        <option value="'Open Sans', sans-serif" style="font-family: 'Open Sans', sans-serif">Open Sans</option>
                        <option value="'Montserrat', sans-serif" style="font-family: 'Montserrat', sans-serif">Montserrat</option>
                        <option value="'Poppins', sans-serif" style="font-family: 'Poppins', sans-serif">Poppins</option>
                        <option value="'Raleway', sans-serif" style="font-family: 'Raleway', sans-serif">Raleway</option>
                    </optgroup>
                    <optgroup label="Serif">
                        <option value="Georgia, serif" style="font-family: Georgia, serif">Georgia</option>
                        <option value="'Playfair Display', serif" style="font-family: 'Playfair Display', serif">Playfair</option>
                        <option value="'Lora', serif" style="font-family: 'Lora', serif">Lora</option>
                        <option value="'Merriweather', serif" style="font-family: 'Merriweather', serif">Merriweather</option>
                    </optgroup>
                    <optgroup label="Monospace">
                        <option value="'Courier Prime', monospace" style="font-family: 'Courier Prime', monospace">Courier</option>
                        <option value="'Roboto Mono', monospace" style="font-family: 'Roboto Mono', monospace">Roboto Mono</option>
                        <option value="'Source Code Pro', monospace" style="font-family: 'Source Code Pro', monospace">Source Code Pro</option>
                        <option value="'Fira Code', monospace" style="font-family: 'Fira Code', monospace">Fira Code</option>
                    </optgroup>
                    <optgroup label="Handwriting">
                        <option value="'Comic Neue', cursive" style="font-family: 'Comic Neue', cursive">Comic Neue</option>
                        <option value="'Dancing Script', cursive" style="font-family: 'Dancing Script', cursive">Dancing Script</option>
                        <option value="'Pacifico', cursive" style="font-family: 'Pacifico', cursive">Pacifico</option>
                        <option value="'Caveat', cursive" style="font-family: 'Caveat', cursive">Caveat</option>
                        <option value="'Architects Daughter', cursive" style="font-family: 'Architects Daughter', cursive">Architects Daughter</option>
                        <option value="'Patrick Hand', cursive" style="font-family: 'Patrick Hand', cursive">Patrick Hand</option>
                        <option value="'Shadows Into Light', cursive" style="font-family: 'Shadows Into Light', cursive">Shadows Into Light</option>
                        <option value="'Permanent Marker', cursive" style="font-family: 'Permanent Marker', cursive">Permanent Marker</option>
                        <option value="'Satisfy', cursive" style="font-family: 'Satisfy', cursive">Satisfy</option>
                    </optgroup>
                </select>
                <select class="font-select" id="font-size-select">
                    <option value="12">12</option>
                    <option value="16" selected>16</option>
                    <option value="20">20</option>
                    <option value="24">24</option>
                    <option value="32">32</option>
                    <option value="48">48</option>
                </select>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <span class="toolbar-label">Format</span>
                <button class="tool-btn format-btn" id="bold-btn" onclick="formatText('bold')" title="Bold (Ctrl+B)"><strong>B</strong></button>
                <button class="tool-btn format-btn" id="italic-btn" onclick="formatText('italic')" title="Italic (Ctrl+I)"><em>I</em></button>
                <button class="tool-btn format-btn" id="underline-btn" onclick="formatText('underline')" title="Underline (Ctrl+U)"><span style="text-decoration:underline">U</span></button>
                <button class="tool-btn format-btn" id="strike-btn" onclick="formatText('strikeThrough')" title="Strikethrough"><span style="text-decoration:line-through">S</span></button>
                <div class="highlight-palette" title="Highlight">
                    <button class="tool-btn highlight-swatch" data-color="#fff7d6" style="background:#fff7d6" onclick="applyHighlight('#fff7d6')" aria-label="Pastel Yellow"></button>
                    <button class="tool-btn highlight-swatch" data-color="#ffd6e0" style="background:#ffd6e0" onclick="applyHighlight('#ffd6e0')" aria-label="Pastel Pink"></button>
                    <button class="tool-btn highlight-swatch" data-color="#e6f7ff" style="background:#e6f7ff" onclick="applyHighlight('#e6f7ff')" aria-label="Pastel Blue"></button>
                    <button class="tool-btn highlight-swatch" data-color="#e8ffef" style="background:#e8ffef" onclick="applyHighlight('#e8ffef')" aria-label="Pastel Green"></button>
                    <button class="tool-btn highlight-swatch" data-color="#f3e8ff" style="background:#f3e8ff" onclick="applyHighlight('#f3e8ff')" aria-label="Pastel Purple"></button>
                </div>
            </div>
            
            <div class="toolbar-group">
                <button class="tool-btn" onclick="zoomOut()"></button>
                <span class="zoom-display" id="zoom-display">100%</span>
                <button class="tool-btn" onclick="zoomIn()">+</button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <button class="tool-btn" id="grid-btn" onclick="toggleGrid()" title="Toggle Grid">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px">
                        <circle cx="4" cy="4" r="1"/><circle cx="12" cy="4" r="1"/><circle cx="20" cy="4" r="1"/>
                        <circle cx="4" cy="12" r="1"/><circle cx="12" cy="12" r="1"/><circle cx="20" cy="12" r="1"/>
                        <circle cx="4" cy="20" r="1"/><circle cx="12" cy="20" r="1"/><circle cx="20" cy="20" r="1"/>
                    </svg>
                    Grid
                </button>
                <button class="tool-btn" id="layers-btn" onclick="toggleLayerPanel()" title="Toggle Layers Panel">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px">
                        <polygon points="12 2 2 7 12 12 22 7 12 2"/>
                        <polyline points="2 17 12 22 22 17"/>
                        <polyline points="2 12 12 17 22 12"/>
                    </svg>
                    Layers
                </button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <button class="tool-btn" id="undo-btn" onclick="undo()" title="Undo (Ctrl+Z)" disabled>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px">
                        <path d="M3 10h10c4.4 0 8 3.6 8 8v0"/>
                        <polyline points="7 14 3 10 7 6"/>
                    </svg>
                </button>
                <button class="tool-btn" id="redo-btn" onclick="redo()" title="Redo (Ctrl+Y)" disabled>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px">
                        <path d="M21 10H11c-4.4 0-8 3.6-8 8v0"/>
                        <polyline points="17 14 21 10 17 6"/>
                    </svg>
                </button>
                <button class="tool-btn" onclick="showVersionHistory()" title="Version History">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12 6 12 12 16 14"/>
                    </svg>
                </button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <div class="media-dropdown">
                    <button class="tool-btn" onclick="toggleMediaDropdown(event)" title="Add Media">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                            <circle cx="8.5" cy="8.5" r="1.5"/>
                            <polyline points="21 15 16 10 5 21"/>
                        </svg>
                        Media
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px;margin-left:2px">
                            <polyline points="6 9 12 15 18 9"/>
                        </svg>
                    </button>
                    <div class="media-dropdown-content" id="media-dropdown">
                        <button class="media-dropdown-item" onclick="showYouTubeDialog()">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                            </svg>
                            YouTube Video
                        </button>
                        <button class="media-dropdown-item" onclick="showLinkEmbedDialog()">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
                                <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
                            </svg>
                            Embed Link
                        </button>
                        <button class="media-dropdown-item" onclick="triggerMediaUpload()">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                <polyline points="17 8 12 3 7 8"/>
                                <line x1="12" y1="3" x2="12" y2="15"/>
                            </svg>
                            Upload File
                        </button>
                    </div>
                </div>
                <input type="file" id="media-upload" accept="image/*,video/*,audio/*,.pdf,application/pdf" multiple style="display:none" onchange="handleFileUpload(event)">
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <span class="toolbar-label">Status</span>
                <select class="status-select" id="status-select" onchange="updateNoteStatus()">
                    <option value="none">No Status</option>
                    <option value="in-progress"> In Progress</option>
                    <option value="finished"> Finished</option>
                    <option value="needs-review"> Needs Review</option>
                </select>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <button class="tool-btn" onclick="manualSave()" title="Save (Ctrl+S)">Save</button>
                <button class="tool-btn" onclick="clearCanvas()">Clear</button>
                <button class="tool-btn" onclick="exportNote()">Export</button>
                <button class="tool-btn" id="dark-mode-btn" onclick="toggleDarkMode()" title="Toggle Dark Mode">
                    <svg class="sun-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                    <svg class="moon-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;display:none;">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                </button>
            </div>
        </div>

        <div class="canvas-container" id="canvas-container" style="display: none;">
            <div class="outline-sidebar" id="outline-sidebar">
                <div class="outline-header">Outline</div>
                <div id="outline-content"></div>
            </div>
            <!-- Header navigation sidebar (Notion-style) -->
            <div class="header-nav" id="header-nav"></div>
            <div class="header-preview" id="header-preview"></div>
            <div class="eraser-cursor" id="eraser-cursor"></div>
            <div class="empty-state" id="empty-state" style="display: none;">
                <div class="empty-state-icon"></div>
                <p>Create a notebook to get started</p>
            </div>
            <div class="canvas-wrapper" id="canvas-wrapper" style="display: none;">
                <canvas class="grid-canvas" id="grid-canvas"></canvas>
                <canvas class="drawing-canvas" id="drawing-canvas"></canvas>
                <div class="media-layer" id="media-layer"></div>
                <div class="grid-overlay" id="grid-overlay"></div>
                <div class="text-layer" id="text-layer"></div>
            </div>
        </div>

        <!-- Link Embed Modal -->
        <div class="link-embed-modal" id="link-embed-modal">
            <div class="link-embed-dialog">
                <h3 id="link-embed-title">Embed Media Link</h3>
                <input type="text" id="link-embed-input" placeholder="Paste YouTube, Vimeo, Evernote, or media URL..." autocomplete="off">
                <div class="link-embed-buttons">
                    <button class="link-embed-btn cancel" onclick="closeLinkEmbedDialog()">Cancel</button>
                    <button class="link-embed-btn embed" onclick="embedLinkFromDialog()">Embed</button>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <span id="note-info">No note selected</span>
            <span class="save-indicator saved" id="save-indicator">
                <span class="save-dot"></span> <span class="save-text">Saved</span>
            </span>
        </div>
    </div>

    <!-- Import Modal -->
    <div class="import-modal" id="import-modal">
        <div class="import-modal-content">
            <h3>Import from Evernote</h3>
            <div class="import-status" id="import-status">Preparing to import...</div>
            <div class="import-progress">
                <div class="import-progress-bar" id="import-progress-bar"></div>
            </div>
            <div class="import-modal-buttons">
                <button class="import-modal-btn secondary" onclick="closeImportModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Modal -->
    <div class="modal" id="modal">
        <div class="modal-content">
            <h2 id="modal-title">New Notebook</h2>
            <input type="text" class="modal-input" id="modal-input" placeholder="Name">
            <div class="modal-buttons">
                <button class="modal-btn secondary" onclick="hideModal()">Cancel</button>
                <button class="modal-btn primary" id="modal-confirm" onclick="confirmModal()">Create</button>
            </div>
        </div>
    </div>

    <!-- Version History Modal -->
    <div class="modal-overlay hidden" id="version-modal-overlay" onclick="hideVersionHistory(event)">
        <div class="version-modal" onclick="event.stopPropagation()">
            <div class="version-modal-header">
                <h3>Version History</h3>
                <button class="modal-close-btn" onclick="hideVersionHistory()">&times;</button>
            </div>
            <div class="version-list" id="version-list">
                <div class="no-versions">No versions saved yet</div>
            </div>
        </div>
    </div>

    <script>
        // CHECK IF RUNNING FROM FILE SYSTEM - YOUTUBE WON'T WORK
        if (window.location.protocol === 'file:') {
            const warningDiv = document.createElement('div');
            warningDiv.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#ff3b30;color:white;padding:16px;text-align:center;z-index:99999;font-family:Inter,sans-serif;font-size:14px;box-shadow:0 4px 12px rgba(0,0,0,0.3);';
            warningDiv.innerHTML = `
                <strong> YouTube videos won't work!</strong> You're opening this file directly.<br>
                <strong>Solution:</strong> Run <code style="background:rgba(0,0,0,0.2);padding:2px 8px;border-radius:4px;font-family:monospace;">start-server.ps1</code> and open <strong>http://localhost:8000/index.html</strong> instead.
                <button onclick="this.parentElement.remove()" style="margin-left:12px;background:white;color:#ff3b30;border:none;padding:6px 12px;border-radius:6px;cursor:pointer;font-weight:600;">Dismiss</button>
            `;
            document.body.insertBefore(warningDiv, document.body.firstChild);
        }
        
        // App State
        let state = {
            notebooks: [],
            pinnedNotes: [], // Array of {notebookId, noteId}
            pinnedNotebooks: [], // Array of notebook IDs
            notebookSort: 'pinned', // 'pinned', 'alphabetical', 'recent', 'custom'
            notebookCustomOrder: [], // Array of notebook IDs for custom ordering
            subNotebookSort: 'alphabetical', // 'alphabetical', 'recent', 'custom'
            notesSort: 'recent', // 'alphabetical', 'recent', 'custom'
            currentNotebook: null,
            currentNote: null,
            currentView: 'home', // 'home' or 'editor'
            tool: 'draw',
            color: '#333333',
            thickness: 3,
            font: "'Inter', sans-serif",
            fontSize: 16,
            zoom: 1,
            panOffset: { x: 0, y: 0 },
            gridVisible: false,
            parentNoteForSubnote: null, // For creating sub-notes
            pendingHeaderLevel: null // For header insertion mode
        };

        // Suppress re-showing the eraser briefly when interacting with UI
        let eraserSuppressed = false;

        // Undo/Redo History
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STACK = 50;

        // Version History
        let versionHistory = [];
        let versionHistoryInterval = null;
        const VERSION_INTERVAL = 5 * 60 * 1000; // 5 minutes

        // Canvas Setup
        const canvasContainer = document.getElementById('canvas-container');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const gridCanvas = document.getElementById('grid-canvas');
        const drawingCanvas = document.getElementById('drawing-canvas');
        const textLayer = document.getElementById('text-layer');
        const gridCtx = gridCanvas.getContext('2d');
        const drawCtx = drawingCanvas.getContext('2d');

        const CANVAS_WIDTH = 4000;
        const CANVAS_HEIGHT = 4000;

        // Initialize canvases
        function initCanvases() {
            gridCanvas.width = CANVAS_WIDTH;
            gridCanvas.height = CANVAS_HEIGHT;
            drawingCanvas.width = CANVAS_WIDTH;
            drawingCanvas.height = CANVAS_HEIGHT;
            
            // Set text layer, grid overlay, and wrapper dimensions
            textLayer.style.width = CANVAS_WIDTH + 'px';
            textLayer.style.height = CANVAS_HEIGHT + 'px';
            canvasWrapper.style.width = CANVAS_WIDTH + 'px';
            canvasWrapper.style.height = CANVAS_HEIGHT + 'px';
            
            const gridOverlay = document.getElementById('grid-overlay');
            if (gridOverlay) {
                gridOverlay.style.width = CANVAS_WIDTH + 'px';
                gridOverlay.style.height = CANVAS_HEIGHT + 'px';
            }
            
            // Center the canvas wrapper
            canvasWrapper.style.marginLeft = (-CANVAS_WIDTH / 2) + 'px';
            canvasWrapper.style.marginTop = (-CANVAS_HEIGHT / 2) + 'px';
            
            updateGridVisibility();
        }

        // Draw dotted grid
        function drawGrid() {
            gridCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            gridCtx.fillStyle = '#c0c0c0';
            const spacing = 30;
            const dotSize = 2;
            
            for (let x = 0; x < CANVAS_WIDTH; x += spacing) {
                for (let y = 0; y < CANVAS_HEIGHT; y += spacing) {
                    gridCtx.fillRect(x, y, dotSize, dotSize);
                }
            }
        }
        
        // Toggle grid visibility
        function toggleGrid() {
            state.gridVisible = !state.gridVisible;
            updateGridVisibility();
        }
        
        function updateGridVisibility() {
            const gridBtn = document.getElementById('grid-btn');
            const gridOverlay = document.getElementById('grid-overlay');
            if (state.gridVisible) {
                gridOverlay?.classList.add('visible');
                gridBtn?.classList.add('active');
            } else {
                gridOverlay?.classList.remove('visible');
                gridBtn?.classList.remove('active');
            }
        }

        // Drawing State
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        // Track last known mouse position for cursor placement
        let lastMousePos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        
        // Vector stroke storage - resolution independent
        let vectorStrokes = [];  // All completed strokes
        let currentStroke = null;  // Stroke being drawn

        // Get canvas coordinates in CSS pixels (for vector storage - resolution independent)
        function getCanvasCoords(e) {
            const rect = drawingCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / state.zoom;
            const y = (e.clientY - rect.top) / state.zoom;
            return { x, y };
        }

        // Drawing functions
        function startDrawing(e) {
            // Deselect any selected media embeds
            document.querySelectorAll('.media-embed.selected').forEach(el => {
                el.classList.remove('selected');
            });
            
            if (state.tool === 'pan') {
                isPanning = true;
                panStart = { x: e.clientX - state.panOffset.x, y: e.clientY - state.panOffset.y };
                return;
            }

            // Check if we're in header insertion mode
            if (state.pendingHeaderLevel) {
                const headerLevel = state.pendingHeaderLevel;
                state.pendingHeaderLevel = null;
                // Clear active state from header buttons
                document.querySelectorAll('.header-btn').forEach(btn => btn.classList.remove('active'));
                createTextBox(e, headerLevel);
                return;
            }

            if (state.tool === 'text') {
                console.log('Text tool - attempting to create text box');
                // Don't create new text box if there's currently a focused text box
                // (this click is just to deselect/blur the current one)
                const activeElement = document.activeElement;
                if (activeElement && activeElement.classList.contains('text-box')) {
                    console.log('Focused text box exists, not creating new one');
                    return;
                }
                console.log('Creating text box at', getCanvasCoords(e));
                createTextBox(e);
                return;
            }

            // Prevent drawing when not in draw/erase mode (e.g., select tool)
            if (state.tool !== 'draw' && state.tool !== 'erase') {
                return;
            }

            // Save state before drawing starts (for undo)
            saveToUndoStack();
            
            isDrawing = true;
            const coords = getCanvasCoords(e);
            lastX = coords.x;
            lastY = coords.y;
            
            // Get the active layer ID
            let activeLayerId = null;
            if (typeof canvasModule !== 'undefined' && canvasModule.manager?.layerManager) {
                const activeLayer = canvasModule.manager.layerManager.getActiveLayer();
                if (activeLayer) {
                    activeLayerId = activeLayer.id;
                }
            }
            
            // Start a new vector stroke
            currentStroke = {
                points: [{ x: coords.x, y: coords.y }],
                color: state.tool === 'erase' ? null : state.color,
                thickness: state.thickness,
                tool: state.tool,  // 'draw' or 'erase'
                layerId: activeLayerId  // Associate stroke with current layer
            };
        }

        function draw(e) {
            if (isPanning) {
                state.panOffset.x = e.clientX - panStart.x;
                state.panOffset.y = e.clientY - panStart.y;
                updateCanvasTransform();
                drawingCanvas.style.cursor = 'grabbing';
                return;
            }

            if (!isDrawing || !currentStroke) return;

            const coords = getCanvasCoords(e);
            
            // Add point to current stroke
            currentStroke.points.push({ x: coords.x, y: coords.y });
            
            // Render the new segment immediately for responsiveness
            renderStrokeSegment(lastX, lastY, coords.x, coords.y, currentStroke);

            lastX = coords.x;
            lastY = coords.y;
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                
                // Finalize and store the vector stroke
                if (currentStroke && currentStroke.points.length > 0) {
                    vectorStrokes.push(currentStroke);
                    currentStroke = null;
                    
                    // Re-render all strokes for clean anti-aliased result
                    renderAllStrokes();
                }
                
                markUnsaved();
            }
            if (isPanning) {
                isPanning = false;
                // Reset cursor to grab when pan tool is selected
                if (state.tool === 'pan') {
                    drawingCanvas.style.cursor = 'grab';
                }
            }
        }
        
        // Vector stroke rendering functions
        function getActiveDrawContext() {
            let ctx = drawCtx;
            if (typeof canvasModule !== 'undefined' && canvasModule.manager?.layerManager) {
                const activeCtx = canvasModule.manager.layerManager.getActiveContext();
                if (activeCtx) {
                    ctx = activeCtx;
                }
            }
            return ctx;
        }
        
        // Render a single stroke segment (for real-time drawing feedback)
        function renderStrokeSegment(x1, y1, x2, y2, stroke) {
            const ctx = getActiveDrawContext();
            const pixelRatio = (typeof canvasModule !== 'undefined' && canvasModule.manager?.pixelRatio) || 1;
            
            ctx.beginPath();
            ctx.moveTo(x1 * pixelRatio, y1 * pixelRatio);
            ctx.lineTo(x2 * pixelRatio, y2 * pixelRatio);
            
            if (stroke.tool === 'erase') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.strokeStyle = 'rgba(0,0,0,1)';
                ctx.lineWidth = stroke.thickness * 6 * pixelRatio;
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = stroke.color;
                ctx.lineWidth = stroke.thickness * pixelRatio;
            }
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
            ctx.globalCompositeOperation = 'source-over';
        }
        
        // Render a complete stroke with smooth bezier curves
        function renderStroke(ctx, stroke, pixelRatio) {
            const points = stroke.points;
            if (points.length < 2) return;
            
            ctx.beginPath();
            
            if (points.length === 2) {
                // Simple line for 2 points
                ctx.moveTo(points[0].x * pixelRatio, points[0].y * pixelRatio);
                ctx.lineTo(points[1].x * pixelRatio, points[1].y * pixelRatio);
            } else {
                // Smooth bezier curve through all points
                ctx.moveTo(points[0].x * pixelRatio, points[0].y * pixelRatio);
                
                for (let i = 1; i < points.length - 1; i++) {
                    const p0 = points[i - 1];
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    
                    // Calculate control point (midpoint between current and next)
                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;
                    
                    // Quadratic curve to midpoint using current point as control
                    ctx.quadraticCurveTo(
                        p1.x * pixelRatio, p1.y * pixelRatio,
                        midX * pixelRatio, midY * pixelRatio
                    );
                }
                
                // Final segment to last point
                const lastPoint = points[points.length - 1];
                const secondLast = points[points.length - 2];
                ctx.quadraticCurveTo(
                    secondLast.x * pixelRatio, secondLast.y * pixelRatio,
                    lastPoint.x * pixelRatio, lastPoint.y * pixelRatio
                );
            }
            
            if (stroke.tool === 'erase') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.strokeStyle = 'rgba(0,0,0,1)';
                ctx.lineWidth = stroke.thickness * 6 * pixelRatio;
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = stroke.color;
                ctx.lineWidth = stroke.thickness * pixelRatio;
            }
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
            ctx.globalCompositeOperation = 'source-over';
        }
        
        // Render all strokes (called on zoom change or load)
        function renderAllStrokes() {
            const pixelRatio = (typeof canvasModule !== 'undefined' && canvasModule.manager?.pixelRatio) || 1;
            const canvasWidth = (typeof canvasModule !== 'undefined' && canvasModule.manager?.CANVAS_WIDTH) || CANVAS_WIDTH;
            const canvasHeight = (typeof canvasModule !== 'undefined' && canvasModule.manager?.CANVAS_HEIGHT) || CANVAS_HEIGHT;
            
            // Get active layer info
            let activeLayerId = null;
            let layerManager = null;
            if (typeof canvasModule !== 'undefined' && canvasModule.manager?.layerManager) {
                layerManager = canvasModule.manager.layerManager;
                const activeLayer = layerManager.getActiveLayer();
                if (activeLayer) {
                    activeLayerId = activeLayer.id;
                }
            }
            
            // Clear all layer canvases and render strokes to their respective layers
            if (layerManager) {
                // Clear all layers first
                for (const layer of layerManager.layers) {
                    layer.ctx.clearRect(0, 0, canvasWidth * pixelRatio, canvasHeight * pixelRatio);
                }
                
                // Render each stroke to its layer
                for (const stroke of vectorStrokes) {
                    const targetLayer = stroke.layerId 
                        ? layerManager.layers.find(l => l.id === stroke.layerId)
                        : layerManager.getActiveLayer();
                    
                    if (targetLayer) {
                        renderStroke(targetLayer.ctx, stroke, pixelRatio);
                    }
                }
            } else {
                // Fallback: render to main drawing canvas
                const ctx = drawCtx;
                ctx.clearRect(0, 0, canvasWidth * pixelRatio, canvasHeight * pixelRatio);
                for (const stroke of vectorStrokes) {
                    renderStroke(ctx, stroke, pixelRatio);
                }
            }
        }
        
        // Clear all vector strokes
        function clearVectorStrokes() {
            vectorStrokes = [];
            currentStroke = null;
            renderAllStrokes();
        }

        // Text box creation
        function createTextBox(e, headerLevel = null) {
            const coords = getCanvasCoords(e);
            const textBox = document.createElement('div');
            textBox.className = 'text-box';
            if (headerLevel) {
                textBox.className += ` header-${headerLevel}`;
                textBox.setAttribute('data-header-level', headerLevel);
            }
            textBox.contentEditable = 'true';
            textBox.style.position = 'absolute';
            textBox.style.left = coords.x + 'px';
            textBox.style.top = coords.y + 'px';
            textBox.style.fontFamily = state.font;
            if (!headerLevel) {
                textBox.style.fontSize = state.fontSize + 'px';
            }
            textBox.style.color = state.color;
            textBox.style.minWidth = '100px';
            textBox.style.minHeight = '30px';
            textBox.style.pointerEvents = 'auto';
            
            // Add to active layer's content container if available, otherwise use textLayer
            let targetContainer = textLayer;
            
            if (typeof canvasModule !== 'undefined' && canvasModule.manager?.layerManager) {
                const activeLayer = canvasModule.manager.layerManager.getActiveLayer();
                if (activeLayer && activeLayer.contentContainer) {
                    // Safety check: ensure content container is in DOM (re-insert if needed)
                    if (!document.body.contains(activeLayer.contentContainer)) {
                        const wrapper = document.getElementById('canvas-wrapper');
                        if (wrapper && activeLayer.canvas) {
                            // Insert after the layer's canvas
                            if (activeLayer.canvas.nextSibling) {
                                wrapper.insertBefore(activeLayer.contentContainer, activeLayer.canvas.nextSibling);
                            } else {
                                wrapper.appendChild(activeLayer.contentContainer);
                            }
                        }
                    }
                    
                    targetContainer = activeLayer.contentContainer;
                    textBox.setAttribute('data-layer-id', activeLayer.id);
                }
            }
            
            targetContainer.appendChild(textBox);
            
            // Small delay to ensure DOM is updated before focusing
            setTimeout(() => {
                textBox.focus();
            }, 10);

            textBox.addEventListener('blur', () => {
                if (textBox.textContent.trim() === '') {
                    textBox.remove();
                } else {
                    textBox.classList.add('placed');
                    saveToUndoStack();
                }
                // Exit editing mode when blurred
                textBox.dataset.editing = 'false';
                updateOutline();
                markUnsaved();
            });

            textBox.addEventListener('input', debounce(() => {
                updateOutline();
                markUnsaved();
            }, 500));
            
            // Add click handler for select tool
            addTextBoxSelectHandler(textBox);
        }

        // Insert header - set mode to place on next click
        function insertHeader(level) {
            if (state.currentView !== 'editor' || !state.currentNote) {
                alert('Please open a note first');
                return;
            }
            
            // Toggle header mode
            if (state.pendingHeaderLevel === level) {
                // Cancel if clicking same header button
                state.pendingHeaderLevel = null;
                document.querySelectorAll('.header-btn').forEach(btn => btn.classList.remove('active'));
            } else {
                // Set new header level
                state.pendingHeaderLevel = level;
                // Update button states
                document.querySelectorAll('.header-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`header-${level}-btn`)?.classList.add('active');
                // Change cursor to indicate header mode
                canvasContainer.style.cursor = 'text';
            }
        }

        // Toggle outline sidebar
        function toggleOutline() {
            const outline = document.getElementById('outline-sidebar');
            const btn = document.getElementById('outline-btn');
            outline.classList.toggle('visible');
            btn.classList.toggle('active');
            if (outline.classList.contains('visible')) {
                updateOutline();
            }
        }

        // Update outline with all headers
        function updateOutline() {
            const outlineContent = document.getElementById('outline-content');
            if (!outlineContent) return;
            
            const headers = textLayer.querySelectorAll('[data-header-level]');
            
            if (headers.length === 0) {
                outlineContent.innerHTML = '<div style="color:#999;font-size:0.75rem;padding:8px 0;">No headers yet</div>';
                return;
            }
            
            let html = '';
            headers.forEach((header, index) => {
                const level = header.getAttribute('data-header-level');
                const text = header.textContent.trim() || `Header ${level}`;
                const shortText = text.length > 30 ? text.substring(0, 30) + '...' : text;
                html += `<div class="outline-item h${level}" onclick="scrollToHeader(${index})" title="${text}">${shortText}</div>`;
            });
            
            outlineContent.innerHTML = html;
            // Also update the header nav (top bar)
            updateHeaderNav(headers);
        }

        // Scroll to header when clicked in outline
        function scrollToHeader(index) {
            const headers = textLayer.querySelectorAll('[data-header-level]');
            if (headers[index]) {
                const header = headers[index];
                
                // Highlight briefly
                header.style.transition = 'background 0.3s ease';
                header.style.background = 'rgba(0, 122, 255, 0.1)';
                setTimeout(() => {
                    header.style.background = '';
                }, 500);
                
                // Scroll into view
                header.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // Update header nav sidebar (Notion-style small lines)
        function updateHeaderNav(headers) {
            const nav = document.getElementById('header-nav');
            const preview = document.getElementById('header-preview');
            if (!nav || !preview) return;

            nav.innerHTML = '';
            preview.style.display = 'none';

            if (!headers || headers.length === 0) {
                nav.style.display = 'none';
                return;
            }

            headers.forEach((header, index) => {
                const level = header.getAttribute('data-header-level');
                const text = header.textContent.trim() || `Header ${level}`;

                const item = document.createElement('div');
                item.className = `header-nav-item h${level}`;
                item.dataset.index = index;

                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Remove active from others
                    nav.querySelectorAll('.header-nav-item').forEach(i => i.classList.remove('active'));
                    item.classList.add('active');
                    scrollToHeader(index);
                });

                item.addEventListener('mouseenter', (e) => {
                    preview.textContent = text;
                    preview.style.display = 'block';
                    const rect = item.getBoundingClientRect();
                    // Position preview to the left of the line
                    preview.style.top = rect.top + 'px';
                    preview.style.left = (rect.left - preview.offsetWidth - 10) + 'px';
                });

                item.addEventListener('mouseleave', () => {
                    preview.style.display = 'none';
                });

                nav.appendChild(item);
            });

            nav.style.display = 'flex';
        }

        function addTextBoxSelectHandler(textBox) {
            // Make sure pointer events work on this text box
            textBox.style.pointerEvents = 'auto';
            
            textBox.addEventListener('mousedown', (e) => {
                if (state.tool !== 'select') return;
                
                e.preventDefault();
                e.stopPropagation();
                
                // Select this text box visually
                selectTextBox(textBox);
                
                // Track for potential drag
                let dragStarted = false;
                const startX = e.clientX;
                const startY = e.clientY;
                const initialX = parseInt(textBox.style.left) || 0;
                const initialY = parseInt(textBox.style.top) || 0;
                
                const onMouseMove = (ev) => {
                    const dx = (ev.clientX - startX) / state.zoom;
                    const dy = (ev.clientY - startY) / state.zoom;
                    
                    // Start dragging after moving 5+ pixels
                    if (!dragStarted && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
                        dragStarted = true;
                        textBox.classList.add('dragging');
                        window.getSelection().removeAllRanges();
                    }
                    
                    if (dragStarted) {
                        textBox.style.left = (initialX + dx) + 'px';
                        textBox.style.top = (initialY + dy) + 'px';
                    }
                };
                
                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    
                    if (dragStarted) {
                        textBox.classList.remove('dragging');
                        markUnsaved();
                    } else {
                        // Didn't drag - enter edit mode
                        textBox.contentEditable = 'true';
                        textBox.focus();
                    }
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        // No longer needed - combined into addTextBoxSelectHandler
        function makeTextBoxDraggable(textBox) {
            // Kept for compatibility but logic is now in addTextBoxSelectHandler
        }

        // Multi-touch / pinch-to-zoom and two-finger pan handling
        let activeTouches = new Map();  // Track all active touch points
        let isPinching = false;         // True when 2+ fingers are on screen
        let lastPinchDistance = 0;      // Distance between fingers in last frame
        let lastPinchCenter = { x: 0, y: 0 }; // Center point in last frame
        
        function getTouchDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function getTouchCenter(touch1, touch2) {
            return {
                x: (touch1.clientX + touch2.clientX) / 2,
                y: (touch1.clientY + touch2.clientY) / 2
            };
        }
        
        function getFirstTwoTouches() {
            const touchArray = Array.from(activeTouches.values());
            if (touchArray.length >= 2) {
                return [touchArray[0], touchArray[1]];
            }
            return null;
        }

        // Use pointer events for consistent mouse/pen/touch behavior
        let activePointerId = null;
        drawingCanvas.addEventListener('pointerdown', (e) => {
            console.log('pointerdown on drawingCanvas, tool:', state.tool, 'button:', e.button, 'pointerType:', e.pointerType, 'pointerId:', e.pointerId);
            
            // Track all touch points
            if (e.pointerType === 'touch') {
                activeTouches.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });
                console.log('Touch added, total touches:', activeTouches.size);
                
                // If 2+ touches, start pinch/pan mode and cancel any drawing
                if (activeTouches.size >= 2) {
                    console.log('Starting pinch mode');
                    isPinching = true;
                    isDrawing = false;
                    currentStroke = null;  // Cancel any in-progress stroke
                    
                    // Initialize with current state for incremental updates
                    const touches = getFirstTwoTouches();
                    if (touches) {
                        lastPinchDistance = getTouchDistance(touches[0], touches[1]);
                        lastPinchCenter = getTouchCenter(touches[0], touches[1]);
                    }
                    return;
                }
            }
            
            // Don't start drawing if we're pinching
            if (isPinching) return;
            
            // Middle mouse button always pans
            if (e.button === 1) {
                e.preventDefault();
                isPanning = true;
                panStart = { x: e.clientX - state.panOffset.x, y: e.clientY - state.panOffset.y };
                drawingCanvas.style.cursor = 'grabbing';
                activePointerId = e.pointerId;
                try { drawingCanvas.setPointerCapture(activePointerId); } catch (err) {}
                return;
            }
            // Only start if left button (or pen contact)
            if (e.button && e.button !== 0) return;
            
            // For touch, don't capture - we need to track multiple touches
            // For mouse/pen, capture to track outside canvas
            if (e.pointerType !== 'touch') {
                activePointerId = e.pointerId;
                try { drawingCanvas.setPointerCapture(activePointerId); } catch (err) {}
            }
            startDrawing(e);
        });

        drawingCanvas.addEventListener('pointermove', (e) => {
            // Always track touch positions
            if (e.pointerType === 'touch') {
                activeTouches.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });
                
                // Handle pinch zoom + two-finger pan (incremental approach)
                if (isPinching && activeTouches.size >= 2) {
                    const touches = getFirstTwoTouches();
                    if (!touches) return;
                    
                    const currentDistance = getTouchDistance(touches[0], touches[1]);
                    const currentCenter = getTouchCenter(touches[0], touches[1]);
                    
                    // Calculate incremental zoom change
                    if (lastPinchDistance > 0) {
                        const zoomDelta = currentDistance / lastPinchDistance;
                        const newZoom = Math.max(0.25, Math.min(4, state.zoom * zoomDelta));
                        state.zoom = newZoom;
                    }
                    
                    // Calculate incremental pan (how much the center moved)
                    const panDeltaX = currentCenter.x - lastPinchCenter.x;
                    const panDeltaY = currentCenter.y - lastPinchCenter.y;
                    state.panOffset.x += panDeltaX;
                    state.panOffset.y += panDeltaY;
                    
                    // Update last values for next frame
                    lastPinchDistance = currentDistance;
                    lastPinchCenter = currentCenter;
                    
                    updateCanvasTransform();
                    updateZoomDisplay();
                    return;
                }
            }
            
            // Don't draw while pinching
            if (isPinching) return;
            
            // When pointer is active, draw; otherwise still update eraser cursor
            if (isDrawing || isPanning) {
                draw(e);
            }
            // Update eraser cursor position and visibility
            if (state.tool === 'erase') {
                const eraserCursor = document.getElementById('eraser-cursor');
                if (eraserCursor) {
                    eraserCursor.style.left = e.clientX + 'px';
                    eraserCursor.style.top = e.clientY + 'px';
                    showEraserCursor();
                }
            }
        });

        drawingCanvas.addEventListener('pointerup', (e) => {
            // Remove touch from tracking
            if (e.pointerType === 'touch') {
                activeTouches.delete(e.pointerId);
                
                // End pinch mode when less than 2 fingers
                if (activeTouches.size < 2) {
                    isPinching = false;
                }
            }
            
            stopDrawing();
            if (activePointerId !== null) {
                try { drawingCanvas.releasePointerCapture(activePointerId); } catch (err) {}
                activePointerId = null;
            }
        });

        drawingCanvas.addEventListener('pointercancel', (e) => {
            // Remove touch from tracking
            if (e.pointerType === 'touch') {
                activeTouches.delete(e.pointerId);
                if (activeTouches.size < 2) {
                    isPinching = false;
                }
            }
            
            stopDrawing();
            if (activePointerId !== null) {
                try { drawingCanvas.releasePointerCapture(activePointerId); } catch (err) {}
                activePointerId = null;
            }
        });

        drawingCanvas.addEventListener('pointerleave', (e) => {
            // Clean up touch tracking
            if (e.pointerType === 'touch') {
                activeTouches.delete(e.pointerId);
                if (activeTouches.size < 2) {
                    isPinching = false;
                }
            }
            // when pointer leaves drawing canvas, stop drawing but don't necessarily hide cursor
            stopDrawing();
            // hide cursor only if pointer not over UI (handled by global handler)
        });
        
        // Native touch events for multi-touch gesture handling
        // Apply to both canvas and container for better capture
        function handleTouchStart(e) {
            console.log('handleTouchStart: touches =', e.touches.length, 'tool =', state.tool);
            if (e.touches.length >= 2) {
                // Two-finger gesture - pan/zoom (works for ALL tools)
                e.preventDefault();
                e.stopPropagation();
                isPinching = true;
                isDrawing = false;
                currentStroke = null;
                
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                lastPinchDistance = getTouchDistance(
                    { clientX: t1.clientX, clientY: t1.clientY },
                    { clientX: t2.clientX, clientY: t2.clientY }
                );
                lastPinchCenter = getTouchCenter(
                    { clientX: t1.clientX, clientY: t1.clientY },
                    { clientX: t2.clientX, clientY: t2.clientY }
                );
                console.log('Pinch started: distance =', lastPinchDistance, 'center =', lastPinchCenter);
            }
        }
        
        function handleTouchMove(e) {
            if (e.touches.length >= 2) {
                // Two-finger gesture - pan/zoom (works for ALL tools including select and eraser)
                e.preventDefault();
                e.stopPropagation();
                
                if (!isPinching) {
                    // Started with one finger, added second - initialize pinch
                    isPinching = true;
                    isDrawing = false;
                    currentStroke = null;
                    const t1 = e.touches[0];
                    const t2 = e.touches[1];
                    lastPinchDistance = getTouchDistance(
                        { clientX: t1.clientX, clientY: t1.clientY },
                        { clientX: t2.clientX, clientY: t2.clientY }
                    );
                    lastPinchCenter = getTouchCenter(
                        { clientX: t1.clientX, clientY: t1.clientY },
                        { clientX: t2.clientX, clientY: t2.clientY }
                    );
                    return;
                }
                
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                const currentDistance = getTouchDistance(
                    { clientX: t1.clientX, clientY: t1.clientY },
                    { clientX: t2.clientX, clientY: t2.clientY }
                );
                const currentCenter = getTouchCenter(
                    { clientX: t1.clientX, clientY: t1.clientY },
                    { clientX: t2.clientX, clientY: t2.clientY }
                );
                
                // Calculate incremental zoom
                if (lastPinchDistance > 0) {
                    const zoomDelta = currentDistance / lastPinchDistance;
                    const newZoom = Math.max(0.25, Math.min(4, state.zoom * zoomDelta));
                    console.log('Pinch move: distance =', currentDistance, 'zoomDelta =', zoomDelta, 'newZoom =', newZoom);
                    state.zoom = newZoom;
                }
                
                // Calculate incremental pan
                const panDeltaX = currentCenter.x - lastPinchCenter.x;
                const panDeltaY = currentCenter.y - lastPinchCenter.y;
                state.panOffset.x += panDeltaX;
                state.panOffset.y += panDeltaY;
                console.log('Pan delta:', panDeltaX, panDeltaY, 'new offset:', state.panOffset);
                
                // Update last values
                lastPinchDistance = currentDistance;
                lastPinchCenter = currentCenter;
                
                updateCanvasTransform();
                updateZoomDisplay();
            }
        }
        
        function handleTouchEnd(e) {
            if (e.touches.length < 2) {
                isPinching = false;
                lastPinchDistance = 0;
                activeTouches.clear();
            }
        }
        
        // Add touch handlers to canvas, wrapper, and container for comprehensive coverage
        drawingCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        drawingCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        drawingCanvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        canvasWrapper.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvasWrapper.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvasWrapper.addEventListener('touchend', handleTouchEnd, { passive: false });
        canvasContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvasContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvasContainer.addEventListener('touchend', handleTouchEnd, { passive: false });

        // Global handler for selecting text boxes in Select mode
        // This catches clicks on text boxes that may not have individual handlers
        canvasWrapper.addEventListener('mousedown', (e) => {
            if (state.tool !== 'select') return;
            
            // Find if we clicked on a text box
            const textBox = e.target.closest('.text-box');
            if (!textBox) {
                // Clicked on empty space - clear selection
                clearTextBoxSelection();
                return;
            }
            
            e.preventDefault();
            e.stopPropagation();
            
            // Select this text box
            selectTextBox(textBox);
            
            // Track for drag
            let dragStarted = false;
            const startX = e.clientX;
            const startY = e.clientY;
            const initialX = parseInt(textBox.style.left) || 0;
            const initialY = parseInt(textBox.style.top) || 0;
            
            const onMouseMove = (ev) => {
                const dx = (ev.clientX - startX) / state.zoom;
                const dy = (ev.clientY - startY) / state.zoom;
                
                if (!dragStarted && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
                    dragStarted = true;
                    textBox.classList.add('dragging');
                    window.getSelection().removeAllRanges();
                }
                
                if (dragStarted) {
                    textBox.style.left = (initialX + dx) + 'px';
                    textBox.style.top = (initialY + dy) + 'px';
                }
            };
            
            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                
                if (dragStarted) {
                    textBox.classList.remove('dragging');
                    markUnsaved();
                } else {
                    // Didn't drag - enter edit mode
                    textBox.contentEditable = 'true';
                    textBox.focus();
                }
            };
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
        
        // Also add handler directly to text-layer for more reliable text box selection
        textLayer.addEventListener('mousedown', (e) => {
            if (state.tool !== 'select') return;
            
            const textBox = e.target.closest('.text-box');
            if (!textBox) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            selectTextBox(textBox);
            
            let dragStarted = false;
            const startX = e.clientX;
            const startY = e.clientY;
            const initialX = parseInt(textBox.style.left) || 0;
            const initialY = parseInt(textBox.style.top) || 0;
            
            const onMouseMove = (ev) => {
                const dx = (ev.clientX - startX) / state.zoom;
                const dy = (ev.clientY - startY) / state.zoom;
                
                if (!dragStarted && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
                    dragStarted = true;
                    textBox.classList.add('dragging');
                    window.getSelection().removeAllRanges();
                }
                
                if (dragStarted) {
                    textBox.style.left = (initialX + dx) + 'px';
                    textBox.style.top = (initialY + dy) + 'px';
                }
            };
            
            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                
                if (dragStarted) {
                    textBox.classList.remove('dragging');
                    markUnsaved();
                } else {
                    textBox.contentEditable = 'true';
                    textBox.focus();
                }
            };
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
        
        // GLOBAL document-level handler as ultimate fallback for text box selection
        document.addEventListener('mousedown', (e) => {
            // DEBUG: Log every click
            console.log('Document mousedown - tool:', state.tool, 'target:', e.target.className, 'view:', state.currentView);
            
            if (state.tool !== 'select') return;
            if (state.currentView !== 'editor') return;
            
            const textBox = e.target.closest('.text-box');
            console.log('Looking for text-box, found:', textBox);
            if (!textBox) return;
            
            // Only handle if we're in the canvas area
            if (!e.target.closest('#canvas-wrapper') && !e.target.closest('#text-layer')) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            selectTextBox(textBox);
            
            let dragStarted = false;
            const startX = e.clientX;
            const startY = e.clientY;
            const initialX = parseInt(textBox.style.left) || 0;
            const initialY = parseInt(textBox.style.top) || 0;
            
            const onMouseMove = (ev) => {
                const dx = (ev.clientX - startX) / state.zoom;
                const dy = (ev.clientY - startY) / state.zoom;
                
                if (!dragStarted && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
                    dragStarted = true;
                    textBox.classList.add('dragging');
                    window.getSelection().removeAllRanges();
                }
                
                if (dragStarted) {
                    textBox.style.left = (initialX + dx) + 'px';
                    textBox.style.top = (initialY + dy) + 'px';
                }
            };
            
            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                
                if (dragStarted) {
                    textBox.classList.remove('dragging');
                    markUnsaved();
                } else {
                    textBox.contentEditable = 'true';
                    textBox.focus();
                }
            };
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }, true); // Use capture phase to get event first

        // Prevent default middle mouse button scrolling
        drawingCanvas.addEventListener('auxclick', (e) => {
            if (e.button === 1) {
                e.preventDefault();
            }
        });

        drawingCanvas.addEventListener('pointerenter', (e) => {
            if (state.tool === 'erase') {
                const eraserCursor = document.getElementById('eraser-cursor');
                if (eraserCursor) {
                    eraserCursor.style.left = e.clientX + 'px';
                    eraserCursor.style.top = e.clientY + 'px';
                }
                showEraserCursor();
            }
        });

        // Click on canvas to deselect text boxes (pointer-friendly)
        drawingCanvas.addEventListener('click', () => {
            if (state.tool === 'select') {
                clearTextBoxSelection();
            }
        });

        // Track mouse globally so eraser cursor can be shown immediately when tool is selected
        document.addEventListener('mousemove', (e) => {
            lastMousePos.x = e.clientX;
            lastMousePos.y = e.clientY;
            const eraserCursor = document.getElementById('eraser-cursor');
            if (!eraserCursor) return;

            // Decide visibility using elementFromPoint - only show over canvas, NOT over toolbar/sidebar/layer panel
            const el = document.elementFromPoint(e.clientX, e.clientY);
            const isOverDrawing = !!(el && (el.id === 'drawing-canvas' || el.closest('#canvas-container')));
            const isOverTools = !!(el && (el.closest('#toolbar') || el.closest('.sidebar') || el.closest('.layer-panel')));

            if (state.tool === 'erase') {
                // Position cursor at pointer
                eraserCursor.style.left = e.clientX + 'px';
                eraserCursor.style.top = e.clientY + 'px';
                // Only show eraser cursor when over drawing canvas, hide over toolbar/sidebar/layer panel
                if (isOverDrawing && !isOverTools) {
                    showEraserCursor();
                } else {
                    hideEraserCursor();
                }
            } else {
                hideEraserCursor();
            }
        });

        // Also hide eraser on window blur or when pointer leaves the document
        window.addEventListener('blur', () => hideEraserCursor());
        document.addEventListener('mouseleave', () => hideEraserCursor());

        // Hide eraser when interacting with UI controls (toolbar, inputs, dropdowns)
        document.addEventListener('pointerdown', (e) => {
            // If the pointerdown is outside the canvas container, hide the eraser
            const isInsideCanvas = !!e.target.closest('#canvas-container');
            if (!isInsideCanvas && state.tool === 'erase') {
                hideEraserCursor();
                eraserSuppressed = true;
                // short debounce to avoid immediate re-show from mousemove
                setTimeout(() => { eraserSuppressed = false; }, 250);
            }
        }, { passive: true });

        // Also hide when focus moves to UI controls (keyboard navigation)
        document.addEventListener('focusin', (e) => {
            const isInsideCanvas = !!e.target.closest('#canvas-container');
            if (!isInsideCanvas && state.tool === 'erase') {
                hideEraserCursor();
                eraserSuppressed = true;
                setTimeout(() => { eraserSuppressed = false; }, 250);
            }
        });

        // Touch: update last position and hide if outside canvas
        document.addEventListener('touchmove', (e) => {
            if (!e.touches || e.touches.length === 0) return;
            const t = e.touches[0];
            lastMousePos.x = t.clientX;
            lastMousePos.y = t.clientY;
            const rect = canvasWrapper.getBoundingClientRect();
            const inside = t.clientX >= rect.left && t.clientX <= rect.right && t.clientY >= rect.top && t.clientY <= rect.bottom;
            const eraserCursor = document.getElementById('eraser-cursor');
            if (eraserCursor) {
                eraserCursor.style.left = t.clientX + 'px';
                eraserCursor.style.top = t.clientY + 'px';
                if (!inside) hideEraserCursor();
            }
        }, { passive: true });

        canvasContainer.addEventListener('touchcancel', () => {
            isPinching = false;
            lastPinchDistance = 0;
            activeTouches.clear();
            stopDrawing();
        });

        // Zoom with mouse wheel
        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            state.zoom = Math.max(0.25, Math.min(4, state.zoom + delta));
            updateCanvasTransform();
            updateZoomDisplay();
        });

        // Text layer click handler for select mode
        const textLayerForSelect = document.getElementById('text-layer');
        textLayerForSelect.addEventListener('mousedown', function(e) {
            if (state.tool !== 'select') return;
            
            // Find if we clicked on a text box
            let textBox = e.target.closest('.text-box');
            if (!textBox) {
                // Check if we clicked directly on text-layer but near a text box
                const textBoxes = document.querySelectorAll('.text-box');
                for (const tb of textBoxes) {
                    const rect = tb.getBoundingClientRect();
                    if (e.clientX >= rect.left && e.clientX <= rect.right && 
                        e.clientY >= rect.top && e.clientY <= rect.bottom) {
                        textBox = tb;
                        break;
                    }
                }
            }
            
            if (!textBox) {
                clearTextBoxSelection();
                return;
            }
            
            e.preventDefault();
            e.stopPropagation();
            
            // Select this text box
            selectTextBox(textBox);
            
            // Track for drag
            let dragStarted = false;
            const startX = e.clientX;
            const startY = e.clientY;
            const initialX = parseInt(textBox.style.left) || 0;
            const initialY = parseInt(textBox.style.top) || 0;
            
            const onMouseMove = (ev) => {
                const dx = (ev.clientX - startX) / state.zoom;
                const dy = (ev.clientY - startY) / state.zoom;
                
                if (!dragStarted && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
                    dragStarted = true;
                    textBox.classList.add('dragging');
                    window.getSelection().removeAllRanges();
                }
                
                if (dragStarted) {
                    textBox.style.left = (initialX + dx) + 'px';
                    textBox.style.top = (initialY + dy) + 'px';
                }
            };
            
            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                
                if (dragStarted) {
                    textBox.classList.remove('dragging');
                    markUnsaved();
                }
            };
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
        
        // Double-click on text-layer to edit text box
        textLayerForSelect.addEventListener('dblclick', function(e) {
            if (state.tool !== 'select') return;
            
            let textBox = e.target.closest('.text-box');
            if (!textBox) {
                const textBoxes = document.querySelectorAll('.text-box');
                for (const tb of textBoxes) {
                    const rect = tb.getBoundingClientRect();
                    if (e.clientX >= rect.left && e.clientX <= rect.right && 
                        e.clientY >= rect.top && e.clientY <= rect.bottom) {
                        textBox = tb;
                        break;
                    }
                }
            }
            
            if (textBox) {
                e.preventDefault();
                e.stopPropagation();
                textBox.contentEditable = 'true';
                textBox.focus();
            }
        });
        
        // Tool functions
        let selectedTextBox = null;

        function setTool(tool) {
            state.tool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`${tool}-btn`).classList.add('active');
            
            // Clear selection when switching tools
            if (tool !== 'select') {
                clearTextBoxSelection();
            }
            
            // When switching to select mode, blur any focused text box first
            // so it can be properly selected/moved
            if (tool === 'select') {
                const focused = document.activeElement;
                if (focused && focused.classList && focused.classList.contains('text-box')) {
                    focused.blur();
                }
                // Reset editing state on all text boxes
                document.querySelectorAll('.text-box').forEach(tb => {
                    tb.dataset.editing = 'false';
                });
            }
            
            const eraserCursor = document.getElementById('eraser-cursor');
            if (tool === 'erase') {
                // allow eraser to show immediately when switching into erase
                eraserSuppressed = false;
                drawingCanvas.style.cursor = 'none';
                showEraserCursor();
            } else {
                // suppress re-show briefly when switching away from erase
                hideEraserCursor();
                eraserSuppressed = true;
                setTimeout(() => { eraserSuppressed = false; }, 250);
                drawingCanvas.style.cursor = tool === 'pan' ? 'grab' : 
                                             tool === 'text' ? 'text' :
                                             tool === 'select' ? 'default' : 'crosshair';
            }
            // When not drawing, let pointer events pass through the drawing canvas
            // so embeds and text boxes underneath can be interacted with in Select mode.
            const mediaLayer = document.getElementById('media-layer');
            const textLayerEl = document.getElementById('text-layer');
            
            // Get all layer content containers
            const layerContents = document.querySelectorAll('.layer-content');
            
            if (tool === 'draw' || tool === 'erase' || tool === 'pan' || tool === 'text') {
                // Ensure the drawing canvas is on top so mouse events reach it
                drawingCanvas.style.pointerEvents = 'auto';
                drawingCanvas.style.zIndex = 99999;
                // For pan, keep media/text interactive but drawing canvas captures events
                if (tool === 'pan') {
                    if (mediaLayer) mediaLayer.style.pointerEvents = 'auto';
                    if (textLayerEl) textLayerEl.style.pointerEvents = 'auto';
                    layerContents.forEach(lc => lc.style.pointerEvents = 'auto');
                } else if (tool === 'text') {
                    // Text tool: drawing canvas captures clicks to create text boxes
                    // Text layer stays below drawing canvas so clicks pass through
                    if (mediaLayer) mediaLayer.style.pointerEvents = 'none';
                    if (textLayerEl) {
                        textLayerEl.style.pointerEvents = 'none';
                        textLayerEl.style.zIndex = 4; // Keep below drawing canvas
                    }
                    layerContents.forEach(lc => lc.style.pointerEvents = 'none');
                } else {
                    // Temporarily ignore pointer events on media/text layers while drawing
                    if (mediaLayer) mediaLayer.style.pointerEvents = 'none';
                    if (textLayerEl) textLayerEl.style.pointerEvents = 'none';
                    layerContents.forEach(lc => lc.style.pointerEvents = 'none');
                }
            } else {
                // Select mode - enable pointer events on all content containers
                drawingCanvas.style.pointerEvents = 'none';
                drawingCanvas.style.zIndex = 2;
                // Enable canvas wrapper to receive clicks
                canvasWrapper.style.pointerEvents = 'auto';
                if (mediaLayer) mediaLayer.style.pointerEvents = 'auto';
                if (textLayerEl) {
                    textLayerEl.style.pointerEvents = 'auto';
                    textLayerEl.style.zIndex = 100000; // Put text layer on top in select mode
                }
                // Enable pointer events on layer content containers so items can be selected
                layerContents.forEach(lc => {
                    lc.style.pointerEvents = 'auto';
                    lc.style.zIndex = 100000; // Same level as text layer
                });
                // Also ensure all text boxes are clickable
                document.querySelectorAll('.text-box').forEach(tb => {
                    tb.style.pointerEvents = 'auto';
                    tb.style.cursor = 'move';
                    tb.style.zIndex = 100001; // Text boxes above their containers
                });
            }
        }

        function selectTextBox(textBox) {
            clearTextBoxSelection();
            selectedTextBox = textBox;
            textBox.classList.add('selected');
        }

        function clearTextBoxSelection() {
            if (selectedTextBox) {
                selectedTextBox.classList.remove('selected');
                selectedTextBox = null;
            }
        }

        function deleteSelectedTextBox() {
            if (selectedTextBox) {
                saveToUndoStack();
                selectedTextBox.remove();
                selectedTextBox = null;
                markUnsaved();
            }
        }
        
        function updateEraserCursor() {
            const eraserCursor = document.getElementById('eraser-cursor');
            // Make eraser circle more visible: larger multiplier
            const size = Math.max(16, state.thickness * 6 * state.zoom);
            eraserCursor.style.width = size + 'px';
            eraserCursor.style.height = size + 'px';
        }

        function showEraserCursor() {
            const eraserCursor = document.getElementById('eraser-cursor');
            if (!eraserCursor) return;
            if (eraserSuppressed) return;
            updateEraserCursor();
            eraserCursor.classList.add('visible');
            // Position immediately at last known mouse position
            eraserCursor.style.left = (lastMousePos.x) + 'px';
            eraserCursor.style.top = (lastMousePos.y) + 'px';
            // Hide the OS cursor while eraser is visible
            try { document.body.style.cursor = 'none'; } catch (err) {}
        }

        function hideEraserCursor() {
            const eraserCursor = document.getElementById('eraser-cursor');
            if (!eraserCursor) return;
            eraserCursor.classList.remove('visible');
            // Restore OS cursor when eraser hidden
            try { document.body.style.cursor = ''; } catch (err) {}
        }


        // Undo/Redo Functions (async + throttled to reduce lag)
        let lastUndoAt = 0;
        const UNDO_COOLDOWN_MS = 1200;
        let pendingUndoTimeout = null;

        async function saveToUndoStack() {
            const now = Date.now();

            // Throttle frequent snapshots (handwriting creates many short strokes)
            if (now - lastUndoAt < UNDO_COOLDOWN_MS) {
                if (pendingUndoTimeout) clearTimeout(pendingUndoTimeout);
                pendingUndoTimeout = setTimeout(() => {
                    // Re-enter after cooldown
                    saveToUndoStack();
                }, UNDO_COOLDOWN_MS - (now - lastUndoAt));
                return;
            }

            // Save vector strokes (deep copy to prevent reference issues)
            const strokesCopy = JSON.parse(JSON.stringify(vectorStrokes));

            const textBoxes = Array.from(textLayer.querySelectorAll('.text-box')).map(box => ({
                content: box.innerHTML,
                left: box.style.left,
                top: box.style.top,
                width: box.style.width,
                height: box.style.height,
                fontFamily: box.style.fontFamily,
                fontSize: box.style.fontSize,
                color: box.style.color
            }));

            undoStack.push({ vectorStrokes: strokesCopy, textBoxes });
            lastUndoAt = Date.now();

            // Limit stack size
            if (undoStack.length > MAX_UNDO_STACK) {
                undoStack.shift();
            }

            // Clear redo stack when new action is performed
            redoStack = [];

            updateUndoRedoButtons();
        }

        function undo() {
            if (undoStack.length === 0) return;
            
            // Save current state to redo stack
            const currentState = {
                vectorStrokes: JSON.parse(JSON.stringify(vectorStrokes)),
                textBoxes: Array.from(textLayer.querySelectorAll('.text-box')).map(box => ({
                    content: box.innerHTML,
                    left: box.style.left,
                    top: box.style.top,
                    width: box.style.width,
                    height: box.style.height,
                    fontFamily: box.style.fontFamily,
                    fontSize: box.style.fontSize,
                    color: box.style.color
                }))
            };
            redoStack.push(currentState);
            
            // Restore previous state
            const previousState = undoStack.pop();
            restoreState(previousState);
            
            updateUndoRedoButtons();
            markUnsaved();
        }

        function redo() {
            if (redoStack.length === 0) return;
            
            // Save current state to undo stack
            const currentState = {
                vectorStrokes: JSON.parse(JSON.stringify(vectorStrokes)),
                textBoxes: Array.from(textLayer.querySelectorAll('.text-box')).map(box => ({
                    content: box.innerHTML,
                    left: box.style.left,
                    top: box.style.top,
                    width: box.style.width,
                    height: box.style.height,
                    fontFamily: box.style.fontFamily,
                    fontSize: box.style.fontSize,
                    color: box.style.color
                }))
            };
            undoStack.push(currentState);
            
            // Restore redo state
            const redoState = redoStack.pop();
            restoreState(redoState);
            
            updateUndoRedoButtons();
            markUnsaved();
        }

        function restoreState(stateData) {
            // Restore vector strokes
            if (stateData.vectorStrokes) {
                vectorStrokes = JSON.parse(JSON.stringify(stateData.vectorStrokes));
                currentStroke = null;
                renderAllStrokes();
            }
            
            // Restore text boxes
            textLayer.innerHTML = '';
            stateData.textBoxes.forEach(boxData => {
                const textBox = document.createElement('div');
                    textBox.className = 'text-box placed';
                    // Restore header class if this textbox was a header when saved
                    if (boxData.headerLevel) {
                        textBox.className += ` header-${boxData.headerLevel}`;
                        textBox.setAttribute('data-header-level', boxData.headerLevel);
                    }
                    textBox.contentEditable = true;
                    // Use textContent for plain imports, innerHTML for saved notes with formatting
                    if (boxData.content && boxData.content.includes('<')) {
                        textBox.innerHTML = boxData.content;
                    } else {
                        textBox.textContent = boxData.content || '';
                    }
                    textBox.style.position = 'absolute';
                    textBox.style.left = boxData.left;
                    textBox.style.top = boxData.top;
                    textBox.style.minWidth = '50px';
                    textBox.style.minHeight = '20px';
                    if (boxData.width && boxData.width !== 'auto' && boxData.width !== '') {
                        textBox.style.width = boxData.width;
                    }
                    if (boxData.height && boxData.height !== 'auto' && boxData.height !== '') {
                        textBox.style.height = boxData.height;
                    }
                    if (boxData.fontFamily) textBox.style.fontFamily = boxData.fontFamily;
                    // For headers, prefer CSS header sizing  avoid setting inline fontSize
                    if (!boxData.headerLevel) {
                        if (boxData.fontSize) textBox.style.fontSize = boxData.fontSize;
                    } else {
                        textBox.style.fontSize = '';
                    }
                    if (boxData.color) textBox.style.color = boxData.color;
                
                textBox.addEventListener('blur', () => {
                    if (textBox.textContent.trim() === '') {
                        textBox.remove();
                    }
                    // Exit editing mode when blurred
                    textBox.dataset.editing = 'false';
                    saveToUndoStack();
                    markUnsaved();
                });

                textBox.addEventListener('input', debounce(() => markUnsaved(), 500));
                
                // Add click handler for select tool
                addTextBoxSelectHandler(textBox);
                
                textLayer.appendChild(textBox);
            });
            
            // Re-render subnote blocks
            if (state.currentNote) {
                renderSubnoteBlocks(state.currentNote);
            }
        }

        function updateUndoRedoButtons() {
            document.getElementById('undo-btn').disabled = undoStack.length === 0;
            document.getElementById('redo-btn').disabled = redoStack.length === 0;
        }

        function clearUndoHistory() {
            undoStack = [];
            redoStack = [];
            updateUndoRedoButtons();
        }

        // Save the initial state when a note is first loaded
        function saveInitialState() {
            const canvasState = drawingCanvas.toDataURL();
            const textBoxes = Array.from(textLayer.querySelectorAll('.text-box')).map(box => ({
                content: box.innerHTML,
                left: box.style.left,
                top: box.style.top,
                width: box.style.width,
                height: box.style.height,
                fontFamily: box.style.fontFamily,
                fontSize: box.style.fontSize,
                color: box.style.color
            }));
            
            // This is the base state - it goes in the undo stack
            // but won't be cleared by saveToUndoStack's redo clear
            undoStack = [{ canvasState, textBoxes }];
            redoStack = [];
            updateUndoRedoButtons();
        }

        // Version History Functions
        function saveVersionSnapshot() {
            if (!state.currentNote) return;
            
            const snapshot = {
                timestamp: Date.now(),
                canvasState: drawingCanvas.toDataURL(),
                textBoxes: Array.from(textLayer.querySelectorAll('.text-box')).map(box => ({
                    content: box.innerHTML,
                    left: box.style.left,
                    top: box.style.top,
                    width: box.style.width,
                    height: box.style.height,
                    fontFamily: box.style.fontFamily,
                    fontSize: box.style.fontSize,
                    color: box.style.color
                }))
            };
            
            versionHistory.push(snapshot);
            
            // Keep max 20 versions per session
            if (versionHistory.length > 20) {
                versionHistory.shift();
            }
            
            // Save to note data
            const note = findCurrentNote();
            if (note) {
                note.versionHistory = versionHistory;
                saveToStorage();
            }
        }

        function startVersionHistoryTimer() {
            if (versionHistoryInterval) {
                clearInterval(versionHistoryInterval);
            }
            // Save initial version
            setTimeout(() => saveVersionSnapshot(), 1000);
            // Save every 5 minutes
            versionHistoryInterval = setInterval(saveVersionSnapshot, VERSION_INTERVAL);
        }

        function stopVersionHistoryTimer() {
            if (versionHistoryInterval) {
                clearInterval(versionHistoryInterval);
                versionHistoryInterval = null;
            }
        }

        function showVersionHistory() {
            const modal = document.getElementById('version-modal-overlay');
            const versionList = document.getElementById('version-list');
            
            if (versionHistory.length === 0) {
                versionList.innerHTML = '<div class="no-versions">No versions saved yet</div>';
            } else {
                versionList.innerHTML = versionHistory.map((version, index) => {
                    const date = new Date(version.timestamp);
                    const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    const dateStr = date.toLocaleDateString([], { month: 'short', day: 'numeric' });
                    return `
                        <div class="version-item" onclick="previewVersion(${index})">
                            <span class="version-time">${dateStr} at ${timeStr}</span>
                            <button class="version-restore-btn" onclick="event.stopPropagation(); restoreVersion(${index})">Restore</button>
                        </div>
                    `;
                }).reverse().join('');
            }
            
            modal.classList.remove('hidden');
        }

        function hideVersionHistory(e) {
            if (e && e.target !== e.currentTarget) return;
            document.getElementById('version-modal-overlay').classList.add('hidden');
        }

        function restoreVersion(index) {
            const version = versionHistory[index];
            if (!version) return;
            
            // Save current state to undo stack before restoring
            saveToUndoStack();
            
            restoreState(version);
            hideVersionHistory();
            markUnsaved();
        }

        function previewVersion(index) {
            // For now, just restore. Could add preview functionality later.
            restoreVersion(index);
        }

        function findCurrentNote() {
            if (!state.currentNotebook || !state.currentNote) return null;
            const notebook = state.notebooks.find(n => n.id === state.currentNotebook);
            if (!notebook) return null;
            return notebook.notes.find(n => n.id === state.currentNote);
        }

        function zoomIn() {
            state.zoom = Math.min(4, state.zoom + 0.25);
            updateCanvasTransform();
            updateZoomDisplay();
            updateEraserCursor();
        }

        function zoomOut() {
            state.zoom = Math.max(0.25, state.zoom - 0.25);
            updateCanvasTransform();
            updateZoomDisplay();
            updateEraserCursor();
        }

        function resetZoom() {
            state.zoom = 1;
            state.panOffset = { x: 0, y: 0 };
            updateCanvasTransform();
            updateZoomDisplay();
            updateEraserCursor();
        }

        function updateCanvasTransform() {
            canvasWrapper.style.transform = `translate(${state.panOffset.x}px, ${state.panOffset.y}px) scale(${state.zoom})`;
        }

        function updateZoomDisplay() {
            document.getElementById('zoom-display').textContent = Math.round(state.zoom * 100) + '%';
        }

        // Color picker
        document.getElementById('color-picker').addEventListener('change', (e) => {
            state.color = e.target.value;
        });

        // Thickness slider
        document.getElementById('thickness-slider').addEventListener('input', (e) => {
            state.thickness = parseInt(e.target.value);
            document.getElementById('thickness-value').textContent = state.thickness + 'px';
            if (state.tool === 'erase') {
                updateEraserCursor();
            }
        });

        // Font select
        // Changing the font now only affects future text boxes.
        document.getElementById('font-select').addEventListener('change', (e) => {
            state.font = e.target.value;
            // Do not overwrite font on existing text boxes; preserve previously-typed text.
            // New text boxes created after this will use `state.font` (see createTextBox).
            if (state.currentNote) saveNoteData();
        });

        // Text formatting (bold/italic/underline/strike)
        function formatText(command) {
            try {
                document.execCommand(command);
                if (state.currentNote) saveNoteData();
            } catch (err) {
                console.warn('formatText error', err);
            }
        }

        // Apply highlight using browser command or a DOM fallback
        function applyHighlight(color) {
            if (!color) return;
            try {
                const supported = (document.queryCommandSupported && (document.queryCommandSupported('hiliteColor') || document.queryCommandSupported('backColor')));
                if (supported) {
                    // Prefer hiliteColor where available
                    if (document.queryCommandSupported('hiliteColor')) document.execCommand('hiliteColor', false, color);
                    else document.execCommand('backColor', false, color);
                } else {
                    const sel = window.getSelection();
                    if (!sel.rangeCount) return;
                    const range = sel.getRangeAt(0);
                    if (range.collapsed) return;
                    const span = document.createElement('span');
                    span.style.backgroundColor = color;
                    range.surroundContents(span);
                }
                // Mark the chosen swatch active visually
                document.querySelectorAll('.highlight-swatch').forEach(s => s.classList.toggle('active', s.getAttribute('data-color') === color));
            } catch (err) {
                console.warn('applyHighlight error', err);
            }
            if (state.currentNote) saveNoteData();
        }

        document.getElementById('font-size-select').addEventListener('change', (e) => {
            state.fontSize = parseInt(e.target.value);
        });

        // Clear canvas
        function clearCanvas() {
            if (confirm('Are you sure you want to clear the canvas?')) {
                // Clear all layers if using layer manager
                if (typeof canvasModule !== 'undefined' && canvasModule.manager?.layerManager) {
                    canvasModule.manager.layerManager.layers.forEach(layer => {
                        layer.ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                        // Clear content containers
                        if (layer.contentContainer) {
                            layer.contentContainer.innerHTML = '';
                        }
                    });
                } else {
                    drawCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    drawCtx.fillStyle = getCanvasBackground();
                    drawCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                }
                textLayer.innerHTML = '';
                
                // Clear all media embeds (they may be in media-layer or layer content containers)
                document.querySelectorAll('.media-embed').forEach(embed => embed.remove());
                
                // Re-render subnote blocks
                if (state.currentNote) {
                    renderSubnoteBlocks(state.currentNote);
                }
                
                saveCurrentNote();
            }
        }

        // Export notes to Evernote ENEX format (replaces previous PNG export)
        async function exportNote() {
            try {
                const enex = await buildENEXFromState();
                const blob = new Blob([enex], { type: 'application/xml' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                const now = new Date();
                const filename = `ultimateNotes-export-${now.getFullYear()}-${now.getMonth()+1}-${now.getDate()}.enex`;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                link.remove();
                URL.revokeObjectURL(url);
            } catch (e) {
                console.error('Export to ENEX failed:', e);
                alert('Export failed. See console for details.');
            }
        }

        // Build ENEX content from current app state
        async function buildENEXFromState() {
            // Simple MD5 implementation (adapted) for computing resource hashes
            function md5cycle(x, k) {
                var a = x[0], b = x[1], c = x[2], d = x[3];
                a = ff(a, b, c, d, k[0], 7, -680876936);
                d = ff(d, a, b, c, k[1], 12, -389564586);
                c = ff(c, d, a, b, k[2], 17, 606105819);
                b = ff(b, c, d, a, k[3], 22, -1044525330);
                a = ff(a, b, c, d, k[4], 7, -176418897);
                d = ff(d, a, b, c, k[5], 12, 1200080426);
                c = ff(c, d, a, b, k[6], 17, -1473231341);
                b = ff(b, c, d, a, k[7], 22, -45705983);
                a = ff(a, b, c, d, k[8], 7, 1770035416);
                d = ff(d, a, b, c, k[9], 12, -1958414417);
                c = ff(c, d, a, b, k[10], 17, -42063);
                b = ff(b, c, d, a, k[11], 22, -1990404162);
                a = ff(a, b, c, d, k[12], 7, 1804603682);
                d = ff(d, a, b, c, k[13], 12, -40341101);
                c = ff(c, d, a, b, k[14], 17, -1502002290);
                b = ff(b, c, d, a, k[15], 22, 1236535329);
                a = gg(a, b, c, d, k[1], 5, -165796510);
                d = gg(d, a, b, c, k[6], 9, -1069501632);
                c = gg(c, d, a, b, k[11], 14, 643717713);
                b = gg(b, c, d, a, k[0], 20, -373897302);
                a = gg(a, b, c, d, k[5], 5, -701558691);
                d = gg(d, a, b, c, k[10], 9, 38016083);
                c = gg(c, d, a, b, k[15], 14, -660478335);
                b = gg(b, c, d, a, k[4], 20, -405537848);
                a = gg(a, b, c, d, k[9], 5, 568446438);
                d = gg(d, a, b, c, k[14], 9, -1019803690);
                c = gg(c, d, a, b, k[3], 14, -187363961);
                b = gg(b, c, d, a, k[8], 20, 1163531501);
                a = gg(a, b, c, d, k[13], 5, -1444681467);
                d = gg(d, a, b, c, k[2], 9, -51403784);
                c = gg(c, d, a, b, k[7], 14, 1735328473);
                b = gg(b, c, d, a, k[12], 20, -1926607734);
                a = hh(a, b, c, d, k[5], 4, -378558);
                d = hh(d, a, b, c, k[8], 11, -2022574463);
                c = hh(c, d, a, b, k[11], 16, 1839030562);
                b = hh(b, c, d, a, k[14], 23, -35309556);
                a = hh(a, b, c, d, k[1], 4, -1530992060);
                d = hh(d, a, b, c, k[4], 11, 1272893353);
                c = hh(c, d, a, b, k[7], 16, -155497632);
                b = hh(b, c, d, a, k[10], 23, -1094730640);
                a = hh(a, b, c, d, k[13], 4, 681279174);
                d = hh(d, a, b, c, k[0], 11, -358537222);
                c = hh(c, d, a, b, k[3], 16, -722521979);
                b = hh(b, c, d, a, k[6], 23, 76029189);
                a = hh(a, b, c, d, k[9], 4, -640364487);
                d = hh(d, a, b, c, k[12], 11, -421815835);
                c = hh(c, d, a, b, k[15], 16, 530742520);
                b = hh(b, c, d, a, k[2], 23, -995338651);
                a = ii(a, b, c, d, k[0], 6, -198630844);
                d = ii(d, a, b, c, k[7], 10, 1126891415);
                c = ii(c, d, a, b, k[14], 15, -1416354905);
                b = ii(b, c, d, a, k[5], 21, -57434055);
                a = ii(a, b, c, d, k[12], 6, 1700485571);
                d = ii(d, a, b, c, k[3], 10, -1894986606);
                c = ii(c, d, a, b, k[10], 15, -1051523);
                b = ii(b, c, d, a, k[1], 21, -2054922799);
                a = ii(a, b, c, d, k[8], 6, 1873313359);
                d = ii(d, a, b, c, k[15], 10, -30611744);
                c = ii(c, d, a, b, k[6], 15, -1560198380);
                b = ii(b, c, d, a, k[13], 21, 1309151649);
                a = ii(a, b, c, d, k[4], 6, -145523070);
                d = ii(d, a, b, c, k[11], 10, -1120210379);
                c = ii(c, d, a, b, k[2], 15, 718787259);
                b = ii(b, c, d, a, k[9], 21, -343485551);
                x[0] = add32(a, x[0]);
                x[1] = add32(b, x[1]);
                x[2] = add32(c, x[2]);
                x[3] = add32(d, x[3]);
            }
            function cmn(q, a, b, x, s, t) {
                a = add32(add32(a, q), add32(x, t));
                return add32((a << s) | (a >>> (32 - s)), b);
            }
            function ff(a, b, c, d, x, s, t) { return cmn((b & c) | (~b & d), a, b, x, s, t); }
            function gg(a, b, c, d, x, s, t) { return cmn((b & d) | (c & ~d), a, b, x, s, t); }
            function hh(a, b, c, d, x, s, t) { return cmn(b ^ c ^ d, a, b, x, s, t); }
            function ii(a, b, c, d, x, s, t) { return cmn(c ^ (b | ~d), a, b, x, s, t); }
            function md51(s) {
                var txt = '';
                var n = s.length,
                    state = [1732584193, -271733879, -1732584194, 271733878],
                    i;
                for (i = 64; i <= s.length; i += 64) {
                    md5cycle(state, md5blk(s.substring(i - 64, i)));
                }
                s = s.substring(i - 64);
                var tail = new Array(16).fill(0);
                for (i = 0; i < s.length; i++) tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
                tail[i >> 2] |= 0x80 << ((i % 4) << 3);
                if (i > 55) {
                    md5cycle(state, tail);
                    tail = new Array(16).fill(0);
                }
                tail[14] = n * 8;
                md5cycle(state, tail);
                return state;
            }
            function md5blk(s) {
                var md5blks = [], i;
                for (i = 0; i < 64; i += 4) {
                    md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
                }
                return md5blks;
            }
            var hex_chr = '0123456789abcdef'.split('');
            function rhex(n) {
                var s = '', j = 0;
                for (; j < 4; j++) s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
                return s;
            }
            function hex(x) {
                for (var i = 0; i < x.length; i++) x[i] = rhex(x[i]);
                return x.join('');
            }
            function md5(s) { return hex(md51(s)); }
            function add32(a, b) { return (a + b) & 0xFFFFFFFF; }

            // Helper: decode base64 to binary string
            function b64ToBinaryString(b64) {
                try {
                    return atob(b64);
                } catch (e) {
                    // fallback
                    return decodeURIComponent(escape(window.atob(b64)));
                }
            }

            // Build ENEX header
            const exportDate = new Date().toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
            let enex = '<?xml version="1.0" encoding="UTF-8"?>\n';
            enex += '<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export2.dtd">\n';
            enex += `<en-export export-date="${exportDate}" application="UltimateNotesApp" version="1.0">\n`;

            // Iterate notebooks and notes
            const notebooks = state.notebooks || [];
            for (const nb of notebooks) {
                for (const note of nb.notes || []) {
                    enex += '  <note>\n';
                    enex += `    <title>${escapeHTML(note.name || 'Untitled')}</title>\n`;

                    // Collect resources for this note
                    const resources = [];

                    // Map mediaEmbeds to resources/en-media or links
                    let noteHtml = '<en-note>';

                    // Add text boxes as simple divs, preserving order
                    const textBoxes = note.textBoxes || [];
                    for (let tb of textBoxes) {
                        let t = escapeHTML(tb.content || '');
                        // Replace any media placeholders like [media:ID]
                        t = t.replace(/\[media:([^\]]+)\]/g, function(_, mid) {
                            const m = (note.mediaEmbeds || []).find(x => x.id === mid);
                            if (m) {
                                if (m.url && m.url.startsWith('data:')) {
                                    const parts = m.url.split(',');
                                    const meta = parts[0];
                                    const b64 = parts[1] || '';
                                    const mime = (meta.split(':')[1] || '').split(';')[0];
                                    const bin = b64ToBinaryString(b64);
                                    const hash = md5(bin);
                                    resources.push({ mime, data: b64, hash, fileName: m.fileName || 'resource' });
                                    return `<en-media type="${mime}" hash="${hash}"/>`;
                                } else if (m.url) {
                                    // External link  convert to anchor
                                    return `<a href="${escapeHTML(m.url)}">${escapeHTML(m.url)}</a>`;
                                }
                            }
                            return '';
                        });
                        noteHtml += `<div>${t}</div>`;
                    }

                    noteHtml += '</en-note>';

                    enex += '    <content><![CDATA[' + noteHtml + ']]></content>\n';

                    // Append resources
                    for (const r of resources) {
                        enex += '    <resource>\n';
                        enex += `      <data encoding="base64">${r.data}</data>\n`;
                        enex += `      <mime>${r.mime}</mime>\n`;
                        enex += '      <resource-attributes>\n';
                        enex += `        <file-name>${escapeHTML(r.fileName || 'resource')}</file-name>\n`;
                        enex += '      </resource-attributes>\n';
                        enex += '    </resource>\n';
                    }

                    enex += '  </note>\n';
                }
            }

            enex += '</en-export>\n';
            return enex;
        }

        // Evernote Import
        function triggerEvernoteImport() {
            document.getElementById('evernote-import').click();
        }

        function handleEvernoteImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Show import modal
            const modal = document.getElementById('import-modal');
            const status = document.getElementById('import-status');
            const progressBar = document.getElementById('import-progress-bar');
            modal.classList.add('active');
            status.textContent = 'Reading file...';
            progressBar.style.width = '10%';

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    status.textContent = 'Parsing Evernote notes...';
                    progressBar.style.width = '30%';
                    
                    const parser = new DOMParser();
                    const xml = parser.parseFromString(e.target.result, 'text/xml');
                    const notes = xml.querySelectorAll('note');
                    
                    if (notes.length === 0) {
                        status.textContent = 'No notes found in file.';
                        progressBar.style.width = '100%';
                        return;
                    }

                    // Create a new notebook for the import
                    const notebookName = file.name.replace('.enex', '') || 'Evernote Import';
                    const notebook = {
                        id: Date.now().toString(),
                        name: notebookName,
                        notes: [],
                        isOpen: true
                    };

                    status.textContent = `Importing ${notes.length} notes...`;
                    progressBar.style.width = '50%';

                    let imported = 0;
                    notes.forEach((noteEl, index) => {
                        const title = noteEl.querySelector('title')?.textContent || `Note ${index + 1}`;
                        const contentEl = noteEl.querySelector('content');
                        let content = '';
                        let extractedMedia = [];
                        
                        if (contentEl) {
                            // Extract ENML content robustly from the XML node.
                            // In an XMLDocument, `innerHTML` is not reliable. Prefer CDATA node value,
                            // then serialize child nodes to preserve markup for parseENML.
                            let rawContent = '';

                            try {
                                // If the first child is a CDATA section, use its nodeValue
                                const first = contentEl.firstChild;
                                if (first && first.nodeType === 4 && first.nodeValue) { // CDATA_SECTION_NODE === 4
                                    rawContent = first.nodeValue;
                                } else {
                                    // Serialize child nodes to a string (preserves any markup)
                                    const serializer = new XMLSerializer();
                                    rawContent = Array.from(contentEl.childNodes).map(n => serializer.serializeToString(n)).join('');
                                }
                            } catch (xmlErr) {
                                console.warn('XML extraction error, falling back to textContent:', xmlErr);
                                rawContent = contentEl.textContent || '';
                            }

                            console.log('Extracted raw ENML for "' + title + '" (first 200 chars):', rawContent.substring(0, 200));

                            // Some ENML exports HTML-encode entities inside the CDATA; decode them safely
                            try {
                                const ta = document.createElement('textarea');
                                ta.innerHTML = rawContent;
                                rawContent = ta.value;
                            } catch (decodeErr) {
                                console.warn('Failed to decode HTML entities for imported content:', decodeErr);
                            }

                            // Build a list of resources for this note so we can map inline <en-media> tags
                            const resourceEls = Array.from(noteEl.querySelectorAll('resource') || []);
                            const resourcesList = resourceEls.map(res => {
                                const dataEl = res.querySelector('data');
                                const mimeEl = res.querySelector('mime');
                                const fileName = res.querySelector('resource-attributes > file-name')?.textContent || '';
                                const b64 = (dataEl?.textContent || '').replace(/\s+/g, '');
                                const mime = (mimeEl?.textContent || '').trim() || '';
                                return { b64, mime, fileName };
                            });

                            // Transform any <en-media> and special <img> placeholders into real <img> tags
                            // and collect extracted media info for later placement as mediaEmbeds.
                            try {
                                const mediaDoc = new DOMParser().parseFromString(rawContent, 'text/html');

                                // Select en-media tags and img tags that might reference en-media URIs
                                const mediaEls = Array.from(mediaDoc.querySelectorAll('en-media, img'))
                                    .filter(el => el.tagName.toLowerCase() === 'en-media' || (el.tagName.toLowerCase() === 'img' && (el.getAttribute('src') || '').startsWith('en-media')));

                                let mapIdx = 0;
                                mediaEls.forEach((mEl, mi) => {
                                    const res = resourcesList[mapIdx];
                                    if (res && res.b64) {
                                        const url = `data:${res.mime};base64,${res.b64}`;
                                        const img = mediaDoc.createElement('img');
                                        const importId = `import-${index}-${mi}`;
                                        img.setAttribute('src', url);
                                        img.setAttribute('data-import-id', importId);
                                        // Replace the original element with a normal img (so later HTML->text parsing can see it)
                                        mEl.parentNode.replaceChild(img, mEl);

                                        const type = res.mime.startsWith('image/') ? 'image' : res.mime.startsWith('video/') ? 'video' : res.mime.startsWith('audio/') ? 'audio' : 'file';
                                        extractedMedia.push({ id: importId, type, url, fileName: res.fileName });
                                        mapIdx++;
                                    }
                                });

                                // Serialize back to string for parseENML
                                rawContent = mediaDoc.body.innerHTML || rawContent;
                            } catch (transformErr) {
                                console.warn('ENML media transform failed:', transformErr);
                            }

                            // Replace image tags with short placeholders so parseENML keeps a visible marker
                            try {
                                rawContent = rawContent.replace(/<img[^>]*data-import-id=["']([^"']+)["'][^>]*>/gi, '\n[media:$1]\n');
                            } catch (phErr) {
                                console.warn('Failed to add image placeholders:', phErr);
                            }

                            content = parseENML(rawContent);

                            // Log transformed/parsing results and media extracted for debugging
                            console.log('Transformed ENML (first 300 chars):', rawContent.substring(0, 300));
                            console.log('Parsed content (first 300 chars):', content.substring(0, 300));
                            console.log('Extracted media for note', extractedMedia);
                            console.log('Parsed content for "' + title + '":', content.substring(0, 200));
                        } else {
                            console.log('No content element found for "' + title + '"');
                        }

                        const created = noteEl.querySelector('created')?.textContent;
                        const createdDate = created ? parseEvernoteDate(created) : Date.now();

                        const note = {
                            id: (Date.now() + index).toString(),
                            name: title,
                            canvasData: null,
                            textBoxes: [],
                            mediaEmbeds: [],
                            status: 'none',
                            children: [],
                            versionHistory: [],
                            createdAt: createdDate
                        };

                        // Add content as text boxes on canvas
                        // Canvas is 4000x4000, centered, so place content near center (around 1800-2000)
                        const startX = 1800;
                        const startY = 1800;
                        
                        // Always add the title as a header first
                        note.textBoxes.push({
                            content: title,
                            left: startX + 'px',
                            top: startY + 'px',
                            width: '',
                            height: '',
                            fontFamily: 'Inter',
                            fontSize: '24px',
                            color: getDefaultInkColor(),
                            headerLevel: '1'
                        });
                        console.log('Added title textBox for "' + title + '", textBoxes count:', note.textBoxes.length);
                        
                        if (content) {
                            const lines = content.split('\n').filter(l => l.trim());
                            console.log('Content lines for "' + title + '":', lines.length, lines);
                            let yPos = startY + 60;
                            
                            lines.forEach((line, lineIndex) => {
                                if (line.trim()) {
                                    note.textBoxes.push({
                                        content: line.trim(),
                                        left: startX + 'px',
                                        top: yPos + 'px',
                                        width: '',
                                        height: '',
                                        fontFamily: 'Inter',
                                        fontSize: '16px',
                                        color: getDefaultInkColor(),
                                        headerLevel: null
                                    });
                                    yPos += 36;
                                }
                            });
                        }
                        
                        console.log('Final textBoxes for "' + title + '":', note.textBoxes.length, note.textBoxes);

                        // Extract any embedded resources (images/audio/video) and add as media embeds
                        note.mediaEmbeds = note.mediaEmbeds || [];
                        try {
                            if (extractedMedia && extractedMedia.length) {
                                extractedMedia.forEach((m, mi) => {
                                    note.mediaEmbeds.push({
                                        id: m.id,
                                        type: m.type,
                                        url: m.url,
                                        fileName: m.fileName,
                                        left: (startX + 300 + mi * 220) + 'px',
                                        top: (startY + 30) + 'px',
                                        width: '200px',
                                        height: '150px'
                                    });
                                });
                            } else {
                                const resources = noteEl.querySelectorAll('resource');
                                resources.forEach((res, rIndex) => {
                                    const dataEl = res.querySelector('data');
                                    const mimeEl = res.querySelector('mime');
                                    if (dataEl && mimeEl) {
                                        const b64 = (dataEl.textContent || '').replace(/\s+/g, '');
                                        const mime = (mimeEl.textContent || '').trim();
                                        if (b64) {
                                            const url = `data:${mime};base64,${b64}`;
                                            const type = mime.startsWith('image/') ? 'image' : mime.startsWith('video/') ? 'video' : mime.startsWith('audio/') ? 'audio' : 'file';
                                            // Place resources near the note start; offset multiple resources
                                            note.mediaEmbeds.push({
                                                id: `import-${note.id}-${rIndex}`,
                                                type: type,
                                                url: url,
                                                fileName: res.querySelector('resource-attributes > file-name')?.textContent || '',
                                                left: (startX + 300 + rIndex * 220) + 'px',
                                                top: (startY + 30) + 'px',
                                                width: '200px',
                                                height: '150px'
                                            });
                                        }
                                    }
                                });
                            }
                        } catch (resErr) {
                            console.warn('Error extracting resources from ENEX note:', resErr);
                        }

                            // If one of the embedded resources looks like the main drawing (image/png, or filename contains 'draw'/'sketch'),
                            // use it as the canvas image (note.canvasData) and remove it from mediaEmbeds so it doesn't appear twice.
                            try {
                                if ((!note.canvasData || note.canvasData === null) && note.mediaEmbeds && note.mediaEmbeds.length) {
                                    let candidateIdx = note.mediaEmbeds.findIndex(m => m.type === 'image' && /draw|sketch|canvas|drawing/i.test(m.fileName || ''));
                                    if (candidateIdx === -1) {
                                        // If only a single image resource exists, assume it's the canvas drawing
                                        const imageCount = note.mediaEmbeds.filter(m => m.type === 'image').length;
                                        console.log(`Note "${note.name}": ${imageCount} images, ${note.mediaEmbeds.length} total embeds`);
                                        if (imageCount === 1) {
                                            candidateIdx = note.mediaEmbeds.findIndex(m => m.type === 'image');
                                            console.log(`Note "${note.name}": Single image - will use as canvasData`);
                                        }
                                    }
                                    if (candidateIdx !== -1) {
                                        const c = note.mediaEmbeds[candidateIdx];
                                        console.log(`Note "${note.name}": Assigning image to canvasData, url length: ${c.url.length}`);
                                        note.canvasData = c.url;
                                        console.log(`Note "${note.name}": canvasData URL (first 200):`, c.url.slice(0, 200));
                                        // Remove from media embeds to avoid duplicate rendering
                                        note.mediaEmbeds.splice(candidateIdx, 1);
                                    }
                                }
                            } catch (canvasErr) {
                                console.warn('Error assigning canvasData from resources:', canvasErr);
                            }

                        notebook.notes.push(note);
                        imported++;
                        
                        const progress = 50 + (imported / notes.length) * 45;
                        progressBar.style.width = progress + '%';
                        status.textContent = `Imported ${imported} of ${notes.length} notes...`;
                    });

                    state.notebooks.push(notebook);
                    console.log('About to save. Notebook notes:', notebook.notes.map(n => ({name: n.name, textBoxes: n.textBoxes.length})));
                    
                    // Check storage size before saving
                    const dataToSave = JSON.stringify(state.notebooks);
                    console.log('Data size to save:', dataToSave.length, 'chars');
                    
                    try {
                        localStorage.setItem('ultimateNotesApp', dataToSave);
                        console.log('Save successful!');
                        
                        // Verify save
                        const saved = JSON.parse(localStorage.getItem('ultimateNotesApp'));
                        const importedNb = saved.find(nb => nb.id === notebook.id);
                        console.log('Verified save - notebook notes:', importedNb?.notes.map(n => ({name: n.name, textBoxes: n.textBoxes?.length})));
                    } catch (saveErr) {
                        console.error('Save failed:', saveErr);
                        status.textContent = 'Import failed: Storage is full! Clear some old notes first.';
                        // Remove the notebook we just added since save failed
                        state.notebooks.pop();
                        return;
                    }
                    
                    renderNotebooks();
                    renderHomePage();

                    progressBar.style.width = '100%';
                    status.textContent = `Successfully imported ${imported} notes into "${notebookName}"!`;

                    // Prevent immediate auto-save from overwriting imported content
                    suppressNextAutoSave = true;

                } catch (err) {
                    console.error('Import error:', err);
                    status.textContent = 'Error importing file. Please check it\'s a valid .enex file.';
                    progressBar.style.width = '100%';
                }
            };

            reader.onerror = () => {
                status.textContent = 'Error reading file.';
                progressBar.style.width = '100%';
            };

            reader.readAsText(file);
            event.target.value = ''; // Reset input
        }

        // Parse ENML (Evernote Markup Language) to plain text
        function parseENML(enml) {
            if (!enml || typeof enml !== 'string') {
                return '';
            }
            
            try {
                let content = enml.trim();
                
                // If it looks like it has XML/HTML tags, parse it
                if (content.includes('<')) {
                    // Remove XML declaration and DOCTYPE
                    content = content.replace(/<\?xml[^>]*\?>/gi, '');
                    content = content.replace(/<!DOCTYPE[^>]*>/gi, '');
                    
                    // Remove en-note wrapper tags (Evernote's root element)
                    content = content.replace(/<\/?en-note[^>]*>/gi, '');
                    
                    // Convert common tags to text with line breaks
                    content = content.replace(/<br\s*\/?>/gi, '\n');
                    content = content.replace(/<\/div>/gi, '\n');
                    content = content.replace(/<\/p>/gi, '\n\n');
                    content = content.replace(/<\/li>/gi, '\n');
                    content = content.replace(/<\/h[1-6]>/gi, '\n\n');
                    content = content.replace(/<\/tr>/gi, '\n');
                    
                    // Remove all remaining HTML tags
                    content = content.replace(/<[^>]+>/g, '');
                    
                    // Decode HTML entities
                    const textarea = document.createElement('textarea');
                    textarea.innerHTML = content;
                    content = textarea.value;
                }
                
                // Clean up whitespace
                content = content.replace(/\r\n/g, '\n');
                content = content.replace(/[ \t]+/g, ' ');
                content = content.replace(/\n /g, '\n');
                content = content.replace(/ \n/g, '\n');
                content = content.replace(/\n{3,}/g, '\n\n');
                
                return content.trim();
            } catch (e) {
                console.error('ENML parse error:', e);
                // Fallback: just strip all tags
                return enml.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
            }
        }

        // Parse Evernote date format (yyyyMMddTHHmmssZ)
        function parseEvernoteDate(dateStr) {
            try {
                const year = dateStr.substring(0, 4);
                const month = dateStr.substring(4, 6);
                const day = dateStr.substring(6, 8);
                const hour = dateStr.substring(9, 11);
                const min = dateStr.substring(11, 13);
                const sec = dateStr.substring(13, 15);
                return new Date(`${year}-${month}-${day}T${hour}:${min}:${sec}Z`).getTime();
            } catch (e) {
                return Date.now();
            }
        }

        // Escape HTML for safe insertion
        function escapeHTML(str) {
            return str.replace(/&/g, '&amp;')
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;')
                      .replace(/"/g, '&quot;');
        }

        function closeImportModal() {
            document.getElementById('import-modal').classList.remove('active');
        }

        // Modal functions
        let modalMode = 'notebook';

        function showModal(mode) {
            modalMode = mode;
            const modal = document.getElementById('modal');
            const title = document.getElementById('modal-title');
            const input = document.getElementById('modal-input');
            
            if (mode === 'notebook') {
                title.textContent = 'New Notebook';
            } else if (mode === 'subnotebook') {
                title.textContent = 'New Sub-Notebook';
            } else if (mode === 'subnote') {
                title.textContent = 'New Sub-Note';
            } else {
                title.textContent = 'New Note';
            }
            input.placeholder = 'Name';
            input.value = '';
            modal.classList.add('active');
            input.focus();
        }

        function hideModal() {
            document.getElementById('modal').classList.remove('active');
            state.parentNoteForSubnote = null;
        }

        function confirmModal() {
            const input = document.getElementById('modal-input');
            const name = input.value.trim();
            
            if (!name) return;

            if (modalMode === 'notebook') {
                state.parentNotebookForSubnotebook = null;
                createNotebook(name);
            } else if (modalMode === 'subnotebook') {
                // Prevent creating subnotebook if already at depth 5
                let parent = state.parentNotebookForSubnotebook;
                let depth = 0;
                while (parent) {
                    depth++;
                    parent = parent.parentId ? window.findNotebookById(parent.parentId) : null;
                }
                if (depth >= 5) {
                    alert('Maximum subfolder depth (5) reached.');
                    return;
                }
                createNotebook(name);
            } else if (modalMode === 'subnote') {
                createNote(name, state.parentNoteForSubnote);
            } else {
                createNote(name);
            }
            hideModal();
        }

        // Handle Enter key in modal
        document.getElementById('modal-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') confirmModal();
            if (e.key === 'Escape') hideModal();
        });

        // Notebook functions
        function createNotebook(name) {
            const notebook = {
                id: Date.now().toString(),
                name: name,
                notes: [],
                isOpen: true,
                children: [], // subnotebooks
                parentId: null
            };
            // If creating as a subnotebook
            if (state.parentNotebookForSubnotebook) {
                if (!state.parentNotebookForSubnotebook.children) state.parentNotebookForSubnotebook.children = [];
                notebook.parentId = state.parentNotebookForSubnotebook.id;
                state.parentNotebookForSubnotebook.children.push(notebook);
            } else {
                state.notebooks.push(notebook);
            }
            state.currentNotebook = notebook;
            state.parentNotebookForSubnotebook = null;
            renderNotebooks();
            saveToStorage();
        }

        function createNote(name, parentNote = null) {
            if (!state.currentNotebook) return;

            const note = {
                id: Date.now().toString(),
                name: name,
                canvasData: null,
                textBoxes: [],
                mediaEmbeds: [],
                children: [],
                parentId: parentNote ? parentNote.id : null,
                isOpen: false,
                status: 'none' // none, in-progress, finished, needs-review
            };
            
            if (parentNote) {
                // Add as child of parent note
                if (!parentNote.children) parentNote.children = [];
                parentNote.children.push(note);
            } else {
                // Add to notebook root
                state.currentNotebook.notes.push(note);
            }
            
            selectNote(state.currentNotebook, note);
            renderNotebooks();
            saveToStorage();
        }

        // Create sub-note
        function createSubNote(notebookId, noteId, e) {
            e.stopPropagation();
            const notebook = window.findNotebookById(notebookId);
            if (!notebook) return;
            const parentNote = findNoteById(notebook, noteId);
            if (parentNote) {
                state.currentNotebook = notebook;
                state.parentNoteForSubnote = parentNote;
                showModal('subnote');
            }
        }

        // Find note by ID (recursive)
        function findNoteById(notebook, noteId, notes = null) {
            const searchNotes = notes || notebook.notes;
            const targetId = String(noteId);
            for (const note of searchNotes) {
                if (String(note.id) === targetId) return note;
                if (note.children && note.children.length > 0) {
                    const found = findNoteById(notebook, noteId, note.children);
                    if (found) return found;
                }
            }
            return null;
        }

        // Find parent note
        function findParentNote(notebook, noteId, notes = null, parent = null) {
            const searchNotes = notes || notebook.notes;
            for (const note of searchNotes) {
                if (note.id === noteId) return parent;
                if (note.children && note.children.length > 0) {
                    const found = findParentNote(notebook, noteId, note.children, note);
                    if (found !== undefined) return found;
                }
            }
            return undefined;
        }

        // Get note path (breadcrumb)
        function getNotePath(notebook, noteId) {
            const path = [];
            let currentId = noteId;
            
            while (currentId) {
                const note = findNoteById(notebook, currentId);
                if (note) {
                    path.unshift(note);
                    currentId = note.parentId;
                } else {
                    break;
                }
            }
            
            return path;
        }

        async function selectNote(notebook, note) {
            // Save current note before switching
            if (state.currentNote) {
                saveNoteData();
            }

            state.currentNotebook = notebook;
            state.currentNote = note;
            
            // Switch to editor view
            showEditor();
            
            // Show canvas
            document.getElementById('empty-state').style.display = 'none';
            document.getElementById('canvas-wrapper').style.display = 'block';
            document.getElementById('toolbar').style.display = 'flex';
            
            // Always initialize canvases first
            initCanvases();
            // Apply current canvas transform (zoom / pan) to ensure wrapper matches state
            updateCanvasTransform();
            
            // Load note data or create blank canvas
            if (note.canvasData || note.layersData) {
                await loadNoteData(note);
            } else {
                // Clear text layer for new note
                textLayer.innerHTML = '';
                // Clear layers if available
                if (typeof canvasModule !== 'undefined' && canvasModule.manager?.layerManager) {
                    canvasModule.manager.layerManager.clearAll();
                } else {
                    drawCtx.fillStyle = getCanvasBackground();
                    drawCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                }
                // Clear undo history and start version timer
                clearUndoHistory();
                versionHistory = note.versionHistory || [];
                startVersionHistoryTimer();
                saveInitialState();
            }

            // Update UI with breadcrumb path
            updateBreadcrumb(notebook, note);
            
            // Update status selector
            const statusSelect = document.getElementById('status-select');
            if (statusSelect) {
                statusSelect.value = note.status || 'none';
            }
            
            // Render sub-note blocks on canvas
            renderSubnoteBlocks(note);
            
            renderNotebooks();
        }

        // Render sub-note links on canvas (Notion-style blocks)
        function renderSubnoteBlocks(note) {
            // Remove existing sub-note blocks
            const existingBlocks = document.querySelectorAll('.subnote-block');
            existingBlocks.forEach(block => block.remove());
            
            if (!note || !note.children || note.children.length === 0) return;
            
            const textLayer = document.getElementById('text-layer');
            
            // Position sub-notes starting from a default location
            // Store positions in note.subnotePositions if they exist
            if (!note.subnotePositions) {
                note.subnotePositions = {};
            }
            
            note.children.forEach((child, index) => {
                // Get stored position or calculate default (center of canvas)
                const pos = note.subnotePositions[child.id] || {
                    x: 1800,
                    y: 1800 + (index * 80)
                };
                
                const block = document.createElement('div');
                block.className = 'subnote-block';
                block.style.left = pos.x + 'px';
                block.style.top = pos.y + 'px';
                block.setAttribute('data-subnote-id', child.id);
                
                block.innerHTML = `
                    <div class="subnote-block-icon"></div>
                    <div class="subnote-block-content">
                        <div class="subnote-block-name">${child.name}</div>
                        <div class="subnote-block-hint">Click to open</div>
                    </div>
                    <div class="subnote-block-arrow"></div>
                `;
                
                // Click to navigate
                block.addEventListener('click', (e) => {
                    if (!block.classList.contains('dragging')) {
                        selectNoteById(state.currentNotebook.id, child.id);
                    }
                });
                
                // Make draggable
                makeSubnoteBlockDraggable(block, child.id);
                
                textLayer.appendChild(block);
            });
        }

        // Make sub-note block draggable
        function makeSubnoteBlockDraggable(block, childId) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            block.addEventListener('mousedown', (e) => {
                if (e.target.closest('.subnote-block-arrow')) return;
                
                isDragging = false;
                startX = e.clientX;
                startY = e.clientY;
                initialX = parseInt(block.style.left) || 0;
                initialY = parseInt(block.style.top) || 0;
                
                const onMouseMove = (e) => {
                    const dx = (e.clientX - startX) / state.zoom;
                    const dy = (e.clientY - startY) / state.zoom;
                    
                    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                        isDragging = true;
                        block.classList.add('dragging');
                    }
                    
                    if (isDragging) {
                        block.style.left = (initialX + dx) + 'px';
                        block.style.top = (initialY + dy) + 'px';
                    }
                };
                
                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    
                    if (isDragging) {
                        // Save new position
                        if (!state.currentNote.subnotePositions) {
                            state.currentNote.subnotePositions = {};
                        }
                        state.currentNote.subnotePositions[childId] = {
                            x: parseInt(block.style.left),
                            y: parseInt(block.style.top)
                        };
                        markUnsaved();
                        
                        // Remove dragging class after a short delay
                        setTimeout(() => {
                            block.classList.remove('dragging');
                        }, 100);
                    }
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        // ==================== MEDIA EMBED FUNCTIONS ====================
        
        // Detect media type from URL
        function detectMediaType(url) {
            const urlLower = url.toLowerCase();
            
            // Image extensions
            if (/\.(jpg|jpeg|png|gif|webp|svg|bmp|ico)(\?.*)?$/i.test(url)) {
                return 'image';
            }
            
            // Video extensions
            if (/\.(mp4|webm|ogg|mov|avi|mkv)(\?.*)?$/i.test(url)) {
                return 'video';
            }
            
            // Audio extensions
            if (/\.(mp3|wav|ogg|m4a|flac|aac|wma)(\?.*)?$/i.test(url)) {
                return 'audio';
            }
            
            // YouTube
            if (urlLower.includes('youtube.com/watch') || urlLower.includes('youtu.be/')) {
                return 'youtube';
            }
            
            // Vimeo
            if (urlLower.includes('vimeo.com/')) {
                return 'vimeo';
            }
            
            // Twitter/X
            if (urlLower.includes('twitter.com/') || urlLower.includes('x.com/')) {
                return 'twitter';
            }
            
            // Spotify
            if (urlLower.includes('spotify.com/')) {
                return 'spotify';
            }
            
            // SoundCloud
            if (urlLower.includes('soundcloud.com/')) {
                return 'soundcloud';
            }
            
            // Google Maps
            if (urlLower.includes('google.com/maps') || urlLower.includes('goo.gl/maps')) {
                return 'maps';
            }
            
            // Evernote note links
            // Catch ALL evernote.com URLs as evernote-link type (not iframe)
            if (/evernote\.com/i.test(url) || /^evernote:\/\//i.test(url)) {
                return 'evernote-link';
            } else if (url.startsWith('http://') || url.startsWith('https://')) {
                return 'iframe';
            }
            
            // Data URLs (for uploaded files)
            if (url.startsWith('data:image/')) {
                return 'image';
            }
            if (url.startsWith('data:video/')) {
                return 'video';
            }
            if (url.startsWith('data:audio/')) {
                return 'audio';
            }
            if (url.startsWith('data:application/pdf')) {
                return 'pdf';
            }
            // URL ending in .pdf
            if (url.toLowerCase().endsWith('.pdf')) {
                return 'pdf';
            }
            
            return null;
        }

        // Get embed URL for various services
        function getEmbedUrl(url, type) {
            switch (type) {
                case 'youtube': {
                    let videoId = '';
                    if (url.includes('youtu.be/')) {
                        // Handle youtu.be/VIDEO_ID format
                        videoId = url.split('youtu.be/')[1].split(/[?&#]/)[0];
                    } else if (url.includes('youtube.com/watch')) {
                        // Handle youtube.com/watch?v=VIDEO_ID format
                        try {
                            const urlObj = new URL(url);
                            videoId = urlObj.searchParams.get('v');
                        } catch (e) {
                            // Fallback parsing
                            const match = url.match(/[?&]v=([^&]+)/);
                            videoId = match ? match[1] : '';
                        }
                    } else if (url.includes('youtube.com/embed/')) {
                        // Already an embed URL
                        videoId = url.split('youtube.com/embed/')[1].split(/[?&#]/)[0];
                    } else if (url.includes('youtube.com/v/')) {
                        // Old style embed URL
                        videoId = url.split('youtube.com/v/')[1].split(/[?&#]/)[0];
                    }
                    if (!videoId) {
                        return url; // Return original if parsing failed
                    }
                    // Use youtube-nocookie.com for better privacy and fewer errors
                    return `https://www.youtube-nocookie.com/embed/${videoId}?rel=0`;
                }
                case 'vimeo': {
                    const videoId = url.split('vimeo.com/')[1].split(/[?&/]/)[0];
                    return `https://player.vimeo.com/video/${videoId}`;
                }
                case 'spotify': {
                    // Convert spotify URL to embed URL
                    const spotifyPath = url.split('spotify.com/')[1];
                    return `https://open.spotify.com/embed/${spotifyPath}`;
                }
                default:
                    return url;
            }
        }

        // Create media embed element
        function createMediaEmbed(url, type, options = {}) {
            // Final safeguard: never embed Evernote links as iframes (catch all evernote.com URLs)
            if (type === 'iframe' && /evernote\.com/i.test(url)) {
                return null;
            }

            const mediaLayer = document.getElementById('media-layer');

            const embed = document.createElement('div');
            embed.className = 'media-embed';
            embed.setAttribute('data-embed-id', options.id || Date.now().toString());
            embed.setAttribute('data-embed-type', type);
            embed.setAttribute('data-embed-url', url);

            // Set position - default to center of canvas
            embed.style.left = options.left || '100px';
            embed.style.top = options.top || '100px';

            // Set size - use provided dimensions or auto-size later
            if (options.width) embed.style.width = options.width;
            if (options.height) embed.style.height = options.height;

            // For new embeds without saved dimensions, start with auto sizing
            const autoSize = !options.width && !options.height;

            // Create content container
            const content = document.createElement('div');
            content.className = 'media-embed-content';

            // Create controls (Delete, Layer transitions, Draw Above toggle)
            const controls = document.createElement('div');
            controls.className = 'media-embed-controls';
            controls.innerHTML = `
                <button class="media-embed-btn" onclick="deleteMediaEmbed(this.closest('.media-embed'))" title="Delete"></button>
                <button class="media-embed-btn" onclick="moveEmbedToLayerBelow(this.closest('.media-embed'))" title="Move to Layer Below"></button>
                <button class="media-embed-btn" onclick="moveEmbedToLayerAbove(this.closest('.media-embed'))" title="Move to Layer Above"></button>
                <button class="media-embed-btn" onclick="toggleDrawAbove(this.closest('.media-embed'))" title="Draw Over"></button>
            `;

            // Create resize handle
            const resizeHandle = document.createElement('div');
            // ...existing code...

            // Add loading state
            content.innerHTML = '<div class="media-embed-loading">Loading...</div>';

            embed.appendChild(content);
            embed.appendChild(controls);
            embed.appendChild(resizeHandle);

            // Add to specified layer or active layer's content container, otherwise use mediaLayer
            let targetContainer = mediaLayer;
            let targetLayerId = null;
            
            if (typeof canvasModule !== 'undefined' && canvasModule.manager?.layerManager) {
                const layerManager = canvasModule.manager.layerManager;
                
                // If layerId is provided (loading from save), find that layer
                if (options.layerId) {
                    const targetLayer = layerManager.layers.find(l => l.id === options.layerId);
                    if (targetLayer && targetLayer.contentContainer) {
                        // Re-insert content container if not in DOM
                        if (!document.body.contains(targetLayer.contentContainer)) {
                            const wrapper = document.getElementById('canvas-wrapper');
                            if (wrapper && targetLayer.canvas) {
                                if (targetLayer.canvas.nextSibling) {
                                    wrapper.insertBefore(targetLayer.contentContainer, targetLayer.canvas.nextSibling);
                                } else {
                                    wrapper.appendChild(targetLayer.contentContainer);
                                }
                            }
                        }
                        targetContainer = targetLayer.contentContainer;
                        targetLayerId = targetLayer.id;
                    }
                } else {
                    // New embed - add to active (selected) layer
                    const activeLayer = layerManager.getActiveLayer();
                    if (activeLayer && activeLayer.contentContainer) {
                        // Re-insert content container if not in DOM
                        if (!document.body.contains(activeLayer.contentContainer)) {
                            const wrapper = document.getElementById('canvas-wrapper');
                            if (wrapper && activeLayer.canvas) {
                                if (activeLayer.canvas.nextSibling) {
                                    wrapper.insertBefore(activeLayer.contentContainer, activeLayer.canvas.nextSibling);
                                } else {
                                    wrapper.appendChild(activeLayer.contentContainer);
                                }
                            }
                        }
                        targetContainer = activeLayer.contentContainer;
                        targetLayerId = activeLayer.id;
                    }
                }
            }
            
            targetContainer.appendChild(embed);
            if (targetLayerId) {
                embed.setAttribute('data-layer-id', targetLayerId);
            }

            // Add resize functionality
            makeMediaEmbedResizable(embed, resizeHandle);

            // Load the actual content based on type
            switch (type) {
                case 'image':
                    loadImageEmbed(embed, content, url, autoSize);
                    break;
                case 'video':
                    loadVideoEmbed(embed, content, url, autoSize);
                    break;
                case 'audio':
                    loadAudioEmbed(embed, content, url);
                    if (autoSize) {
                        embed.style.width = '320px';
                        embed.style.height = '120px';
                    }
                    break;
                case 'youtube':
                    loadYouTubeEmbed(content, url);
                    if (autoSize) {
                        embed.style.width = '560px';
                        embed.style.height = '315px';
                    }
                    break;
                case 'vimeo':
                    loadVimeoEmbed(content, url);
                    if (autoSize) {
                        embed.style.width = '560px';
                        embed.style.height = '315px';
                    }
                    break;
                case 'spotify':
                    loadIframeEmbed(content, getEmbedUrl(url, type));
                    if (autoSize) {
                        embed.style.width = '400px';
                        embed.style.height = '152px';
                    }
                    break;
                case 'evernote-link':
                    // Rich Evernote preview card
                    const noteId = url.match(/\/([a-f0-9-]+)(?:\?|$)/i)?.[1] || '';
                    const shortUrl = url.length > 50 ? url.substring(0, 47) + '...' : url;
                    content.innerHTML = `
                        <div style="display:flex;flex-direction:column;height:100%;background:linear-gradient(135deg, #f8faf5 0%, #e8f5e0 100%);border-radius:8px;overflow:hidden;font-family:Inter,sans-serif;pointer-events:auto;" onclick="event.stopPropagation();">
                            <div style="background:#1db954;padding:12px 16px;display:flex;align-items:center;gap:12px;">
                                <svg width="28" height="28" viewBox="0 0 24 24" fill="white">
                                    <path d="M8 3a2 2 0 0 0-2 2v4a2 2 0 0 1-2 2H3v2h1a2 2 0 0 1 2 2v4a2 2 0 0 0 2 2h2v-2H8v-4a2 2 0 0 0-2-2 2 2 0 0 0 2-2V5h2V3H8zm8 0a2 2 0 0 1 2 2v4a2 2 0 0 0 2 2h1v2h-1a2 2 0 0 0-2 2v4a2 2 0 0 1-2 2h-2v-2h2v-4a2 2 0 0 1 2-2 2 2 0 0 1-2-2V5h-2V3h2z"/>
                                </svg>
                                <span style="color:white;font-weight:600;font-size:1.1rem;">Evernote Note</span>
                            </div>
                            <div style="flex:1;padding:16px;display:flex;flex-direction:column;gap:12px;">
                                <div style="display:flex;align-items:center;gap:10px;">
                                    <span style="font-size:2.5rem;"></span>
                                    <div style="flex:1;">
                                        <div style="font-weight:600;font-size:1rem;color:#2d3748;margin-bottom:4px;">Linked Note</div>
                                        <div style="font-size:0.85rem;color:#718096;word-break:break-all;">${shortUrl}</div>
                                    </div>
                                </div>
                                <div style="margin-top:auto;display:flex;gap:10px;">
                                    <a href="${url}" target="_blank" style="flex:1;display:flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;background:#1db954;color:white;text-decoration:none;border-radius:8px;font-weight:600;font-size:0.95rem;transition:background 0.2s;" onmouseover="this.style.background='#18a349'" onmouseout="this.style.background='#1db954'">
                                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/>
                                            <polyline points="15 3 21 3 21 9"/>
                                            <line x1="10" y1="14" x2="21" y2="3"/>
                                        </svg>
                                        Open in Evernote
                                    </a>
                                </div>
                            </div>
                        </div>`;
                    if (autoSize) {
                        embed.style.width = '320px';
                        embed.style.height = '220px';
                    }
                    break;
                case 'iframe':
                    loadIframeEmbed(content, url);
                    if (autoSize) {
                        embed.style.width = '500px';
                        embed.style.height = '400px';
                    }
                    break;
                case 'pdf':
                    loadPdfEmbed(content, url);
                    if (autoSize) {
                        embed.style.width = '600px';
                        embed.style.height = '800px';
                    }
                    break;
                default:
                    content.innerHTML = '<div class="media-embed-error">Unsupported media type</div>';
                    if (autoSize) {
                        embed.style.width = '200px';
                        embed.style.height = '100px';
                    }
            }
            
            // Make draggable
            makeMediaEmbedDraggable(embed);
            
            // Add select handler
            addMediaEmbedSelectHandler(embed);
            // Initialize z-order for this embed
            initEmbedZOrder(embed);
            try { updateMediaLayerZ(); } catch (e) { /* ignore */ }
            
            markUnsaved();
            return embed;
        }

        // Z-order management for media embeds
        function getAllEmbeds() {
            return Array.from(document.querySelectorAll('.media-embed'));
        }

        function initEmbedZOrder(embed) {
            const embeds = getAllEmbeds().filter(e => e !== embed);
            const maxZ = embeds.reduce((m, e) => {
                const z = parseInt(e.dataset.z || e.style.zIndex) || 0; return Math.max(m, z);
            }, 2);
            const z = (parseInt(embed.dataset.z) || 0) || (maxZ + 1);
            setEmbedZ(embed, z);
            normalizeEmbedZs();
        }

        function setEmbedZ(embed, z) {
            embed.dataset.z = String(z);
            embed.style.zIndex = String(z);
        }

        function normalizeEmbedZs() {
            const embeds = getAllEmbeds().sort((a, b) => (parseInt(a.dataset.z||a.style.zIndex||0) - parseInt(b.dataset.z||b.style.zIndex||0)));
            let base = 4; // start above drawing canvas (1) and text-layer/text-box (2-3)
            embeds.forEach(e => {
                setEmbedZ(e, base);
                base++;
            });
            // If there's a draw-target, ensure drawing canvas zIndex follows it
            const drawTargetId = document.getElementById('drawing-canvas')?.dataset.drawTargetId;
            if (drawTargetId) {
                const target = document.querySelector(`.media-embed[data-embed-id="${drawTargetId}"]`);
                if (target) {
                    const tz = parseInt(target.dataset.z) || 0;
                    document.getElementById('drawing-canvas').style.zIndex = String(tz + 1);
                }
            }
            // Update media-layer z based on embeds vs text-layer stacking
            try { updateMediaLayerZ(); } catch (e) { console.warn('updateMediaLayerZ failed', e); }
        }

        // Raise or lower the media-layer z-index depending on embed z values
        function updateMediaLayerZ() {
            const mediaLayer = document.getElementById('media-layer');
            const textLayer = document.getElementById('text-layer');
            if (!mediaLayer || !textLayer) return;
            // Compute max z among text layer and text-boxes to compare against embeds
            const baseTextZ = parseInt(window.getComputedStyle(textLayer).zIndex) || 5;
            const textBoxes = Array.from(textLayer.querySelectorAll('.text-box'));
            const maxTextBoxZ = textBoxes.reduce((m, tb) => Math.max(m, parseInt(tb.style.zIndex || window.getComputedStyle(tb).zIndex || 0)), baseTextZ);
            const textZ = Math.max(baseTextZ, maxTextBoxZ);
            const embeds = getAllEmbeds();
            if (embeds.length === 0) {
                mediaLayer.style.zIndex = '3';
                return;
            }
            const maxEmbedZ = embeds.reduce((m, e) => Math.max(m, parseInt(e.dataset.z || e.style.zIndex || 0)), 0);
            if (maxEmbedZ > textZ) {
                // Bring media-layer above text-layer so top embeds can appear over text and text-boxes
                mediaLayer.style.zIndex = String(maxEmbedZ + 1);
            } else {
                // Keep default media layer beneath text
                mediaLayer.style.zIndex = '3';
            }
        }

        function bringEmbedForward(embed) {
            const embeds = getAllEmbeds().sort((a,b)=>parseInt(a.dataset.z||a.style.zIndex||0)-parseInt(b.dataset.z||b.style.zIndex||0));
            const idx = embeds.indexOf(embed);
            if (idx === -1 || idx === embeds.length - 1) return;
            // swap z with next
            const next = embeds[idx+1];
            const z1 = parseInt(embed.dataset.z||embed.style.zIndex||0);
            const z2 = parseInt(next.dataset.z||next.style.zIndex||0);
            setEmbedZ(embed, z2);
            setEmbedZ(next, z1);
            // Also move the embed after the next sibling in DOM so it appears visually above
            try {
                const parent = embed.parentElement;
                if (parent && parent.contains(next) && parent.contains(embed)) {
                    parent.insertBefore(embed, next.nextSibling);
                }
            } catch (e) { console.warn('Failed to reorder DOM for bringEmbedForward', e); }
            console.log('bringEmbedForward:', embed.getAttribute('data-embed-id'), 'newZ', embed.dataset.z);
            normalizeEmbedZs();
            markUnsaved();
        }

        function sendEmbedBackward(embed) {
            const embeds = getAllEmbeds().sort((a,b)=>parseInt(a.dataset.z||a.style.zIndex||0)-parseInt(b.dataset.z||b.style.zIndex||0));
            const idx = embeds.indexOf(embed);
            if (idx <= 0) return;
            const prev = embeds[idx-1];
            const z1 = parseInt(embed.dataset.z||embed.style.zIndex||0);
            const z2 = parseInt(prev.dataset.z||prev.style.zIndex||0);
            setEmbedZ(embed, z2);
            setEmbedZ(prev, z1);
            // Also move the embed before the previous sibling in DOM so it appears visually behind
            try {
                const parent = embed.parentElement;
                if (parent && parent.contains(prev) && parent.contains(embed)) {
                    parent.insertBefore(embed, prev);
                }
            } catch (e) { console.warn('Failed to reorder DOM for sendEmbedBackward', e); }
            console.log('sendEmbedBackward:', embed.getAttribute('data-embed-id'), 'newZ', embed.dataset.z);
            normalizeEmbedZs();
            markUnsaved();
        }

        function bringEmbedToFront(embed) {
            const maxZ = getAllEmbeds().reduce((m,e)=>Math.max(m, parseInt(e.dataset.z||e.style.zIndex||0)), 0);
            setEmbedZ(embed, maxZ + 1);
            normalizeEmbedZs();
            markUnsaved();
        }

        function sendEmbedToBack(embed) {
            const minZ = getAllEmbeds().reduce((m,e)=>Math.min(m || 9999, parseInt(e.dataset.z||e.style.zIndex||9999)), 9999);
            setEmbedZ(embed, Math.max(1, minZ - 1));
            normalizeEmbedZs();
            markUnsaved();
        }

        // Show a toast notification
        function showLayerToast(message) {
            // Remove existing toast if any
            const existingToast = document.getElementById('layer-toast');
            if (existingToast) existingToast.remove();
            
            const toast = document.createElement('div');
            toast.id = 'layer-toast';
            toast.style.cssText = `
                position: fixed;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.85);
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                z-index: 999999;
                animation: toastFadeIn 0.2s ease;
                pointer-events: none;
            `;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            // Auto-remove after 2 seconds
            setTimeout(() => {
                toast.style.animation = 'toastFadeOut 0.3s ease forwards';
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        }

        // Move embed to the layer above
        function moveEmbedToLayerAbove(embed) {
            if (typeof canvasModule === 'undefined' || !canvasModule.manager?.layerManager) {
                showLayerToast('Layers not available');
                return;
            }
            
            const layerManager = canvasModule.manager.layerManager;
            const currentLayerId = embed.getAttribute('data-layer-id');
            
            // Find current layer index
            let currentIndex = layerManager.layers.findIndex(l => l.id === currentLayerId);
            if (currentIndex === -1) {
                // Not on a layer, put it on the active layer
                currentIndex = layerManager.activeLayerIndex;
            }
            
            // Check if there's a layer above
            if (currentIndex >= layerManager.layers.length - 1) {
                showLayerToast('Already on top layer');
                return;
            }
            
            const targetLayer = layerManager.layers[currentIndex + 1];
            if (!targetLayer || !targetLayer.contentContainer) {
                showLayerToast('No layer above');
                return;
            }
            
            // Move embed to target layer
            targetLayer.contentContainer.appendChild(embed);
            embed.setAttribute('data-layer-id', targetLayer.id);
            
            showLayerToast(`Moved to: ${targetLayer.name}`);
            markUnsaved();
        }

        // Move embed to the layer below
        function moveEmbedToLayerBelow(embed) {
            if (typeof canvasModule === 'undefined' || !canvasModule.manager?.layerManager) {
                showLayerToast('Layers not available');
                return;
            }
            
            const layerManager = canvasModule.manager.layerManager;
            const currentLayerId = embed.getAttribute('data-layer-id');
            
            // Find current layer index
            let currentIndex = layerManager.layers.findIndex(l => l.id === currentLayerId);
            if (currentIndex === -1) {
                // Not on a layer, put it on the active layer
                currentIndex = layerManager.activeLayerIndex;
            }
            
            // Check if there's a layer below
            if (currentIndex <= 0) {
                showLayerToast('Already on bottom layer');
                return;
            }
            
            const targetLayer = layerManager.layers[currentIndex - 1];
            if (!targetLayer || !targetLayer.contentContainer) {
                showLayerToast('No layer below');
                return;
            }
            
            // Move embed to target layer
            targetLayer.contentContainer.appendChild(embed);
            embed.setAttribute('data-layer-id', targetLayer.id);
            
            showLayerToast(`Moved to: ${targetLayer.name}`);
            markUnsaved();
        }

        // Toggle drawing layer above a specific embed
        function toggleDrawAbove(embed) {
            const canvas = document.getElementById('drawing-canvas');
            if (!canvas) return;
            const mediaLayer = document.getElementById('media-layer');
            const mediaZ = parseInt((mediaLayer && window.getComputedStyle(mediaLayer).zIndex) || 3) || 3;
            const isActive = canvas.dataset.drawAbove === 'true';
            if (isActive) {
                // disable draw-above
                canvas.dataset.drawAbove = 'false';
                canvas.style.zIndex = '2';
                embed.querySelector('.media-embed-btn[title="Draw Over"]')?.classList.remove('active');
            } else {
                // enable draw above media layer (but keep text layer above)
                canvas.dataset.drawAbove = 'true';
                // Put drawing canvas above media layer but below text-layer
                canvas.style.zIndex = String(mediaZ + 1);
                // mark this embed's button active (visual hint)
                getAllEmbeds().forEach(e=> e.querySelector('.media-embed-btn[title="Draw Over"]')?.classList.remove('active'));
                embed.querySelector('.media-embed-btn[title="Draw Over"]')?.classList.add('active');
            }
        }

        function loadImageEmbed(embed, container, url, autoSize) {
            const img = new Image();
            img.onload = () => {
                container.innerHTML = '';
                container.appendChild(img);
                
                // Auto-size embed to fit image (with max constraints)
                if (autoSize) {
                    const maxWidth = 800;
                    const maxHeight = 600;
                    let width = img.naturalWidth;
                    let height = img.naturalHeight;
                    
                    // Scale down if too large
                    if (width > maxWidth) {
                        height = height * (maxWidth / width);
                        width = maxWidth;
                    }
                    if (height > maxHeight) {
                        width = width * (maxHeight / height);
                        height = maxHeight;
                    }
                    
                    // Minimum size
                    width = Math.max(width, 100);
                    height = Math.max(height, 80);
                    
                    embed.style.width = width + 'px';
                    embed.style.height = height + 'px';
                }
            };
            img.onerror = () => {
                container.innerHTML = '<div class="media-embed-error">Failed to load image</div>';
                if (autoSize) {
                    embed.style.width = '200px';
                    embed.style.height = '100px';
                }
            };
            img.src = url;
            img.style.pointerEvents = 'none';
        }

        function loadVideoEmbed(embed, container, url, autoSize) {
            const video = document.createElement('video');
            video.controls = true;
            video.src = url;
            video.onloadedmetadata = () => {
                container.innerHTML = '';
                container.appendChild(video);
                
                // Auto-size embed to fit video (with max constraints)
                if (autoSize) {
                    const maxWidth = 800;
                    const maxHeight = 600;
                    let width = video.videoWidth;
                    let height = video.videoHeight;
                    
                    // Scale down if too large
                    if (width > maxWidth) {
                        height = height * (maxWidth / width);
                        width = maxWidth;
                    }
                    if (height > maxHeight) {
                        width = width * (maxHeight / height);
                        height = maxHeight;
                    }
                    
                    // Minimum size
                    width = Math.max(width, 200);
                    height = Math.max(height, 150);
                    
                    embed.style.width = width + 'px';
                    embed.style.height = height + 'px';
                }
            };
            video.onerror = () => {
                container.innerHTML = '<div class="media-embed-error">Failed to load video</div>';
                if (autoSize) {
                    embed.style.width = '300px';
                    embed.style.height = '200px';
                }
            };
        }

        function loadAudioEmbed(embed, container, url) {
            container.innerHTML = '';
            container.style.flexDirection = 'column';
            container.style.padding = '15px';
            
            const icon = document.createElement('div');
            icon.className = 'media-embed-audio-icon';
            icon.textContent = '';
            
            const audio = document.createElement('audio');
            audio.controls = true;
            audio.src = url;
            audio.style.width = '100%';
            
            container.appendChild(icon);
            container.appendChild(audio);
            
            audio.onerror = () => {
                container.innerHTML = '<div class="media-embed-error">Failed to load audio</div>';
            };
        }

        function loadPdfEmbed(container, url) {
            container.innerHTML = '';
            container.style.display = 'flex';
            container.style.flexDirection = 'column';
            container.style.height = '100%';
            
            // Create toolbar
            const toolbar = document.createElement('div');
            toolbar.style.cssText = 'display:flex;align-items:center;justify-content:space-between;padding:8px 12px;background:#f5f5f5;border-bottom:1px solid #ddd;';
            toolbar.innerHTML = `
                <div style="display:flex;align-items:center;gap:8px;">
                    <span style="font-size:1.2rem;"></span>
                    <span style="font-weight:600;font-size:0.9rem;color:#333;">PDF Document</span>
                </div>
                <a href="${url}" download style="padding:6px 12px;background:#007AFF;color:white;text-decoration:none;border-radius:6px;font-size:0.85rem;font-weight:500;">Download</a>
            `;
            
            // Create PDF viewer using embed element
            const pdfViewer = document.createElement('embed');
            pdfViewer.src = url;
            pdfViewer.type = 'application/pdf';
            pdfViewer.style.cssText = 'flex:1;width:100%;height:100%;border:none;';
            
            container.appendChild(toolbar);
            container.appendChild(pdfViewer);
            
            // Fallback for browsers that don't support embedded PDFs
            pdfViewer.onerror = () => {
                container.innerHTML = `
                    <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;gap:16px;padding:20px;text-align:center;">
                        <span style="font-size:4rem;"></span>
                        <div style="font-weight:600;font-size:1.1rem;color:#333;">PDF Document</div>
                        <div style="color:#666;font-size:0.9rem;">Your browser cannot display this PDF inline.</div>
                        <a href="${url}" download style="padding:12px 24px;background:#007AFF;color:white;text-decoration:none;border-radius:8px;font-weight:600;">Download PDF</a>
                    </div>
                `;
            };
        }

        function loadIframeEmbed(container, url) {
            const iframe = document.createElement('iframe');
            iframe.src = url;
            iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
            iframe.allowFullscreen = true;
            iframe.setAttribute('frameborder', '0');
            iframe.setAttribute('referrerpolicy', 'strict-origin-when-cross-origin');
            iframe.onload = () => {
                container.innerHTML = '';
                container.appendChild(iframe);
            };
            iframe.onerror = () => {
                container.innerHTML = '<div class="media-embed-error">Failed to load content</div>';
            };
            // Add iframe immediately since onload may not fire for cross-origin
            container.innerHTML = '';
            container.appendChild(iframe);
        }

        // Extract YouTube video ID from URL
        function getYouTubeVideoId(url) {
            let videoId = '';
            if (url.includes('youtu.be/')) {
                videoId = url.split('youtu.be/')[1].split(/[?&#]/)[0];
            } else if (url.includes('youtube.com/watch')) {
                try {
                    const urlObj = new URL(url);
                    videoId = urlObj.searchParams.get('v');
                } catch (e) {
                    const match = url.match(/[?&]v=([^&]+)/);
                    videoId = match ? match[1] : '';
                }
            } else if (url.includes('youtube.com/embed/')) {
                videoId = url.split('youtube.com/embed/')[1].split(/[?&#]/)[0];
            } else if (url.includes('youtube.com/v/')) {
                videoId = url.split('youtube.com/v/')[1].split(/[?&#]/)[0];
            }
            return videoId;
        }

        // Load YouTube embed - loads iframe directly to avoid Error 153
        function loadYouTubeEmbed(container, url) {
            const videoId = getYouTubeVideoId(url);
            if (!videoId) {
                container.innerHTML = '<div class="media-embed-error"> Invalid YouTube URL<br><small>Please check the URL and try again</small></div>';
                return;
            }
            
            // Create iframe without origin parameter (works better for local files)
            // Using minimal parameters to maximize compatibility
            const iframe = document.createElement('iframe');
            iframe.src = `https://www.youtube.com/embed/${videoId}?rel=0&modestbranding=1&playsinline=1`;
            iframe.setAttribute('frameborder', '0');
            iframe.setAttribute('allowfullscreen', 'true');
            iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share');
            iframe.setAttribute('referrerpolicy', 'no-referrer-when-downgrade');
            iframe.setAttribute('sandbox', 'allow-same-origin allow-scripts allow-popups allow-forms allow-presentation');
            iframe.style.cssText = 'width:100%;height:100%;border:none;display:block;background:#000;';
            
            // Detect if embedding failed (Error 153) and show fallback
            let embedFailed = false;
            const errorTimeout = setTimeout(() => {
                embedFailed = true;
            }, 5000);
            
            iframe.onload = () => {
                clearTimeout(errorTimeout);
                // Try to detect if iframe loaded properly
                try {
                    if (iframe.contentWindow) {
                        // Successfully loaded
                    }
                } catch (e) {
                    // Cross-origin, but that's expected
                }
            };
            
            // Fallback: Create a thumbnail with "Watch on YouTube" button
            const createFallback = () => {
                const thumbnailUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;
                const fallback = document.createElement('div');
                fallback.style.cssText = 'position:relative;width:100%;height:100%;background:#000 url(' + thumbnailUrl + ') center/cover;display:flex;align-items:center;justify-content:center;cursor:pointer;';
                fallback.innerHTML = `
                    <div style="background:rgba(0,0,0,0.85);padding:24px 32px;border-radius:12px;text-align:center;color:white;backdrop-filter:blur(8px);border:2px solid rgba(255,255,255,0.1);">
                        <div style="font-size:48px;margin-bottom:12px;"></div>
                        <div style="font-size:16px;font-weight:600;margin-bottom:8px;">Video Embedding Restricted</div>
                        <div style="font-size:13px;color:#ccc;margin-bottom:16px;">This video can't be embedded</div>
                        <button style="background:#FF0000;color:white;border:none;padding:12px 24px;border-radius:8px;font-size:14px;font-weight:600;cursor:pointer;font-family:inherit;box-shadow:0 4px 12px rgba(255,0,0,0.3);" onmouseover="this.style.background='#CC0000'" onmouseout="this.style.background='#FF0000'">
                            Watch on YouTube
                        </button>
                    </div>
                `;
                fallback.onclick = () => {
                    window.open('https://youtube.com/watch?v=' + videoId, '_blank');
                };
                return fallback;
            };
            
            container.innerHTML = '<div class="media-embed-loading"> Loading video...</div>';
            
            // Replace loading with iframe
            setTimeout(() => {
                container.innerHTML = '';
                container.appendChild(iframe);
                
                // Check if we're on file:// protocol
                if (window.location.protocol === 'file:') {
                    // Replace with fallback immediately on file://
                    setTimeout(() => {
                        container.innerHTML = '';
                        container.appendChild(createFallback());
                    }, 1000);
                }
            }, 100);
        }

        // Load Vimeo embed with thumbnail fallback
        function loadVimeoEmbed(container, url) {
            const videoId = url.split('vimeo.com/')[1]?.split(/[?&/]/)[0];
            if (!videoId) {
                container.innerHTML = '<div class="media-embed-error">Invalid Vimeo URL</div>';
                return;
            }
            
            const watchUrl = `https://vimeo.com/${videoId}`;
            
            // Create a preview that links to Vimeo
            const wrapper = document.createElement('div');
            wrapper.className = 'vimeo-preview';
            wrapper.style.cssText = 'position:relative;width:100%;height:100%;cursor:pointer;background:linear-gradient(135deg,#1ab7ea,#162221);display:flex;align-items:center;justify-content:center;flex-direction:column;';
            
            const playBtn = document.createElement('div');
            playBtn.innerHTML = `<svg viewBox="0 0 24 24" style="width:64px;height:64px;fill:#fff;opacity:0.9;"><path d="M8 5v14l11-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/></svg>`;
            
            const label = document.createElement('div');
            label.textContent = 'Click to watch on Vimeo';
            label.style.cssText = 'color:#fff;font-size:14px;margin-top:10px;opacity:0.8;';
            
            wrapper.appendChild(playBtn);
            wrapper.appendChild(label);
            
            wrapper.onclick = (e) => {
                e.stopPropagation();
                window.open(watchUrl, '_blank');
            };
            
            container.innerHTML = '';
            container.appendChild(wrapper);
        }

        function deleteMediaEmbed(embed) {
            if (confirm('Delete this media?')) {
                embed.remove();
                markUnsaved();
            }
        }

        function makeMediaEmbedDraggable(embed) {
            let isDragging = false;
            let startX, startY, initialX, initialY;

            embed.addEventListener('mousedown', (e) => {
                // Only allow dragging/selecting when select tool is active
                if (state.tool !== 'select') return;
                // Don't drag if clicking on controls, resize handle, or iframe
                if (e.target.closest('.media-embed-controls') ||
                    e.target.closest('.media-embed-resize') ||
                    e.target.closest('.media-embed-content iframe')) return;

                e.preventDefault();
                
                // Select this embed immediately on mousedown
                document.querySelectorAll('.media-embed.selected, .text-box.selected').forEach(el => {
                    el.classList.remove('selected');
                });
                embed.classList.add('selected');

                isDragging = false;
                startX = e.clientX;
                startY = e.clientY;
                initialX = parseInt(embed.style.left) || 0;
                initialY = parseInt(embed.style.top) || 0;

                // Find text boxes that intersect this embed at drag start
                const embedW = parseInt(embed.style.width) || embed.offsetWidth;
                const embedH = parseInt(embed.style.height) || embed.offsetHeight;
                const embedLeft = initialX;
                const embedTop = initialY;

                const candidateTextBoxes = Array.from(textLayer.querySelectorAll('.text-box'));
                const linkedTextBoxes = [];
                candidateTextBoxes.forEach(tb => {
                    const tbLeft = parseInt(tb.style.left) || 0;
                    const tbTop = parseInt(tb.style.top) || 0;
                    const tbW = parseInt(tb.style.width) || tb.offsetWidth;
                    const tbH = parseInt(tb.style.height) || tb.offsetHeight;
                    const intersects = !(tbLeft > embedLeft + embedW || tbLeft + tbW < embedLeft || tbTop > embedTop + embedH || tbTop + tbH < embedTop);
                    if (intersects) {
                        linkedTextBoxes.push({ el: tb, left: tbLeft, top: tbTop });
                    }
                });

                // Prepare for shifting drawing layer visually during drag
                let drawingShiftX = 0;
                let drawingShiftY = 0;
                const originalDrawingLeft = drawingCanvas.style.left || '';
                const originalDrawingTop = drawingCanvas.style.top || '';

                const onMouseMove = (e) => {
                    const dx = (e.clientX - startX) / state.zoom;
                    const dy = (e.clientY - startY) / state.zoom;

                    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                        isDragging = true;
                        embed.classList.add('dragging');
                    }

                    if (isDragging) {
                        // Move embed
                        embed.style.left = (initialX + dx) + 'px';
                        embed.style.top = (initialY + dy) + 'px';

                        // Move linked text boxes along with the embed
                        linkedTextBoxes.forEach(info => {
                            info.el.style.left = (info.left + dx) + 'px';
                            info.el.style.top = (info.top + dy) + 'px';
                        });

                        // Visually shift the drawing canvas during drag for immediate feedback
                        drawingShiftX = dx;
                        drawingShiftY = dy;
                        drawingCanvas.style.left = drawingShiftX + 'px';
                        drawingCanvas.style.top = drawingShiftY + 'px';
                    }
                };

                const onMouseUp = (ev) => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);

                    if (isDragging) {
                        // Before committing drawing move, save undo snapshot
                        saveToUndoStack();

                        // Commit drawing shift into canvas pixels
                        if ((drawingShiftX !== 0 || drawingShiftY !== 0)) {
                            try {
                                const tmp = document.createElement('canvas');
                                tmp.width = drawingCanvas.width;
                                tmp.height = drawingCanvas.height;
                                const tmpCtx = tmp.getContext('2d');
                                // drawImage needs numeric offsets in canvas pixels
                                tmpCtx.drawImage(drawingCanvas, 0, 0);

                                // Clear and redraw shifted image onto the real canvas
                                drawCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                                drawCtx.drawImage(tmp, drawingShiftX, drawingShiftY);
                            } catch (err) {
                                console.error('Error committing drawing shift:', err);
                            }
                        }

                        // Reset any temporary drawing offsets
                        drawingCanvas.style.left = originalDrawingLeft;
                        drawingCanvas.style.top = originalDrawingTop;

                        markUnsaved();
                        setTimeout(() => embed.classList.remove('dragging'), 100);
                    }
                };

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        function makeMediaEmbedResizable(embed, handle) {
            handle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                const startX = e.clientX;
                const startY = e.clientY;
                const startWidth = embed.offsetWidth;
                const startHeight = embed.offsetHeight;
                
                // Check if this is an image or video (lock aspect ratio for these)
                const embedType = embed.getAttribute('data-embed-type');
                const lockRatio = (embedType === 'image' || embedType === 'video');
                
                // Get actual aspect ratio from the media element
                let aspectRatio = startWidth / startHeight;
                if (lockRatio) {
                    const img = embed.querySelector('img');
                    const video = embed.querySelector('video');
                    if (img && img.naturalWidth && img.naturalHeight) {
                        aspectRatio = img.naturalWidth / img.naturalHeight;
                    } else if (video && video.videoWidth && video.videoHeight) {
                        aspectRatio = video.videoWidth / video.videoHeight;
                    }
                }
                
                const onMouseMove = (e) => {
                    // Calculate diagonal distance from start point
                    const dx = (e.clientX - startX) / state.zoom;
                    const dy = (e.clientY - startY) / state.zoom;
                    
                    let newWidth, newHeight;
                    
                    if (lockRatio) {
                        // Use diagonal movement for proportional resize
                        const diagonalDelta = (dx + dy) / 2;
                        newWidth = Math.max(100, startWidth + diagonalDelta);
                        newHeight = newWidth / aspectRatio;
                        
                        // Ensure minimum height
                        if (newHeight < 80) {
                            newHeight = 80;
                            newWidth = newHeight * aspectRatio;
                        }
                    } else {
                        newWidth = Math.max(100, startWidth + dx);
                        newHeight = Math.max(80, startHeight + dy);
                    }
                    
                    embed.style.width = newWidth + 'px';
                    embed.style.height = newHeight + 'px';
                };
                
                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    markUnsaved();
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        function addMediaEmbedSelectHandler(embed) {
            // Selection is now handled in makeMediaEmbedDraggable's mousedown handler
            // This function is kept for backwards compatibility but does nothing
            // The draggable handler selects on mousedown to ensure it works even with preventDefault
        }

        // Handle paste event for media URLs
        function handlePaste(e) {
            // Don't intercept paste if typing in a text box
            if (document.activeElement.classList.contains('text-box') || 
                document.activeElement.tagName === 'INPUT' ||
                document.activeElement.tagName === 'TEXTAREA') {
                return;
            }
            
            // Only handle paste in editor view
            if (state.currentView !== 'editor' || !state.currentNote) return;
            
            const clipboardData = e.clipboardData || window.clipboardData;
            
            // Check for image data first
            const items = clipboardData.items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    e.preventDefault();
                    const blob = items[i].getAsFile();
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        createMediaEmbed(event.target.result, 'image');
                    };
                    reader.readAsDataURL(blob);
                    return;
                }
            }
            
            // Check for text (URL)
            const text = clipboardData.getData('text').trim();
            if (text) {
                const mediaType = detectMediaType(text);
                if (mediaType) {
                    // Prevent double embedding for Evernote links
                    if (mediaType === 'evernote-link') {
                        e.preventDefault();
                        createMediaEmbed(text, 'evernote-link');
                    } else {
                        e.preventDefault();
                        createMediaEmbed(text, mediaType);
                    }
                }
            }
        }

        // Add paste event listener
        document.addEventListener('paste', handlePaste);

        // Toggle media dropdown
        function toggleMediaDropdown(e) {
            e.stopPropagation();
            const dropdown = document.getElementById('media-dropdown');
            dropdown.classList.toggle('show');
        }

        // Close media dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('media-dropdown');
            if (dropdown && !e.target.closest('.media-dropdown')) {
                dropdown.classList.remove('show');
            }
        });

        // Show link embed dialog
        function showLinkEmbedDialog() {
            if (state.currentView !== 'editor' || !state.currentNote) {
                alert('Please open a note first to add media');
                return;
            }
            document.getElementById('media-dropdown')?.classList.remove('show');
            const modal = document.getElementById('link-embed-modal');
            const title = document.getElementById('link-embed-title');
            const input = document.getElementById('link-embed-input');
            
            title.textContent = 'Embed Media Link';
            input.placeholder = 'Paste YouTube, Vimeo, Evernote, or media URL...';
            modal.classList.add('show');
            input.value = '';
            input.focus();
        }
        
        // Show YouTube-specific dialog
        function showYouTubeDialog() {
            if (state.currentView !== 'editor' || !state.currentNote) {
                alert('Please open a note first to embed a video');
                return;
            }
            document.getElementById('media-dropdown')?.classList.remove('show');
            const modal = document.getElementById('link-embed-modal');
            const title = document.getElementById('link-embed-title');
            const input = document.getElementById('link-embed-input');
            
            title.textContent = ' Embed YouTube Video';
            input.placeholder = 'Paste YouTube URL (e.g., https://youtube.com/watch?v=...)';
            modal.classList.add('show');
            input.value = '';
            input.focus();
        }

        // Close link embed dialog
        function closeLinkEmbedDialog() {
            document.getElementById('link-embed-modal').classList.remove('show');
        }

        // Embed link from dialog
        function embedLinkFromDialog() {
            const input = document.getElementById('link-embed-input');
            const url = input.value.trim();
            
            if (!url) {
                alert('Please enter a URL');
                return;
            }
            
            const type = detectMediaType(url);
            if (!type) {
                alert('Could not detect media type. Please enter a valid image, video, audio, or Evernote link URL.');
                return;
            }
            
            createMediaEmbed(url, type, {
                left: '1800px',
                top: '1800px'
            });
            
            closeLinkEmbedDialog();
        }

        // Handle Enter key in link embed dialog
        document.addEventListener('keydown', (e) => {
            const modal = document.getElementById('link-embed-modal');
            if (modal && modal.classList.contains('show')) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    embedLinkFromDialog();
                } else if (e.key === 'Escape') {
                    closeLinkEmbedDialog();
                }
            }
        });

        // Close modal when clicking backdrop
        document.getElementById('link-embed-modal')?.addEventListener('click', (e) => {
            if (e.target.classList.contains('link-embed-modal')) {
                closeLinkEmbedDialog();
            }
        });

        // Trigger file upload dialog
        function triggerMediaUpload() {
            if (state.currentView !== 'editor' || !state.currentNote) {
                alert('Please open a note first to add media');
                return;
            }
            document.getElementById('media-dropdown').classList.remove('show');
            document.getElementById('media-upload').click();
        }

        // Handle file upload from file input
        function handleFileUpload(e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;
            
            Array.from(files).forEach((file, index) => {
                embedLocalFile(file, index);
            });
            
            // Reset file input so same file can be selected again
            e.target.value = '';
        }

        // Embed a local file
        function embedLocalFile(file, offsetIndex = 0) {
            const reader = new FileReader();
            
            reader.onload = (event) => {
                const dataUrl = event.target.result;
                let type = 'image';
                
                if (file.type.startsWith('video/')) {
                    type = 'video';
                } else if (file.type.startsWith('audio/')) {
                    type = 'audio';
                } else if (file.type.startsWith('image/')) {
                    type = 'image';
                } else if (file.type === 'application/pdf') {
                    type = 'pdf';
                }
                
                // Offset each file slightly so they don't stack exactly on top of each other
                const options = {
                    left: (1800 + offsetIndex * 30) + 'px',
                    top: (1800 + offsetIndex * 30) + 'px'
                };
                
                createMediaEmbed(dataUrl, type, options);
            };
            
            reader.onerror = () => {
                alert('Failed to load file: ' + file.name);
            };
            
            reader.readAsDataURL(file);
        }

        // Handle drag and drop of files onto canvas
        function setupDragAndDrop() {
            const canvasContainer = document.getElementById('canvas-container');
            
            canvasContainer.addEventListener('dragover', (e) => {
                if (state.currentView !== 'editor' || !state.currentNote) return;
                e.preventDefault();
                e.stopPropagation();
                canvasContainer.classList.add('drag-over');
            });
            
            canvasContainer.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                canvasContainer.classList.remove('drag-over');
            });
            
            canvasContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                canvasContainer.classList.remove('drag-over');
                
                if (state.currentView !== 'editor' || !state.currentNote) return;
                
                const files = e.dataTransfer.files;
                if (files && files.length > 0) {
                    Array.from(files).forEach((file, index) => {
                        // Check if it's an acceptable file type
                        if (file.type.startsWith('image/') || file.type.startsWith('video/') || file.type.startsWith('audio/')) {
                            embedLocalFile(file, index);
                        }
                    });
                }
                
                // Also check for dropped URLs (text/uri-list or text/plain)
                const url = e.dataTransfer.getData('text/uri-list') || e.dataTransfer.getData('text/plain');
                if (url && !files.length) {
                    const mediaType = detectMediaType(url);
                    if (mediaType) {
                        createMediaEmbed(url, mediaType);
                    }
                }
            });
        }

        // Initialize drag and drop
        setupDragAndDrop();

        // ==================== END MEDIA EMBED FUNCTIONS ====================

        function updateBreadcrumb(notebook, note) {
            const path = getNotePath(notebook, note.id);
            let breadcrumb = `<span class="breadcrumb-item" onclick="showHomePage()">Home</span>`;
            breadcrumb += `<span class="breadcrumb-separator"> / </span>`;
            breadcrumb += `<span class="breadcrumb-item" onclick="toggleNotebook(state.notebooks.find(n => n.id === '${notebook.id}'))">${notebook.name}</span>`;
            
            path.forEach((pathNote, index) => {
                breadcrumb += `<span class="breadcrumb-separator"> / </span>`;
                if (index === path.length - 1) {
                    breadcrumb += `<span class="breadcrumb-current">${pathNote.name}</span>`;
                } else {
                    breadcrumb += `<span class="breadcrumb-item" onclick="selectNoteById('${notebook.id}', '${pathNote.id}')">${pathNote.name}</span>`;
                }
            });
            
            document.getElementById('note-info').innerHTML = breadcrumb;
        }

        function deleteNote(notebook, note, e) {
            e.stopPropagation();
            if (confirm(`Delete "${note.name}"?`)) {
                const index = notebook.notes.indexOf(note);
                notebook.notes.splice(index, 1);
                
                // Remove from pinned if pinned
                const pinnedIndex = state.pinnedNotes.findIndex(p => p.notebookId === notebook.id && p.noteId === note.id);
                if (pinnedIndex > -1) {
                    state.pinnedNotes.splice(pinnedIndex, 1);
                    savePinnedToStorage();
                }
                
                if (state.currentNote === note) {
                    state.currentNote = null;
                    showHomePage();
                }
                
                renderNotebooks();
                renderHomePage();
                saveToStorage();
            }
        }

        function deleteNotebook(notebook, e) {
            e.stopPropagation();
            if (confirm(`Delete notebook "${notebook.name}" and all its notes?`)) {
                const index = state.notebooks.indexOf(notebook);
                state.notebooks.splice(index, 1);
                
                // Remove all pinned notes from this notebook
                state.pinnedNotes = state.pinnedNotes.filter(p => p.notebookId !== notebook.id);
                savePinnedToStorage();
                
                if (state.currentNotebook === notebook) {
                    state.currentNotebook = null;
                    state.currentNote = null;
                    showHomePage();
                }
                
                renderNotebooks();
                renderHomePage();
                saveToStorage();
            }
        }

        function toggleNotebook(notebook) {
            notebook.isOpen = !notebook.isOpen;
            renderNotebooks();
        }

        function toggleNoteChildren(notebookId, noteId, e) {
            e.stopPropagation();
            const notebook = window.findNotebookById(notebookId);
            if (!notebook) return;
            const note = findNoteById(notebook, noteId);
            if (note) {
                note.isOpen = !note.isOpen;
                renderNotebooks();
                saveToStorage();
            }
        }

        // Get status label for badge
        function getStatusLabel(status, short = false) {
            if (short) {
                switch(status) {
                    case 'in-progress': return '';
                    case 'finished': return '';
                    case 'needs-review': return '';
                    default: return '';
                }
            }
            switch(status) {
                case 'in-progress': return 'In Progress';
                case 'finished': return 'Done';
                case 'needs-review': return 'Review';
                default: return '';
            }
        }

        // Update note status from toolbar
        function updateNoteStatus() {
            if (!state.currentNote) return;
            
            const statusSelect = document.getElementById('status-select');
            const newStatus = statusSelect.value;
            
            state.currentNote.status = newStatus;
            renderNotebooks();
            renderHomePage();
            saveToStorage();
            markUnsaved();
        }

        // Render a single note item with its children recursively
        function renderNoteItem(notebook, note, notebookIndex, depth = 0) {
            const isPinned = isNotePinned(notebook.id, note.id);
            const hasChildren = note.children && note.children.length > 0;
            const isActive = state.currentNote && state.currentNote.id === note.id;
            const statusBadge = note.status && note.status !== 'none' ? `<div class="note-item-status-row"><span class="status-badge ${note.status}">${getStatusLabel(note.status)}</span></div>` : '';
            
            let html = `
                <div class="note-item-container" 
                    data-note-id="${note.id}" 
                    data-notebook-id="${notebook.id}"
                    draggable="true">
                    <div class="note-item ${isActive ? 'active' : ''}" onclick="selectNoteById('${notebook.id}', '${note.id}')">
                        <div class="note-item-header">
                            <span>
                                <span class="note-toggle ${hasChildren ? (note.isOpen ? 'open' : '') : 'hidden'}" onclick="toggleNoteChildren('${notebook.id}', '${note.id}', event)"></span>
                                ${note.name}
                            </span>
                            <div>
                                <button class="add-subnote-btn" onclick="createSubNote('${notebook.id}', '${note.id}', event)" title="Add sub-note">+</button>
                                <button class="pin-btn ${isPinned ? 'pinned' : ''}" onclick="togglePin(event, '${notebook.id}', '${note.id}')" title="${isPinned ? 'Unpin' : 'Pin'}">${isPinned ? '' : ''}</button>
                                <button class="delete-btn" onclick="deleteNoteById('${notebook.id}', '${note.id}', event)"></button>
                            </div>
                        </div>
                        ${statusBadge}
                    </div>
            `;
            
            if (hasChildren) {
                html += `<div class="sub-notes-list ${note.isOpen ? 'open' : ''}">`;
                note.children.forEach(childNote => {
                    html += renderNoteItem(notebook, childNote, notebookIndex, depth + 1);
                });
                html += `</div>`;
            }
            
            html += `</div>`;
            return html;
        }

        // Notebook sorting functions
        function setNotebookSort(sortMode) {
            state.notebookSort = sortMode;
            renderNotebooks();
            renderHomePage();
            saveToStorage();
        }

        function setSubNotebookSort(sortMode) {
            state.subNotebookSort = sortMode;
            if (state.viewingNotebook) {
                showNotebookDetailPage(state.viewingNotebook);
            }
            saveToStorage();
        }

        function setNotesSort(sortMode) {
            state.notesSort = sortMode;
            if (state.viewingNotebook) {
                showNotebookDetailPage(state.viewingNotebook);
            }
            saveToStorage();
        }

        function toggleNotebookPin(notebookId) {
            if (!state.pinnedNotebooks) state.pinnedNotebooks = [];
            const index = state.pinnedNotebooks.indexOf(notebookId);
            if (index > -1) {
                state.pinnedNotebooks.splice(index, 1);
            } else {
                state.pinnedNotebooks.push(notebookId);
            }
            renderNotebooks();
            saveToStorage();
        }

        function getSortedNotebooks(notebooks) {
            if (!notebooks || notebooks.length === 0) return [];
            
            // Create a copy to avoid mutating original
            const sorted = [...notebooks];
            
            switch (state.notebookSort) {
                case 'pinned':
                    // Pinned first, then by creation date (most recent first)
                    sorted.sort((a, b) => {
                        const aPinned = state.pinnedNotebooks && state.pinnedNotebooks.includes(a.id);
                        const bPinned = state.pinnedNotebooks && state.pinnedNotebooks.includes(b.id);
                        if (aPinned && !bPinned) return -1;
                        if (!aPinned && bPinned) return 1;
                        // Both pinned or both unpinned - sort by ID (timestamp) descending
                        return parseInt(b.id) - parseInt(a.id);
                    });
                    break;
                case 'alphabetical':
                    sorted.sort((a, b) => a.name.localeCompare(b.name));
                    break;
                case 'recent':
                    // Sort by ID (which is timestamp) descending
                    sorted.sort((a, b) => parseInt(b.id) - parseInt(a.id));
                    break;
                case 'custom':
                    // Use custom order if available, otherwise keep original order
                    if (state.notebookCustomOrder && state.notebookCustomOrder.length > 0) {
                        sorted.sort((a, b) => {
                            const aIndex = state.notebookCustomOrder.indexOf(a.id);
                            const bIndex = state.notebookCustomOrder.indexOf(b.id);
                            // Items not in custom order go to the end
                            if (aIndex === -1 && bIndex === -1) return 0;
                            if (aIndex === -1) return 1;
                            if (bIndex === -1) return -1;
                            return aIndex - bIndex;
                        });
                    }
                    break;
            }
            
            return sorted;
        }

        // Sort sub-notebooks within a parent notebook
        function getSortedSubNotebooks(subNotebooks, parentNotebookId) {
            if (!subNotebooks || subNotebooks.length === 0) return [];
            
            const sorted = [...subNotebooks];
            const customOrderKey = `subnotebook_order_${parentNotebookId}`;
            const customOrder = state[customOrderKey] || [];
            
            switch (state.subNotebookSort) {
                case 'alphabetical':
                    sorted.sort((a, b) => a.name.localeCompare(b.name));
                    break;
                case 'recent':
                    sorted.sort((a, b) => parseInt(b.id) - parseInt(a.id));
                    break;
                case 'custom':
                    if (customOrder.length > 0) {
                        sorted.sort((a, b) => {
                            const aIndex = customOrder.indexOf(a.id);
                            const bIndex = customOrder.indexOf(b.id);
                            if (aIndex === -1 && bIndex === -1) return 0;
                            if (aIndex === -1) return 1;
                            if (bIndex === -1) return -1;
                            return aIndex - bIndex;
                        });
                    }
                    break;
            }
            
            return sorted;
        }

        // Sort notes within a notebook
        function getSortedNotes(notes, notebookId) {
            if (!notes || notes.length === 0) return [];
            
            const sorted = [...notes];
            const customOrderKey = `notes_order_${notebookId}`;
            const customOrder = state[customOrderKey] || [];
            
            switch (state.notesSort) {
                case 'alphabetical':
                    sorted.sort((a, b) => a.name.localeCompare(b.name));
                    break;
                case 'recent':
                    sorted.sort((a, b) => parseInt(b.id) - parseInt(a.id));
                    break;
                case 'custom':
                    if (customOrder.length > 0) {
                        sorted.sort((a, b) => {
                            const aIndex = customOrder.indexOf(a.id);
                            const bIndex = customOrder.indexOf(b.id);
                            if (aIndex === -1 && bIndex === -1) return 0;
                            if (aIndex === -1) return 1;
                            if (bIndex === -1) return -1;
                            return aIndex - bIndex;
                        });
                    }
                    break;
            }
            
            return sorted;
        }

        // Custom drag and drop for notebook reordering
        let draggedNotebookId = null;

        function handleNotebookDragStart(e, notebookId) {
            draggedNotebookId = notebookId;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', notebookId);
            if (state.notebookSort === 'custom') {
                showDragHint('Drag to reorder or drop items here');
            } else {
                showDragHint('Drop items on notebooks to move them');
            }
        }

        function handleNotebookDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedNotebookId = null;
            // Remove drag-over class from all elements
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        }

        function handleNotebookDragOver(e) {
            if (state.notebookSort !== 'custom' || !draggedNotebookId) return;
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const target = e.target.closest('.notebook-card, .notebook');
            if (target && !target.classList.contains('dragging')) {
                document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                target.classList.add('drag-over');
            }
        }

        function handleNotebookDragLeave(e) {
            const target = e.target.closest('.notebook-card, .notebook');
            if (target) {
                target.classList.remove('drag-over');
            }
        }

        function handleNotebookDrop(e, targetNotebookId) {
            e.preventDefault();
            console.log('handleNotebookDrop called on:', targetNotebookId);
            console.log('draggedSubNotebookId:', draggedSubNotebookId);
            console.log('draggedNoteData:', draggedNoteData);
            
            // Check if we're dropping a sub-notebook or note INTO this notebook
            if (draggedSubNotebookId && targetNotebookId !== draggedSubNotebookId) {
                console.log('Moving sub-notebook to notebook');
                moveSubNotebookToNotebook(draggedSubNotebookId, targetNotebookId);
                clearAllDragStates();
                return;
            }
            
            if (draggedNoteData && targetNotebookId) {
                console.log('Moving note to notebook');
                moveNoteToNotebook(draggedNoteData.noteId, draggedNoteData.sourceNotebookId, targetNotebookId);
                clearAllDragStates();
                return;
            }
            
            // Original reordering logic for custom sort
            if (state.notebookSort !== 'custom' || !draggedNotebookId || draggedNotebookId === targetNotebookId) {
                document.querySelectorAll('.drag-over, .drop-target').forEach(el => {
                    el.classList.remove('drag-over');
                    el.classList.remove('drop-target');
                });
                return;
            }

            // Initialize custom order if needed
            if (!state.notebookCustomOrder || state.notebookCustomOrder.length === 0) {
                state.notebookCustomOrder = state.notebooks.map(nb => nb.id);
            }

            // Remove dragged item from current position
            const draggedIndex = state.notebookCustomOrder.indexOf(draggedNotebookId);
            if (draggedIndex > -1) {
                state.notebookCustomOrder.splice(draggedIndex, 1);
            }

            // Insert at new position (before target)
            const targetIndex = state.notebookCustomOrder.indexOf(targetNotebookId);
            if (targetIndex > -1) {
                state.notebookCustomOrder.splice(targetIndex, 0, draggedNotebookId);
            } else {
                state.notebookCustomOrder.push(draggedNotebookId);
            }

            clearAllDragStates();
            draggedNotebookId = null;

            renderNotebooks();
            renderHomePage();
            saveToStorage();
        }

        // ===== Undo System for Drag Operations =====
        // undoStack already declared earlier, reusing it
        const MAX_UNDO_DRAG = 20;

        function saveUndoState(action) {
            undoStack.push({
                action: action,
                notebooks: JSON.parse(JSON.stringify(state.notebooks)),
                pinnedNotes: JSON.parse(JSON.stringify(state.pinnedNotes || [])),
                timestamp: Date.now()
            });
            if (undoStack.length > MAX_UNDO_DRAG) {
                undoStack.shift();
            }
        }

        function undoDragAction() {
            if (undoStack.length === 0) {
                showLayerToast('Nothing to undo');
                return;
            }
            const lastState = undoStack.pop();
            state.notebooks = lastState.notebooks;
            state.pinnedNotes = lastState.pinnedNotes;
            renderNotebooks();
            renderHomePage();
            if (state.viewingNotebook) {
                state.viewingNotebook = window.findNotebookById(state.viewingNotebook.id);
                if (state.viewingNotebook) {
                    showNotebookDetailPage(state.viewingNotebook);
                }
            }
            saveToStorage();
            showLayerToast('Undid: ' + lastState.action);
        }

        // Ctrl+Z handler for undo drag operations
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                // Only undo drag operations when not in a text input
                const activeEl = document.activeElement;
                const isTextInput = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable);
                if (!isTextInput) {
                    e.preventDefault();
                    undoDragAction();
                }
            }
        });

        // ===== Drag and Drop for Sub-Notebooks and Notes =====
        let draggedSubNotebookId = null;
        let draggedSubNotebookParentId = null;
        let draggedNoteData = null; // {noteId, sourceNotebookId}
        let dragHintEl = null;
        let dropIndicator = null; // Visual indicator for insert position
        let dropPosition = null; // 'before', 'after', or 'into'

        // Create drop indicator element
        function getDropIndicator() {
            if (!dropIndicator) {
                dropIndicator = document.createElement('div');
                dropIndicator.className = 'drop-indicator';
                dropIndicator.style.cssText = 'position:absolute;left:0;right:0;height:3px;background:#007aff;border-radius:2px;pointer-events:none;z-index:1000;display:none;';
            }
            return dropIndicator;
        }

        // Global drag event delegation
        document.addEventListener('dragstart', function(e) {
            // Prevent dragging if clicking on a button
            if (e.target.closest('button')) {
                e.preventDefault();
                return;
            }
            
            e.stopPropagation();
            
            // Find the draggable item
            const noteContainer = e.target.closest('.note-item-container[data-note-id]');
            const subnotebookEl = e.target.closest('[data-subnotebook-id]');
            const notebookCard = e.target.closest('.notebook-card[data-notebook-id]');
            const pinnedCard = e.target.closest('.pinned-card[data-note-id]');
            
            if (noteContainer) {
                // Dragging a note from sidebar
                const noteId = noteContainer.dataset.noteId;
                const notebookId = noteContainer.dataset.notebookId;
                console.log('Dragging NOTE from sidebar:', noteId);
                saveUndoState('Move note');
                draggedNoteData = { noteId, sourceNotebookId: notebookId };
                noteContainer.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', 'note:' + noteId);
                showDragHint('Drop on notebook or between items');
            } else if (pinnedCard) {
                // Dragging a pinned note
                const noteId = pinnedCard.dataset.noteId;
                const notebookId = pinnedCard.dataset.notebookId;
                console.log('Dragging PINNED NOTE:', noteId);
                saveUndoState('Move note');
                draggedNoteData = { noteId, sourceNotebookId: notebookId };
                pinnedCard.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', 'note:' + noteId);
                showDragHint('Drop on notebook or between items');
            } else if (subnotebookEl && !notebookCard) {
                // Dragging a sub-notebook from sidebar
                const subId = subnotebookEl.dataset.subnotebookId;
                const parentId = subnotebookEl.dataset.parentId;
                console.log('Dragging SUB-NOTEBOOK:', subId);
                saveUndoState('Move sub-notebook');
                draggedSubNotebookId = subId;
                draggedSubNotebookParentId = parentId;
                subnotebookEl.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', 'subnotebook:' + subId);
                showDragHint('Drop on notebook or between items');
            } else if (notebookCard && notebookCard.dataset.subnotebookId) {
                // Dragging a sub-notebook card from detail page
                const subId = notebookCard.dataset.subnotebookId;
                const parentId = notebookCard.dataset.parentId;
                console.log('Dragging SUB-NOTEBOOK CARD:', subId);
                saveUndoState('Move sub-notebook');
                draggedSubNotebookId = subId;
                draggedSubNotebookParentId = parentId;
                notebookCard.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', 'subnotebook:' + subId);
                showDragHint('Drop on notebook or between items');
            }
        }, true);

        document.addEventListener('dragend', function(e) {
            clearAllDragStates();
            draggedSubNotebookId = null;
            draggedSubNotebookParentId = null;
            draggedNoteData = null;
            dropPosition = null;
            hideDropIndicator();
        });

        // Show drop indicator between items
        function showDropIndicator(element, position) {
            const indicator = getDropIndicator();
            const rect = element.getBoundingClientRect();
            indicator.style.display = 'block';
            
            if (position === 'before') {
                indicator.style.top = (rect.top + window.scrollY - 2) + 'px';
            } else {
                indicator.style.top = (rect.bottom + window.scrollY - 1) + 'px';
            }
            indicator.style.left = rect.left + 'px';
            indicator.style.width = rect.width + 'px';
            document.body.appendChild(indicator);
        }

        function hideDropIndicator() {
            if (dropIndicator) {
                dropIndicator.style.display = 'none';
            }
        }

        // Handle dragover to show insertion point
        document.addEventListener('dragover', function(e) {
            if (!draggedNoteData && !draggedSubNotebookId) return;
            
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            // Find what we're hovering over
            const noteContainer = e.target.closest('.note-item-container[data-note-id]');
            const notebookEl = e.target.closest('.notebook[data-notebook-id]');
            const notebookCard = e.target.closest('.notebook-card[data-notebook-id]');
            
            // Clear previous highlights
            document.querySelectorAll('.drop-target, .drop-before, .drop-after, .drop-into').forEach(el => {
                el.classList.remove('drop-target', 'drop-before', 'drop-after', 'drop-into');
            });
            
            if (noteContainer && draggedNoteData) {
                // Hovering over a note - show insert position based on vertical position
                const rect = noteContainer.getBoundingClientRect();
                const thirdHeight = rect.height / 3;
                const relativeY = e.clientY - rect.top;
                
                if (relativeY < thirdHeight) {
                    // Top third - insert before
                    dropPosition = 'before';
                    noteContainer.classList.add('drop-before');
                    showDropIndicator(noteContainer, 'before');
                } else if (relativeY > thirdHeight * 2) {
                    // Bottom third - insert after
                    dropPosition = 'after';
                    noteContainer.classList.add('drop-after');
                    showDropIndicator(noteContainer, 'after');
                } else {
                    // Middle third - drop INTO as sub-note
                    dropPosition = 'into';
                    noteContainer.classList.add('drop-into');
                    hideDropIndicator();
                }
            } else if (notebookEl) {
                // Hovering over a notebook - drop into
                dropPosition = 'into';
                notebookEl.classList.add('drop-target');
                hideDropIndicator();
            } else if (notebookCard) {
                // Hovering over a notebook card - drop into
                dropPosition = 'into';
                notebookCard.classList.add('drop-target');
                hideDropIndicator();
            } else {
                hideDropIndicator();
            }
        });

        document.addEventListener('dragleave', function(e) {
            const relatedTarget = e.relatedTarget;
            if (!relatedTarget || !e.currentTarget.contains(relatedTarget)) {
                // Left the document
            }
        });

        // Handle drop
        document.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Immediately hide the drop indicator
            hideDropIndicator();
            
            if (!draggedNoteData && !draggedSubNotebookId) {
                clearAllDragStates();
                return;
            }
            
            const noteContainer = e.target.closest('.note-item-container[data-note-id]');
            const notebookEl = e.target.closest('.notebook[data-notebook-id]');
            const notebookCard = e.target.closest('.notebook-card[data-notebook-id]');
            
            if (noteContainer && draggedNoteData && dropPosition) {
                const targetNoteId = noteContainer.dataset.noteId;
                const targetNotebookId = noteContainer.dataset.notebookId;
                
                if (dropPosition === 'into') {
                    // Drop INTO the note as a sub-note
                    makeNoteSubnote(draggedNoteData.noteId, draggedNoteData.sourceNotebookId, targetNoteId, targetNotebookId);
                } else {
                    // Drop before or after the note
                    insertNoteRelativeTo(draggedNoteData.noteId, draggedNoteData.sourceNotebookId, targetNoteId, targetNotebookId, dropPosition);
                }
            } else if (notebookEl && notebookEl.dataset.notebookId) {
                // Dropping into a notebook
                const targetNotebookId = notebookEl.dataset.notebookId;
                if (draggedNoteData) {
                    moveNoteToNotebook(draggedNoteData.noteId, draggedNoteData.sourceNotebookId, targetNotebookId);
                } else if (draggedSubNotebookId) {
                    moveSubNotebookToNotebook(draggedSubNotebookId, targetNotebookId);
                }
            } else if (notebookCard && notebookCard.dataset.notebookId) {
                // Dropping into a notebook card
                const targetNotebookId = notebookCard.dataset.notebookId;
                if (draggedNoteData) {
                    moveNoteToNotebook(draggedNoteData.noteId, draggedNoteData.sourceNotebookId, targetNotebookId);
                } else if (draggedSubNotebookId) {
                    moveSubNotebookToNotebook(draggedSubNotebookId, targetNotebookId);
                }
            }
            
            // Clean up all drag states
            clearAllDragStates();
            draggedNoteData = null;
            draggedSubNotebookId = null;
            draggedSubNotebookParentId = null;
            dropPosition = null;
        });

        // Make a note become a sub-note of another note
        function makeNoteSubnote(noteId, sourceNotebookId, targetNoteId, targetNotebookId) {
            if (noteId === targetNoteId) return;
            
            // Helper to find a note in ALL notebooks
            function findNoteInAllNotebooks(searchNoteId) {
                function searchInNotebook(notebook) {
                    function searchNotes(notes) {
                        for (const note of notes) {
                            if (String(note.id) === String(searchNoteId)) return { note, notebook };
                            if (note.children) {
                                const found = searchNotes(note.children);
                                if (found) return found;
                            }
                        }
                        return null;
                    }
                    return searchNotes(notebook.notes || []);
                }
                
                function searchAllNotebooks(notebooks) {
                    for (const nb of notebooks) {
                        const found = searchInNotebook(nb);
                        if (found) return found;
                        if (nb.children) {
                            const childFound = searchAllNotebooks(nb.children);
                            if (childFound) return childFound;
                        }
                    }
                    return null;
                }
                
                return searchAllNotebooks(state.notebooks);
            }
            
            // Find target note
            const targetResult = findNoteInAllNotebooks(targetNoteId);
            if (!targetResult) {
                console.error('Target note not found:', targetNoteId);
                showLayerToast('Error: Target note not found');
                return;
            }
            const targetNote = targetResult.note;
            
            // Find and remove source note from wherever it actually is
            const sourceResult = findNoteInAllNotebooks(noteId);
            if (!sourceResult) {
                console.error('Source note not found:', noteId);
                showLayerToast('Error: Source note not found');
                return;
            }
            
            // Remove from actual source notebook
            const note = removeNoteFromNotebook(noteId, sourceResult.notebook);
            if (!note) {
                console.error('Could not remove note from source');
                showLayerToast('Error: Could not move note');
                return;
            }
            
            // Add as child of target note
            if (!targetNote.children) targetNote.children = [];
            targetNote.children.push(note);
            
            // Make sure target note is expanded so user can see the new child
            targetNote.isOpen = true;
            
            showLayerToast(`Made "${note.name}" a sub-note of "${targetNote.name}"`);
            
            renderNotebooks();
            renderHomePage();
            if (state.viewingNotebook) {
                showNotebookDetailPage(state.viewingNotebook);
            }
            saveToStorage();
            
            // Highlight the moved note in the sidebar so user can see where it went
            setTimeout(() => {
                const movedNoteEl = document.querySelector(`.sidebar-note-item[data-note-id="${note.id}"]`);
                if (movedNoteEl) {
                    movedNoteEl.classList.add('just-moved');
                    movedNoteEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    setTimeout(() => movedNoteEl.classList.remove('just-moved'), 2000);
                }
            }, 100);
        }

        // Insert note relative to another note (before or after)
        function insertNoteRelativeTo(noteId, sourceNotebookId, targetNoteId, targetNotebookId, position) {
            if (noteId === targetNoteId) return;
            
            // Helper to find a note in ALL notebooks
            function findNoteInAllNotebooks(searchNoteId) {
                function searchInNotebook(notebook) {
                    function searchNotes(notes) {
                        for (const note of notes) {
                            if (String(note.id) === String(searchNoteId)) return { note, notebook };
                            if (note.children) {
                                const found = searchNotes(note.children);
                                if (found) return found;
                            }
                        }
                        return null;
                    }
                    return searchNotes(notebook.notes || []);
                }
                
                function searchAllNotebooks(notebooks) {
                    for (const nb of notebooks) {
                        const found = searchInNotebook(nb);
                        if (found) return found;
                        if (nb.children) {
                            const childFound = searchAllNotebooks(nb.children);
                            if (childFound) return childFound;
                        }
                    }
                    return null;
                }
                
                return searchAllNotebooks(state.notebooks);
            }
            
            // Find source note in wherever it actually is
            const sourceResult = findNoteInAllNotebooks(noteId);
            if (!sourceResult) {
                console.error('Source note not found:', noteId);
                return;
            }
            
            // Remove note from its actual location
            const note = removeNoteFromNotebook(noteId, sourceResult.notebook);
            if (!note) return;
            
            // Find the target notebook - use the notebook that contains the target note
            const targetResult = findNoteInAllNotebooks(targetNoteId);
            const targetNotebook = targetResult ? targetResult.notebook : window.findNotebookById(targetNotebookId);
            if (!targetNotebook) {
                console.error('Target notebook not found');
                return;
            }
            
            // Find target note and insert relative to it
            if (!targetNotebook.notes) targetNotebook.notes = [];
            
            // Search for target note (could be nested in children)
            function findAndInsertRelativeTo(notes, parentArray) {
                for (let i = 0; i < notes.length; i++) {
                    if (String(notes[i].id) === String(targetNoteId)) {
                        const insertIndex = position === 'before' ? i : i + 1;
                        notes.splice(insertIndex, 0, note);
                        return true;
                    }
                    if (notes[i].children && notes[i].children.length > 0) {
                        if (findAndInsertRelativeTo(notes[i].children, notes[i].children)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            if (!findAndInsertRelativeTo(targetNotebook.notes, targetNotebook.notes)) {
                // If target not found, just add to end
                targetNotebook.notes.push(note);
            }
            
            showLayerToast(`Moved "${note.name}" ${position} target`);
            renderNotebooks();
            renderHomePage();
            if (state.viewingNotebook) {
                showNotebookDetailPage(state.viewingNotebook);
            }
            saveToStorage();
            
            // Highlight the moved note
            setTimeout(() => {
                const movedNoteEl = document.querySelector(`.sidebar-note-item[data-note-id="${note.id}"]`);
                if (movedNoteEl) {
                    movedNoteEl.classList.add('just-moved');
                    movedNoteEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    setTimeout(() => movedNoteEl.classList.remove('just-moved'), 2000);
                }
            }, 100);
        }

        function clearAllDragStates() {
            document.querySelectorAll('.drag-over, .drop-target, .dragging, .drop-before, .drop-after, .drop-into').forEach(el => {
                el.classList.remove('drag-over', 'drop-target', 'dragging', 'drop-before', 'drop-after', 'drop-into');
            });
            if (dragHintEl) {
                dragHintEl.remove();
                dragHintEl = null;
            }
            hideDropIndicator();
        }

        function showDragHint(text) {
            if (!dragHintEl) {
                dragHintEl = document.createElement('div');
                dragHintEl.className = 'drag-hint';
                document.body.appendChild(dragHintEl);
            }
            dragHintEl.textContent = text;
        }

        // Sub-notebook drag handlers (kept for backwards compatibility)
        function handleSubNotebookDragStart(e, subNotebookId, parentNotebookId) {
            e.stopPropagation();
            console.log('Sub-notebook drag started:', subNotebookId, 'from parent:', parentNotebookId);
            saveUndoState('Move sub-notebook');
            draggedSubNotebookId = subNotebookId;
            draggedSubNotebookParentId = parentNotebookId;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', 'subnotebook:' + subNotebookId);
            showDragHint('Drop on a notebook to move');
        }

        function handleSubNotebookDragEnd(e) {
            console.log('Sub-notebook drag ended');
            clearAllDragStates();
            draggedSubNotebookId = null;
            draggedSubNotebookParentId = null;
        }

        function handleSubNotebookDragOver(e) {
            if (!draggedSubNotebookId) return;
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const target = e.target.closest('.notebook-card');
            if (target && !target.classList.contains('dragging')) {
                document.querySelectorAll('.notebook-card.drag-over').forEach(el => el.classList.remove('drag-over'));
                target.classList.add('drag-over');
            }
        }

        function handleSubNotebookDrop(e, targetSubNotebookId, parentNotebookId) {
            e.preventDefault();
            e.stopPropagation();
            
            // If reordering within same parent and custom sort
            if (state.subNotebookSort === 'custom' && draggedSubNotebookId && draggedSubNotebookParentId === parentNotebookId) {
                reorderSubNotebook(draggedSubNotebookId, targetSubNotebookId, parentNotebookId);
                clearAllDragStates();
                return;
            }
            
            // Otherwise, move to target notebook
            if (draggedSubNotebookId && targetSubNotebookId !== draggedSubNotebookId) {
                moveSubNotebookToNotebook(draggedSubNotebookId, targetSubNotebookId);
            }
            clearAllDragStates();
        }

        function reorderSubNotebook(draggedId, targetId, parentNotebookId) {
            if (draggedId === targetId) return;
            
            const customOrderKey = `subnotebook_order_${parentNotebookId}`;
            const parentNotebook = window.findNotebookById(parentNotebookId);
            if (!parentNotebook || !parentNotebook.children) return;
            
            // Initialize custom order if needed
            if (!state[customOrderKey] || state[customOrderKey].length === 0) {
                state[customOrderKey] = parentNotebook.children.map(nb => nb.id);
            }
            
            // Remove dragged item and insert before target
            const order = state[customOrderKey];
            const draggedIndex = order.indexOf(draggedId);
            if (draggedIndex > -1) order.splice(draggedIndex, 1);
            
            const targetIndex = order.indexOf(targetId);
            if (targetIndex > -1) {
                order.splice(targetIndex, 0, draggedId);
            } else {
                order.push(draggedId);
            }
            
            showNotebookDetailPage(state.viewingNotebook);
            saveToStorage();
        }

        // Note drag handlers
        function handleNoteDragStart(e, noteId, sourceNotebookId) {
            e.stopPropagation();
            console.log('Note drag started:', noteId, 'from notebook:', sourceNotebookId);
            saveUndoState('Move note');
            draggedNoteData = { noteId, sourceNotebookId };
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', 'note:' + noteId);
            showDragHint('Drop on notebook or between items');
        }

        function handleNoteDragEnd(e) {
            console.log('Note drag ended');
            clearAllDragStates();
            draggedNoteData = null;
            dropPosition = null;
            hideDropIndicator();
        }

        function handleNoteDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const target = e.target.closest('.pinned-card');
            if (target && !target.classList.contains('dragging')) {
                document.querySelectorAll('.pinned-card.drag-over').forEach(el => el.classList.remove('drag-over'));
                target.classList.add('drag-over');
            }
        }

        function handleNoteDrop(e, targetNoteId, notebookId) {
            e.preventDefault();
            e.stopPropagation();
            
            // If reordering within same notebook and custom sort
            if (state.notesSort === 'custom' && draggedNoteData && draggedNoteData.sourceNotebookId === notebookId) {
                reorderNote(draggedNoteData.noteId, targetNoteId, notebookId);
                clearAllDragStates();
                return;
            }
            
            clearAllDragStates();
        }

        function reorderNote(draggedId, targetId, notebookId) {
            if (draggedId === targetId) return;
            
            const customOrderKey = `notes_order_${notebookId}`;
            const notebook = window.findNotebookById(notebookId);
            if (!notebook || !notebook.notes) return;
            
            // Initialize custom order if needed
            if (!state[customOrderKey] || state[customOrderKey].length === 0) {
                state[customOrderKey] = notebook.notes.map(n => n.id);
            }
            
            // Remove dragged item and insert before target
            const order = state[customOrderKey];
            const draggedIndex = order.indexOf(draggedId);
            if (draggedIndex > -1) order.splice(draggedIndex, 1);
            
            const targetIndex = order.indexOf(targetId);
            if (targetIndex > -1) {
                order.splice(targetIndex, 0, draggedId);
            } else {
                order.push(draggedId);
            }
            
            showNotebookDetailPage(state.viewingNotebook);
            saveToStorage();
        }

        // Generic drag over handler for drop targets (notebooks that can receive items)
        function handleDropTargetDragOver(e) {
            if (!draggedSubNotebookId && !draggedNoteData) return;
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const target = e.target.closest('.notebook-card, .notebook');
            if (target) {
                document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
                target.classList.add('drop-target');
            }
        }

        function handleDropTargetDragLeave(e) {
            const target = e.target.closest('.notebook-card, .notebook');
            if (target) {
                target.classList.remove('drop-target');
            }
        }

        // Move a sub-notebook to a different parent notebook
        function moveSubNotebookToNotebook(subNotebookId, targetNotebookId) {
            const subNotebook = window.findNotebookById(subNotebookId);
            const targetNotebook = window.findNotebookById(targetNotebookId);
            
            if (!subNotebook || !targetNotebook) return;
            
            // Prevent moving a notebook into itself or its descendants
            if (isDescendantNotebook(targetNotebookId, subNotebookId)) {
                showLayerToast('Cannot move a notebook into itself or its sub-notebook');
                return;
            }
            
            // Remove from current parent
            removeNotebookFromParent(subNotebookId);
            
            // Add to new parent
            if (!targetNotebook.children) targetNotebook.children = [];
            subNotebook.parentId = targetNotebookId;
            targetNotebook.children.push(subNotebook);
            
            showLayerToast(`Moved "${subNotebook.name}" to "${targetNotebook.name}"`);
            
            renderNotebooks();
            if (state.viewingNotebook) {
                showNotebookDetailPage(state.viewingNotebook);
            } else {
                renderHomePage();
            }
            saveToStorage();
        }

        // Check if potentialDescendant is a descendant of notebookId
        function isDescendantNotebook(potentialDescendantId, notebookId) {
            const notebook = window.findNotebookById(notebookId);
            if (!notebook || !notebook.children) return false;
            
            for (const child of notebook.children) {
                if (child.id === potentialDescendantId) return true;
                if (isDescendantNotebook(potentialDescendantId, child.id)) return true;
            }
            return false;
        }

        // Remove a notebook from its current parent
        function removeNotebookFromParent(notebookId) {
            const notebook = window.findNotebookById(notebookId);
            if (!notebook) return;
            
            // Check if it's a top-level notebook
            const topLevelIndex = state.notebooks.findIndex(nb => nb.id === notebookId);
            if (topLevelIndex > -1) {
                state.notebooks.splice(topLevelIndex, 1);
                return;
            }
            
            // Find and remove from parent's children
            function removeFromChildren(notebooks) {
                for (const nb of notebooks) {
                    if (nb.children) {
                        const childIndex = nb.children.findIndex(c => c.id === notebookId);
                        if (childIndex > -1) {
                            nb.children.splice(childIndex, 1);
                            return true;
                        }
                        if (removeFromChildren(nb.children)) return true;
                    }
                }
                return false;
            }
            removeFromChildren(state.notebooks);
        }

        // Move a note to a different notebook
        function moveNoteToNotebook(noteId, sourceNotebookId, targetNotebookId) {
            if (sourceNotebookId === targetNotebookId) return;
            
            const sourceNotebook = window.findNotebookById(sourceNotebookId);
            const targetNotebook = window.findNotebookById(targetNotebookId);
            
            if (!sourceNotebook || !targetNotebook) return;
            
            // Find and remove the note from source
            const note = findAndRemoveNote(sourceNotebook, noteId);
            if (!note) return;
            
            // Add to target notebook
            if (!targetNotebook.notes) targetNotebook.notes = [];
            targetNotebook.notes.push(note);
            
            showLayerToast(`Moved "${note.name}" to "${targetNotebook.name}"`);
            
            renderNotebooks();
            if (state.viewingNotebook) {
                showNotebookDetailPage(state.viewingNotebook);
            } else {
                renderHomePage();
            }
            saveToStorage();
        }

        // Find and remove a note from a notebook (including from sub-notes)
        function findAndRemoveNote(notebook, noteId) {
            function removeFromNotes(notes) {
                for (let i = 0; i < notes.length; i++) {
                    if (String(notes[i].id) === String(noteId)) {
                        return notes.splice(i, 1)[0];
                    }
                    if (notes[i].children && notes[i].children.length > 0) {
                        const found = removeFromNotes(notes[i].children);
                        if (found) return found;
                    }
                }
                return null;
            }
            return removeFromNotes(notebook.notes || []);
        }

        // Move sub-notebook to top level (make it a root notebook)
        function moveSubNotebookToTopLevel(subNotebookId) {
            const subNotebook = window.findNotebookById(subNotebookId);
            if (!subNotebook) return;
            
            // Remove from current parent
            removeNotebookFromParent(subNotebookId);
            
            // Add to top level
            subNotebook.parentId = null;
            state.notebooks.push(subNotebook);
            
            showLayerToast(`"${subNotebook.name}" moved to top level`);
            
            renderNotebooks();
            renderHomePage();
            saveToStorage();
        }

        // Expose drag handlers to window for inline event handlers
        window.handleSubNotebookDragStart = handleSubNotebookDragStart;
        window.handleSubNotebookDragEnd = handleSubNotebookDragEnd;
        window.handleSubNotebookDragOver = handleSubNotebookDragOver;
        window.handleSubNotebookDrop = handleSubNotebookDrop;
        window.handleNoteDragStart = handleNoteDragStart;
        window.handleNoteDragEnd = handleNoteDragEnd;
        window.handleNoteDragOver = handleNoteDragOver;
        window.handleNoteDrop = handleNoteDrop;
        window.handleDropTargetDragOver = handleDropTargetDragOver;
        window.handleDropTargetDragLeave = handleDropTargetDragLeave;

        // Recursive render for unlimited-depth subnotebooks
        function renderNotebooks() {
            const container = document.getElementById('notebooks-container');
            container.innerHTML = '';

            // Update sort dropdown to reflect current state
            const sortSelect = document.getElementById('notebook-sort');
            if (sortSelect) sortSelect.value = state.notebookSort;

            // Sort notebooks based on current sort mode
            const sortedNotebooks = getSortedNotebooks(state.notebooks);

            function renderNotebookTree(notebook, notebookIndex, depth = 0, parentContainer = null) {
                const notebookEl = document.createElement('div');
                notebookEl.className = 'notebook';
                notebookEl.style.marginLeft = (depth * 18) + 'px';
                notebookEl.dataset.notebookId = notebook.id;
                
                // For sub-notebooks (depth > 0), add subnotebook data attributes
                if (depth > 0) {
                    notebookEl.dataset.subnotebookId = notebook.id;
                    notebookEl.dataset.parentId = notebook.parentId || '';
                    notebookEl.draggable = true;
                }
                
                // Add drag-and-drop for custom sorting (only top-level notebooks)
                if (state.notebookSort === 'custom' && depth === 0) {
                    notebookEl.draggable = true;
                    notebookEl.ondragstart = (e) => handleNotebookDragStart(e, notebook.id);
                    notebookEl.ondragend = handleNotebookDragEnd;
                }
                
                // Always allow dropping items into notebooks
                notebookEl.ondragover = (e) => {
                    handleNotebookDragOver(e);
                    handleDropTargetDragOver(e);
                };
                notebookEl.ondragleave = (e) => {
                    handleNotebookDragLeave(e);
                    handleDropTargetDragLeave(e);
                };
                notebookEl.ondrop = (e) => handleNotebookDrop(e, notebook.id);

                let notesHtml = '';
                notebook.notes.forEach(note => {
                    notesHtml += renderNoteItem(notebook, note, notebookIndex);
                });

                // Add subnotebook button (no folder icon, with tooltip)
                const addSubNotebookBtn = `<button class=\"add-btn\" title=\"New Notebook\" onclick=\"event.stopPropagation(); state.parentNotebookForSubnotebook = window.findNotebookById('${notebook.id}'); showModal('subnotebook');\" style=\"margin-right: 4px; width: 18px; height: 18px; font-size: 0.75rem;\">+</button>`;
                
                // Pin button for notebook
                const isPinned = state.pinnedNotebooks && state.pinnedNotebooks.includes(notebook.id);
                const pinBtn = `<button class=\"notebook-pin-btn ${isPinned ? 'pinned' : ''}\" onclick=\"event.stopPropagation(); toggleNotebookPin('${notebook.id}')\" title=\"${isPinned ? 'Unpin' : 'Pin'}\">${isPinned ? '' : ''}</button>`;

                notebookEl.innerHTML = `
                    <div class=\"notebook-header ${state.currentNotebook && state.currentNotebook.id === notebook.id ? 'active' : ''}\" onclick=\"toggleNotebook(window.findNotebookById('${notebook.id}'))\">
                        <span class=\"notebook-icon\"></span>
                        <span class=\"notebook-name\">${notebook.name}</span>
                        ${pinBtn}
                        ${addSubNotebookBtn}
                        <button class=\"add-btn\" title=\"New Note\" onclick=\"event.stopPropagation(); state.currentNotebook = window.findNotebookById('${notebook.id}'); showModal('note');\" style=\"margin-right: 8px; width: 18px; height: 18px; font-size: 0.75rem;\">+</button>
                        <button class=\"delete-btn\" onclick=\"deleteNotebook(window.findNotebookById('${notebook.id}'), event)\"></button>
                        <span class=\"notebook-toggle ${notebook.isOpen ? 'open' : ''}\"></span>
                    </div>
                    <div class=\"notes-list ${notebook.isOpen ? 'open' : ''}\">
                        ${notesHtml}
                    </div>
                `;
                
                // Append to parent container or main container
                const targetContainer = parentContainer || container;
                targetContainer.appendChild(notebookEl);
                
                // Recursively render children inside the notes-list when parent is open
                if (notebook.children && notebook.children.length > 0 && notebook.isOpen) {
                    const notesList = notebookEl.querySelector('.notes-list');
                    // Sort children too
                    const sortedChildren = getSortedNotebooks(notebook.children);
                    sortedChildren.forEach((child, idx) => renderNotebookTree(child, idx, depth + 1, notesList));
                }
            }

            // Helper to find notebook by id recursively
            window.findNotebookById = function(id, notebooks = state.notebooks) {
                for (const nb of notebooks) {
                    if (nb.id === id) return nb;
                    if (nb.children && nb.children.length > 0) {
                        const found = window.findNotebookById(id, nb.children);
                        if (found) return found;
                    }
                }
                return null;
            };

            sortedNotebooks.forEach((notebook, notebookIndex) => {
                renderNotebookTree(notebook, notebookIndex, 0);
            });
        }

        // Select note by ID
        function selectNoteById(notebookId, noteId) {
            const notebook = window.findNotebookById(notebookId);
            if (notebook) {
                const note = findNoteById(notebook, noteId);
                if (note) {
                    selectNote(notebook, note);
                }
            }
        }

        // Delete note by ID (handles nested notes)
        function deleteNoteById(notebookId, noteId, e) {
            e.stopPropagation();
            const notebook = state.notebooks.find(n => n.id === notebookId);
            if (!notebook) return;
            
            const note = findNoteById(notebook, noteId);
            if (!note) return;
            
            const childCount = countAllChildren(note);
            const message = childCount > 0 
                ? `Delete "${note.name}" and its ${childCount} sub-note(s)?`
                : `Delete "${note.name}"?`;
            
            if (confirm(message)) {
                removeNoteFromTree(notebook, noteId);
                
                // Remove from pinned if pinned
                const pinnedIndex = state.pinnedNotes.findIndex(p => p.notebookId === notebook.id && p.noteId === noteId);
                if (pinnedIndex > -1) {
                    state.pinnedNotes.splice(pinnedIndex, 1);
                    savePinnedToStorage();
                }
                
                if (state.currentNote && state.currentNote.id === noteId) {
                    state.currentNote = null;
                    showHomePage();
                }
                
                renderNotebooks();
                renderHomePage();
                saveToStorage();
            }
        }

        // Count all children recursively
        function countAllChildren(note) {
            if (!note.children || note.children.length === 0) return 0;
            return note.children.reduce((count, child) => count + 1 + countAllChildren(child), 0);
        }

        // Remove note from tree (returns boolean)
        function removeNoteFromTree(notebook, noteId, notes = null) {
            const searchNotes = notes || notebook.notes;
            for (let i = 0; i < searchNotes.length; i++) {
                if (searchNotes[i].id === noteId) {
                    searchNotes.splice(i, 1);
                    return true;
                }
                if (searchNotes[i].children && removeNoteFromTree(notebook, noteId, searchNotes[i].children)) {
                    return true;
                }
            }
            return false;
        }

        // Remove note from notebook and return the removed note
        function removeNoteFromNotebook(noteId, notebook) {
            if (!notebook || !notebook.notes) return null;
            
            function removeFromNotes(notes) {
                for (let i = 0; i < notes.length; i++) {
                    if (String(notes[i].id) === String(noteId)) {
                        return notes.splice(i, 1)[0];
                    }
                    if (notes[i].children && notes[i].children.length > 0) {
                        const found = removeFromNotes(notes[i].children);
                        if (found) return found;
                    }
                }
                return null;
            }
            
            return removeFromNotes(notebook.notes);
        }

        // Pin/Unpin functions
        function isNotePinned(notebookId, noteId) {
            return state.pinnedNotes.some(p => p.notebookId === notebookId && p.noteId === noteId);
        }

        function togglePin(e, notebookId, noteId) {
            e.stopPropagation();
            const index = state.pinnedNotes.findIndex(p => p.notebookId === notebookId && p.noteId === noteId);
            if (index > -1) {
                state.pinnedNotes.splice(index, 1);
            } else {
                state.pinnedNotes.push({ notebookId, noteId });
            }
            renderNotebooks();
            renderHomePage();
            savePinnedToStorage();
        }

        function unpinNote(notebookId, noteId) {
            const index = state.pinnedNotes.findIndex(p => p.notebookId === notebookId && p.noteId === noteId);
            if (index > -1) {
                state.pinnedNotes.splice(index, 1);
                renderNotebooks();
                renderHomePage();
                savePinnedToStorage();
            }
        }

        // Home page functions
        function showHomePage() {
            // Save current note if any
            if (state.currentNote && hasUnsavedChanges) {
                saveNoteData();
                saveToStorage();
            }
            
            // Stop version history timer
            stopVersionHistoryTimer();
            
            // Clear undo/redo history
            clearUndoHistory();
            
            // Clear notebook navigation stack
            notebookNavStack = [];
            state.viewingNotebook = null;
            
            state.currentView = 'home';
            state.currentNote = null;
            
            document.getElementById('home-page').style.display = 'block';
            document.getElementById('notebook-detail-page').style.display = 'none';
            document.getElementById('canvas-container').style.display = 'none';
            document.getElementById('toolbar').style.display = 'none';
            const graphView = document.getElementById('graph-view');
            if (graphView) graphView.style.display = 'none';
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            document.getElementById('nav-home').classList.add('active');
            document.getElementById('note-info').textContent = 'Home';
            
            // Remove sub-note blocks from canvas
            const existingBlocks = document.querySelectorAll('.subnote-block');
            existingBlocks.forEach(block => block.remove());
            
            const indicator = document.getElementById('save-indicator');
            indicator.className = 'save-indicator saved';
            indicator.innerHTML = '<span class="save-dot"></span> <span class="save-text">Saved</span>';
            
            renderHomePage();
            renderNotebooks();
            // Hide header navigation and preview when returning to home
            const headerNav = document.getElementById('header-nav');
            const headerPreview = document.getElementById('header-preview');
            if (headerNav) { headerNav.style.display = 'none'; headerNav.innerHTML = ''; }
            if (headerPreview) { headerPreview.style.display = 'none'; headerPreview.textContent = ''; }
        }

        function showEditor() {
            state.currentView = 'editor';
            document.getElementById('home-page').style.display = 'none';
            document.getElementById('notebook-detail-page').style.display = 'none';
            document.getElementById('canvas-container').style.display = 'block';
            const graphView = document.getElementById('graph-view');
            if (graphView) graphView.style.display = 'none';
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
        }

        function renderHomePage() {
            // Render pinned notes
            const pinnedContainer = document.getElementById('pinned-container');
            if (state.pinnedNotes.length === 0) {
                pinnedContainer.innerHTML = `
                    <div class="empty-pinned">
                        <p>No pinned notes yet. Click  on a note to pin it here.</p>
                    </div>
                `;
            } else {
                pinnedContainer.innerHTML = state.pinnedNotes.map(pin => {
                    const notebook = window.findNotebookById(pin.notebookId);
                    if (!notebook) return '';
                    const note = findNoteById(notebook, pin.noteId);
                    if (!note) return '';
                    const statusBadge = note.status && note.status !== 'none' ? `<span class="status-badge ${note.status}">${getStatusLabel(note.status)}</span>` : '';
                    
                    return `
                        <div class="pinned-card" 
                            data-note-id="${pin.noteId}"
                            data-notebook-id="${pin.notebookId}"
                            draggable="true">
                            <button class="unpin-btn" onclick="event.stopPropagation(); unpinNote('${pin.notebookId}', '${pin.noteId}')" title="Unpin"></button>
                            <div class="pinned-card-preview">
                                ${note.canvasData ? `<img src="${note.canvasData}" alt="Preview">` : ''}
                            </div>
                            <div class="pinned-card-title">${note.name}${statusBadge}</div>
                            <div class="pinned-card-notebook">${notebook.name}</div>
                        </div>
                    `;
                }).join('');
                
                // Add drag event listeners to pinned notes using addEventListener
                const pinnedCards = pinnedContainer.querySelectorAll('.pinned-card[data-note-id]');
                console.log('HOME PAGE: Attaching drag listeners to', pinnedCards.length, 'pinned notes');
                pinnedCards.forEach(card => {
                    const noteId = card.dataset.noteId;
                    const notebookId = card.dataset.notebookId;
                    console.log('HOME PAGE: Setting up drag for pinned note:', noteId);
                    
                    card.addEventListener('click', (e) => {
                        if (e.defaultPrevented) return;
                        openPinnedNote(notebookId, noteId);
                    });
                    card.addEventListener('dragstart', (e) => {
                        e.stopPropagation();
                        console.log('PINNED NOTE DRAGSTART FIRED:', noteId);
                        handleNoteDragStart(e, noteId, notebookId);
                    });
                    card.addEventListener('dragend', (e) => handleNoteDragEnd(e));
                });
            }
            
            // Render notebooks (including sub-notebooks)
            const notebooksContainer = document.getElementById('notebooks-home-container');
            
            // Update home page sort dropdown to reflect current state
            const homeSortSelect = document.getElementById('notebook-sort-home');
            if (homeSortSelect) homeSortSelect.value = state.notebookSort;
            
            // Helper to count all notes recursively (including sub-notes)
            function countAllNotes(notebook) {
                let count = notebook.notes ? notebook.notes.length : 0;
                // Count notes in children recursively
                if (notebook.notes) {
                    notebook.notes.forEach(note => {
                        if (note.children) count += countChildNotes(note);
                    });
                }
                // Count notes in sub-notebooks
                if (notebook.children) {
                    notebook.children.forEach(child => count += countAllNotes(child));
                }
                return count;
            }
            
            function countChildNotes(note) {
                if (!note.children) return 0;
                return note.children.reduce((sum, child) => sum + 1 + countChildNotes(child), 0);
            }
            
            // Only show top-level notebooks on home page (sub-notebooks shown when you click into a notebook)
            if (state.notebooks.length === 0) {
                notebooksContainer.innerHTML = `
                    <div class="empty-pinned">
                        <p>No notebooks yet. Create one to get started!</p>
                    </div>
                `;
            } else {
                // Apply sorting
                const sortedNotebooks = getSortedNotebooks(state.notebooks);
                
                notebooksContainer.innerHTML = sortedNotebooks.map(notebook => {
                    const noteCount = countAllNotes(notebook);
                    const subNotebookCount = notebook.children ? notebook.children.length : 0;
                    const subIndicator = subNotebookCount > 0 ? `  ${subNotebookCount} sub-notebook${subNotebookCount !== 1 ? 's' : ''}` : '';
                    const isPinned = state.pinnedNotebooks && state.pinnedNotebooks.includes(notebook.id);
                    const pinIndicator = isPinned ? '<span class="notebook-card-pin"></span>' : '';
                    
                    return `
                        <div class="notebook-card" 
                            data-notebook-id="${notebook.id}"
                            draggable="true">
                            ${pinIndicator}
                            <div class="notebook-card-icon"></div>
                            <div class="notebook-card-name">${notebook.name}</div>
                            <div class="notebook-card-count">${noteCount} note${noteCount !== 1 ? 's' : ''}${subIndicator}</div>
                        </div>
                    `;
                }).join('');
                
                // Add event listeners to notebook cards
                const notebookCards = notebooksContainer.querySelectorAll('.notebook-card[data-notebook-id]');
                console.log('HOME PAGE: Attaching listeners to', notebookCards.length, 'notebook cards');
                notebookCards.forEach(card => {
                    const notebookId = card.dataset.notebookId;
                    card.onclick = (e) => {
                        if (e.defaultPrevented) return;
                        openNotebook(notebookId);
                    };
                    card.ondragstart = (e) => {
                        console.log('Notebook drag started:', notebookId);
                        handleNotebookDragStart(e, notebookId);
                    };
                    card.ondragend = (e) => handleNotebookDragEnd(e);
                    card.ondragover = (e) => {
                        handleNotebookDragOver(e);
                        handleDropTargetDragOver(e);
                    };
                    card.ondragleave = (e) => {
                        handleNotebookDragLeave(e);
                        handleDropTargetDragLeave(e);
                    };
                    card.ondrop = (e) => handleNotebookDrop(e, notebookId);
                });
            }
        }

        function openPinnedNote(notebookId, noteId) {
            const notebook = window.findNotebookById(notebookId);
            if (!notebook) return;
            const note = findNoteById(notebook, noteId);
            if (!note) return;
            selectNote(notebook, note);
        }

        // Stack to track notebook navigation history
        let notebookNavStack = [];

        function openNotebook(notebookId) {
            const notebook = window.findNotebookById(notebookId);
            if (!notebook) return;
            notebook.isOpen = true;
            state.currentNotebook = notebook;
            
            // Show the notebook detail page instead of immediately opening a note
            showNotebookDetailPage(notebook);
            renderNotebooks();
        }
        
        function showNotebookDetailPage(notebook) {
            // Hide other views
            document.getElementById('home-page').style.display = 'none';
            document.getElementById('graph-view').style.display = 'none';
            document.getElementById('canvas-wrapper').style.display = 'none';
            document.getElementById('toolbar').style.display = 'none';
            document.getElementById('empty-state').style.display = 'none';
            
            // Show notebook detail page
            const detailPage = document.getElementById('notebook-detail-page');
            detailPage.style.display = 'block';
            
            // Set title and path
            document.getElementById('notebook-detail-title').textContent = notebook.name;
            
            // Build breadcrumb path
            const path = getNotebookPath(notebook.id);
            document.getElementById('notebook-detail-path').textContent = path.join('  ');
            
            // Update sort dropdowns
            const subNotebookSortSelect = document.getElementById('subnotebook-sort');
            if (subNotebookSortSelect) subNotebookSortSelect.value = state.subNotebookSort;
            const notesSortSelect = document.getElementById('notes-sort');
            if (notesSortSelect) notesSortSelect.value = state.notesSort;
            
            // Render sub-notebooks
            const subnotebooksContainer = document.getElementById('subnotebooks-container');
            const subnotebooksSection = document.getElementById('subnotebooks-section');
            
            if (notebook.children && notebook.children.length > 0) {
                subnotebooksSection.style.display = 'block';
                const sortedSubNotebooks = getSortedSubNotebooks(notebook.children, notebook.id);
                const isSubNotebookDraggable = state.subNotebookSort === 'custom';
                
                subnotebooksContainer.innerHTML = sortedSubNotebooks.map(child => {
                    const noteCount = countAllNotesInNotebook(child);
                    return `
                        <div class="notebook-card" 
                            data-subnotebook-id="${child.id}"
                            data-parent-id="${notebook.id}"
                            draggable="true">
                            <div class="notebook-card-icon"></div>
                            <div class="notebook-card-name">${child.name}</div>
                            <div class="notebook-card-count">${noteCount} note${noteCount !== 1 ? 's' : ''}</div>
                        </div>
                    `;
                }).join('');
                
                // Add event listeners programmatically for sub-notebooks using addEventListener
                const subCards = subnotebooksContainer.querySelectorAll('.notebook-card[data-subnotebook-id]');
                console.log('DETAIL PAGE: Attaching drag listeners to', subCards.length, 'sub-notebooks');
                subCards.forEach(card => {
                    const subId = card.dataset.subnotebookId;
                    const parentId = card.dataset.parentId;
                    console.log('DETAIL PAGE: Setting up drag for sub-notebook:', subId);
                    
                    card.addEventListener('click', () => navigateToSubNotebook(subId));
                    card.addEventListener('dragstart', (e) => {
                        e.stopPropagation();
                        console.log('SUB-NOTEBOOK DRAGSTART FIRED:', subId);
                        handleSubNotebookDragStart(e, subId, parentId);
                    });
                    card.addEventListener('dragend', (e) => handleSubNotebookDragEnd(e));
                    card.addEventListener('dragover', (e) => {
                        handleDropTargetDragOver(e);
                        if (isSubNotebookDraggable) handleSubNotebookDragOver(e);
                    });
                    card.addEventListener('dragleave', (e) => handleDropTargetDragLeave(e));
                    card.addEventListener('drop', (e) => handleSubNotebookDrop(e, subId, parentId));
                });
            } else {
                subnotebooksSection.style.display = 'none';
            }
            
            // Render notes in this notebook
            const notesContainer = document.getElementById('notebook-notes-container');
            
            if (notebook.notes && notebook.notes.length > 0) {
                const sortedNotes = getSortedNotes(notebook.notes, notebook.id);
                const isNoteDraggable = state.notesSort === 'custom';
                
                notesContainer.innerHTML = sortedNotes.map(note => {
                    const statusBadge = note.status && note.status !== 'none' ? `<span class="status-badge ${note.status}">${getStatusLabel(note.status)}</span>` : '';
                    const childCount = note.children ? note.children.length : 0;
                    const childIndicator = childCount > 0 ? `<span style="font-size:0.75rem;color:#888;margin-left:4px;">(+${childCount})</span>` : '';
                    
                    return `
                        <div class="pinned-card" 
                            data-note-id="${note.id}"
                            data-notebook-id="${notebook.id}"
                            draggable="true">
                            <div class="pinned-card-preview">
                                ${note.canvasData ? `<img src="${note.canvasData}" alt="Preview">` : '<div style="display:flex;align-items:center;justify-content:center;height:100%;font-size:2rem;color:#ccc;"></div>'}
                            </div>
                            <div class="pinned-card-title">${note.name}${childIndicator}${statusBadge}</div>
                            <div class="pinned-card-notebook">${new Date(note.created).toLocaleDateString()}</div>
                        </div>
                    `;
                }).join('');
                
                // Add event listeners programmatically for notes using addEventListener
                const noteCards = notesContainer.querySelectorAll('.pinned-card[data-note-id]');
                console.log('DETAIL PAGE: Attaching drag listeners to', noteCards.length, 'notes');
                noteCards.forEach(card => {
                    const noteId = card.dataset.noteId;
                    const notebookId = card.dataset.notebookId;
                    console.log('DETAIL PAGE: Setting up drag for note:', noteId);
                    
                    card.addEventListener('click', () => openNoteFromDetail(notebookId, noteId));
                    card.addEventListener('dragstart', (e) => {
                        e.stopPropagation();
                        console.log('NOTE DRAGSTART FIRED:', noteId);
                        handleNoteDragStart(e, noteId, notebookId);
                    });
                    card.addEventListener('dragend', (e) => handleNoteDragEnd(e));
                    card.addEventListener('dragover', (e) => {
                        if (isNoteDraggable) handleNoteDragOver(e);
                    });
                    card.addEventListener('dragleave', () => card.classList.remove('drag-over'));
                    card.addEventListener('drop', (e) => handleNoteDrop(e, noteId, notebookId));
                });
            } else {
                notesContainer.innerHTML = `
                    <div class="empty-pinned">
                        <p>No notes in this notebook yet. Click + to create one.</p>
                    </div>
                `;
            }
            
            // Update nav
            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            
            // Track current view
            state.currentView = 'notebook-detail';
            state.viewingNotebook = notebook;
        }
        
        function navigateToSubNotebook(notebookId) {
            // Push current notebook to stack for back navigation
            if (state.viewingNotebook) {
                notebookNavStack.push(state.viewingNotebook.id);
            }
            const notebook = window.findNotebookById(notebookId);
            if (notebook) {
                notebook.isOpen = true;
                state.currentNotebook = notebook;
                showNotebookDetailPage(notebook);
                renderNotebooks();
            }
        }
        
        function openNoteFromDetail(notebookId, noteId) {
            const notebook = window.findNotebookById(notebookId);
            if (!notebook) return;
            const note = findNoteById(notebook, noteId);
            if (!note) return;
            selectNote(notebook, note);
        }
        
        function goBackFromNotebook() {
            if (notebookNavStack.length > 0) {
                const prevNotebookId = notebookNavStack.pop();
                const prevNotebook = window.findNotebookById(prevNotebookId);
                if (prevNotebook) {
                    showNotebookDetailPage(prevNotebook);
                    return;
                }
            }
            // Go back to home
            showHomePage();
        }
        
        function getNotebookPath(notebookId, notebooks = state.notebooks, path = ['Home']) {
            for (const nb of notebooks) {
                if (nb.id === notebookId) {
                    return [...path, nb.name];
                }
                if (nb.children && nb.children.length > 0) {
                    const found = getNotebookPath(notebookId, nb.children, [...path, nb.name]);
                    if (found.length > path.length + 1) return found;
                }
            }
            return path;
        }
        
        function countAllNotesInNotebook(notebook) {
            let count = notebook.notes ? notebook.notes.length : 0;
            if (notebook.notes) {
                notebook.notes.forEach(note => {
                    if (note.children) count += countChildNotesRecursive(note);
                });
            }
            if (notebook.children) {
                notebook.children.forEach(child => count += countAllNotesInNotebook(child));
            }
            return count;
        }
        
        function countChildNotesRecursive(note) {
            if (!note.children) return 0;
            return note.children.reduce((sum, child) => sum + 1 + countChildNotesRecursive(child), 0);
        }

        // Save/Load functions
        // Async version for autosave - doesn't block drawing
        async function saveNoteDataAsync() {
            if (!state.currentNote) return;
            
            // Save canvas data - prefer layers if available, fallback to flat canvas
            if (typeof canvasModule !== 'undefined' && canvasModule.manager?.layerManager) {
                const layerManager = canvasModule.manager.layerManager;
                // Save full layer data for future loading (async to avoid blocking)
                state.currentNote.layersData = await layerManager.serializeAsync();
                // Also save flattened version for backward compatibility (async)
                state.currentNote.canvasData = await layerManager.getFlattenedDataURLAsync();
            } else {
                // Wrap sync toDataURL in requestIdleCallback to avoid blocking
                state.currentNote.canvasData = await new Promise((resolve) => {
                    const doWork = () => resolve(drawingCanvas.toDataURL());
                    if (typeof requestIdleCallback !== 'undefined') {
                        requestIdleCallback(doWork, { timeout: 1000 });
                    } else {
                        setTimeout(doWork, 0);
                    }
                });
            }
            
            state.currentNote.textBoxes = Array.from(textLayer.querySelectorAll('.text-box')).map(box => ({
                content: box.innerHTML,
                left: box.style.left,
                top: box.style.top,
                width: box.style.width,
                height: box.style.height,
                fontFamily: box.style.fontFamily,
                fontSize: box.style.fontSize,
                color: box.style.color,
                headerLevel: box.getAttribute('data-header-level') || null
            }));
            
            // Save media embeds (they may be in #media-layer or in layer content containers)
            state.currentNote.mediaEmbeds = Array.from(document.querySelectorAll('.media-embed')).map(embed => ({
                id: embed.getAttribute('data-embed-id'),
                type: embed.getAttribute('data-embed-type'),
                url: embed.getAttribute('data-embed-url'),
                left: embed.style.left,
                top: embed.style.top,
                width: embed.style.width,
                height: embed.style.height,
                layerId: embed.getAttribute('data-layer-id') || null
            }));
            
            // Save vector strokes (resolution-independent drawing data)
            state.currentNote.vectorStrokes = vectorStrokes;
        }
        
        // Sync version for critical saves (beforeunload, etc.)
        function saveNoteData() {
            if (!state.currentNote) return;
            
            // Save canvas data - prefer layers if available, fallback to flat canvas
            if (typeof canvasModule !== 'undefined' && canvasModule.manager?.layerManager) {
                const layerManager = canvasModule.manager.layerManager;
                // Save full layer data for future loading
                state.currentNote.layersData = layerManager.serialize();
                // Also save flattened version for backward compatibility
                state.currentNote.canvasData = layerManager.getFlattenedDataURL();
            } else {
                state.currentNote.canvasData = drawingCanvas.toDataURL();
            }
            
            state.currentNote.textBoxes = Array.from(textLayer.querySelectorAll('.text-box')).map(box => ({
                content: box.innerHTML,
                left: box.style.left,
                top: box.style.top,
                width: box.style.width,
                height: box.style.height,
                fontFamily: box.style.fontFamily,
                fontSize: box.style.fontSize,
                color: box.style.color,
                headerLevel: box.getAttribute('data-header-level') || null
            }));
            
            // Save media embeds (they may be in #media-layer or in layer content containers)
            state.currentNote.mediaEmbeds = Array.from(document.querySelectorAll('.media-embed')).map(embed => ({
                id: embed.getAttribute('data-embed-id'),
                type: embed.getAttribute('data-embed-type'),
                url: embed.getAttribute('data-embed-url'),
                left: embed.style.left,
                top: embed.style.top,
                width: embed.style.width,
                height: embed.style.height,
                layerId: embed.getAttribute('data-layer-id') || null
            }));
            
            // Save vector strokes (resolution-independent drawing data)
            state.currentNote.vectorStrokes = vectorStrokes;
        }

        async function loadNoteData(note) {
            initCanvases();
            
            // Clear undo/redo history for new note
            clearUndoHistory();
            
            // Clear previous vector strokes
            vectorStrokes = [];
            currentStroke = null;
            
            // Load version history
            versionHistory = note.versionHistory || [];
            
            // Start version history timer
            startVersionHistoryTimer();
            
            // Load vector strokes if available (preferred - resolution independent)
            if (note.vectorStrokes && note.vectorStrokes.length > 0) {
                vectorStrokes = note.vectorStrokes;
                currentStroke = null;
                renderAllStrokes();
                saveInitialState();
            } else if (typeof canvasModule !== 'undefined' && canvasModule.manager?.layerManager) {
                const layerManager = canvasModule.manager.layerManager;
                
                if (note.layersData && note.layersData.length > 0) {
                    // Load full layer data
                    layerManager.deserialize(note.layersData);
                    saveInitialState();
                } else if (note.canvasData) {
                    // Backward compatibility: load flat canvas into background layer
                    layerManager.clearAll();
                    const activeLayer = layerManager.getActiveLayer();
                    if (activeLayer) {
                        const img = new Image();
                        img.onload = () => {
                            activeLayer.ctx.drawImage(img, 0, 0);
                            saveInitialState();
                        };
                        img.src = note.canvasData;
                    }
                } else {
                    // New blank note
                    layerManager.clearAll();
                    saveInitialState();
                }
            } else {
                // Fallback to original drawing canvas
                if (note.canvasData) {
                    const img = new Image();
                    img.onload = () => {
                        drawCtx.drawImage(img, 0, 0);
                        // Draw a visible red border to confirm image is rendered
                        drawCtx.save();
                        drawCtx.strokeStyle = 'red';
                        drawCtx.lineWidth = 8;
                        drawCtx.strokeRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                        drawCtx.restore();
                        saveInitialState();
                    };
                    img.src = note.canvasData;
                } else {
                    drawCtx.fillStyle = getCanvasBackground();
                    drawCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    saveInitialState();
                }
            }

            // Load text boxes - clear only text-box elements, preserve layer content containers
            // Remove all text-box elements but keep .layer-content containers
            const textBoxesToRemove = textLayer.querySelectorAll('.text-box');
            textBoxesToRemove.forEach(box => box.remove());
            
            if (note.textBoxes && note.textBoxes.length > 0) {
                note.textBoxes.forEach((boxData, idx) => {
                    const textBox = document.createElement('div');
                    textBox.className = 'text-box placed';
                    // Restore header class if this textbox was a header when saved
                    if (boxData.headerLevel) {
                        textBox.className += ` header-${boxData.headerLevel}`;
                        textBox.setAttribute('data-header-level', boxData.headerLevel);
                    }
                    textBox.contentEditable = true;
                    // Use innerHTML when content contains markup, otherwise preserve newlines
                    if (boxData.content && boxData.content.includes('<')) {
                        textBox.innerHTML = boxData.content;
                    } else if (boxData.content && boxData.content.indexOf('\n') !== -1) {
                        // Escape HTML then convert newlines to <br>
                        textBox.innerHTML = escapeHTML(boxData.content).replace(/\n/g, '<br>');
                    } else {
                        textBox.textContent = boxData.content || '';
                    }
                    textBox.style.position = 'absolute';
                    textBox.style.left = boxData.left;
                    textBox.style.top = boxData.top;
                    textBox.style.minWidth = '50px';
                    textBox.style.minHeight = '20px';
                    if (boxData.width && boxData.width !== 'auto' && boxData.width !== '') {
                        textBox.style.width = boxData.width;
                    }
                    if (boxData.height && boxData.height !== 'auto' && boxData.height !== '') {
                        textBox.style.height = boxData.height;
                    }
                    if (boxData.fontFamily) textBox.style.fontFamily = boxData.fontFamily;
                    // For headers, prefer CSS header sizing  avoid setting inline fontSize
                    if (!boxData.headerLevel) {
                        if (boxData.fontSize) textBox.style.fontSize = boxData.fontSize;
                    } else {
                        textBox.style.fontSize = '';
                    }
                    if (boxData.color) textBox.style.color = boxData.color;
                    
                    textBox.addEventListener('blur', () => {
                        if (textBox.textContent.trim() === '') {
                            textBox.remove();
                        }
                        // Exit editing mode when blurred
                        textBox.dataset.editing = 'false';
                        saveToUndoStack();
                        markUnsaved();
                    });

                    textBox.addEventListener('input', debounce(() => markUnsaved(), 500));
                    
                    // Add click handler for select tool
                    addTextBoxSelectHandler(textBox);
                    
                    textLayer.appendChild(textBox);
                });
            }
            
            // Clear existing media embeds before loading new ones
            document.querySelectorAll('.media-embed').forEach(embed => embed.remove());
            
            // Load media embeds
            if (note.mediaEmbeds) {
                const seenEvernoteLinks = new Set();
                // Process media embeds - load from IndexedDB if needed
                const processedEmbeds = await processMediaForLoad(note.mediaEmbeds);
                processedEmbeds.forEach(embedData => {
                    // If this is an iframe for an Evernote link, skip it if an evernote-link embed exists for the same URL
                    if (
                        embedData.type === 'iframe' &&
                        /^(https?:\/\/www\.evernote\.com\/shard\/|evernote:\/\/view\/)/i.test(embedData.url) &&
                        processedEmbeds.some(e => e.type === 'evernote-link' && e.url === embedData.url)
                    ) {
                        return;
                    }
                    createMediaEmbed(embedData.url, embedData.type, {
                        id: embedData.id,
                        left: embedData.left,
                        top: embedData.top,
                        width: embedData.width,
                        height: embedData.height,
                        layerId: embedData.layerId
                    });
                });
            }

            // Update outline and header nav after loading text boxes
            updateOutline();

            // Ensure canvas wrapper transform is applied after loading content
            updateCanvasTransform();
        }

        // Auto-save
        let saveTimeout = null;
        let debounceSaveTimeout = null;
        let hasUnsavedChanges = false;
        let suppressNextAutoSave = false;
        const SAVE_DELAY = 2000; // Save 2 seconds after user stops making changes
        
        function markUnsaved() {
            if (!hasUnsavedChanges) {
                hasUnsavedChanges = true;
                const indicator = document.getElementById('save-indicator');
                indicator.className = 'save-indicator unsaved';
                indicator.innerHTML = '<span class="save-dot"></span> <span class="save-text">Unsaved changes</span>';
            }
            
            // Debounce: save after user stops making changes
            if (debounceSaveTimeout) clearTimeout(debounceSaveTimeout);
            debounceSaveTimeout = setTimeout(() => {
                if (hasUnsavedChanges && state.currentNote) {
                    saveCurrentNoteAsync();
                }
            }, SAVE_DELAY);
        }
        
        // Async save for autosave - doesn't block drawing
        async function saveCurrentNoteAsync() {
            if (!state.currentNote) return;
            
            // Prevent immediate auto-save from overwriting imported content
            if (suppressNextAutoSave) {
                suppressNextAutoSave = false;
                return;
            }
            
            const indicator = document.getElementById('save-indicator');
            
            // Show saving state
            indicator.className = 'save-indicator saving';
            indicator.innerHTML = '<span class="save-dot"></span> <span class="save-text">Saving...</span>';
            
            // Use async save to avoid blocking drawing
            await saveNoteDataAsync();
            await saveToStorage();
            hasUnsavedChanges = false;

            // Clear any existing timeout
            if (saveTimeout) clearTimeout(saveTimeout);
            
            // Show "just saved" state briefly
            setTimeout(() => {
                indicator.className = 'save-indicator just-saved';
                indicator.innerHTML = '<span class="save-dot"></span> <span class="save-text">Saved just now</span>';
                
                // Then fade to normal saved state
                saveTimeout = setTimeout(() => {
                    indicator.className = 'save-indicator saved';
                    indicator.innerHTML = '<span class="save-dot"></span> <span class="save-text">Saved</span>';
                }, 2000);
            }, 400);
        }
        
        // Sync save for critical operations (manual save, etc.) - now async
        async function saveCurrentNote() {
            if (!state.currentNote) return;
            
            // Prevent immediate auto-save from overwriting imported content
            if (suppressNextAutoSave) {
                suppressNextAutoSave = false;
                return;
            }
            
            const indicator = document.getElementById('save-indicator');
            
            // Show saving state
            indicator.className = 'save-indicator saving';
            indicator.innerHTML = '<span class="save-dot"></span> <span class="save-text">Saving...</span>';
            
            saveNoteData();
            await saveToStorage();
            hasUnsavedChanges = false;

            // Clear any existing timeout
            if (saveTimeout) clearTimeout(saveTimeout);
            
            // Show "just saved" state briefly
            setTimeout(() => {
                indicator.className = 'save-indicator just-saved';
                indicator.innerHTML = '<span class="save-dot"></span> <span class="save-text">Saved just now</span>';
                
                // Then fade to normal saved state
                saveTimeout = setTimeout(() => {
                    indicator.className = 'save-indicator saved';
                    indicator.innerHTML = '<span class="save-dot"></span> <span class="save-text">Saved</span>';
                }, 2000);
            }, 400);
        }
        
        // Save before leaving page
        window.addEventListener('beforeunload', (e) => {
            if (hasUnsavedChanges && state.currentNote) {
                saveNoteData();
                // Use sync localStorage save for beforeunload - IndexedDB async won't complete in time
                try {
                    localStorage.setItem('ultimateNotesApp', JSON.stringify(state.notebooks));
                } catch (e) {
                    console.error('Failed to save before unload:', e);
                }
            }
        });

        // IndexedDB for large media storage
        const DB_NAME = 'NotesAppMediaDB';
        const DB_VERSION = 1;
        const MEDIA_STORE = 'media';
        let mediaDB = null;

        function initMediaDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => {
                    console.error('Failed to open IndexedDB:', request.error);
                    reject(request.error);
                };
                
                request.onsuccess = () => {
                    mediaDB = request.result;
                    console.log('IndexedDB initialized for media storage');
                    resolve(mediaDB);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(MEDIA_STORE)) {
                        db.createObjectStore(MEDIA_STORE, { keyPath: 'id' });
                        console.log('Created media object store');
                    }
                };
            });
        }

        async function saveMediaToDB(id, dataUrl) {
            if (!mediaDB) await initMediaDB();
            return new Promise((resolve, reject) => {
                const transaction = mediaDB.transaction([MEDIA_STORE], 'readwrite');
                const store = transaction.objectStore(MEDIA_STORE);
                const request = store.put({ id, dataUrl, timestamp: Date.now() });
                request.onsuccess = () => resolve(id);
                request.onerror = () => reject(request.error);
            });
        }

        async function getMediaFromDB(id) {
            if (!mediaDB) await initMediaDB();
            return new Promise((resolve, reject) => {
                const transaction = mediaDB.transaction([MEDIA_STORE], 'readonly');
                const store = transaction.objectStore(MEDIA_STORE);
                const request = store.get(id);
                request.onsuccess = () => resolve(request.result?.dataUrl || null);
                request.onerror = () => reject(request.error);
            });
        }

        async function deleteMediaFromDB(id) {
            if (!mediaDB) await initMediaDB();
            return new Promise((resolve, reject) => {
                const transaction = mediaDB.transaction([MEDIA_STORE], 'readwrite');
                const store = transaction.objectStore(MEDIA_STORE);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Check if a data URL is large enough to store in IndexedDB
        function isLargeMedia(dataUrl) {
            return dataUrl && dataUrl.startsWith('data:') && dataUrl.length > 50000; // > 50KB
        }

        // Process media embeds for saving - store large ones in IndexedDB
        async function processMediaForSave(mediaEmbeds) {
            const processed = [];
            for (const embed of mediaEmbeds) {
                if (isLargeMedia(embed.url)) {
                    // Store in IndexedDB and save reference
                    const mediaId = embed.id || `media-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    try {
                        await saveMediaToDB(mediaId, embed.url);
                        processed.push({
                            ...embed,
                            url: `indexeddb://${mediaId}`, // Reference to IndexedDB
                            originalId: mediaId
                        });
                        console.log(`Saved large media to IndexedDB: ${mediaId}`);
                    } catch (e) {
                        console.error('Failed to save media to IndexedDB:', e);
                        processed.push(embed); // Keep original if IndexedDB fails
                    }
                } else {
                    processed.push(embed);
                }
            }
            return processed;
        }

        // Process media embeds for loading - retrieve from IndexedDB
        async function processMediaForLoad(mediaEmbeds) {
            const processed = [];
            for (const embed of mediaEmbeds) {
                if (embed.url && embed.url.startsWith('indexeddb://')) {
                    const mediaId = embed.url.replace('indexeddb://', '');
                    try {
                        const dataUrl = await getMediaFromDB(mediaId);
                        if (dataUrl) {
                            processed.push({ ...embed, url: dataUrl });
                        } else {
                            console.warn(`Media not found in IndexedDB: ${mediaId}`);
                        }
                    } catch (e) {
                        console.error('Failed to load media from IndexedDB:', e);
                    }
                } else {
                    processed.push(embed);
                }
            }
            return processed;
        }

        async function saveToStorage() {
            try {
                // Process all notes to save large media to IndexedDB
                for (const notebook of state.notebooks) {
                    await processNotebookMediaForSave(notebook);
                }
                localStorage.setItem('ultimateNotesApp', JSON.stringify(state.notebooks));
                // Also save pinned items and sort preferences
                savePinnedToStorage();
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    console.error('Storage quota exceeded! Trying to free space...');
                    // Try to free space by clearing version history
                    state.notebooks.forEach(nb => {
                        const processNotes = (notes) => {
                            notes.forEach(n => { 
                                n.versionHistory = [];
                                if (n.children) processNotes(n.children);
                            });
                        };
                        processNotes(nb.notes || []);
                    });
                    try {
                        localStorage.setItem('ultimateNotesApp', JSON.stringify(state.notebooks));
                        console.log('Saved after clearing version history');
                    } catch (e2) {
                        alert('Storage is full! Consider exporting and deleting some notes.');
                    }
                } else {
                    console.error('Save error:', e);
                }
            }
        }

        async function processNotebookMediaForSave(notebook) {
            const processNotes = async (notes) => {
                for (const note of notes) {
                    if (note.mediaEmbeds && note.mediaEmbeds.length > 0) {
                        note.mediaEmbeds = await processMediaForSave(note.mediaEmbeds);
                    }
                    if (note.children && note.children.length > 0) {
                        await processNotes(note.children);
                    }
                }
            };
            await processNotes(notebook.notes || []);
            if (notebook.children && notebook.children.length > 0) {
                for (const child of notebook.children) {
                    await processNotebookMediaForSave(child);
                }
            }
        }

        function savePinnedToStorage() {
            localStorage.setItem('ultimateNotesAppPinned', JSON.stringify(state.pinnedNotes));
            localStorage.setItem('ultimateNotesAppPinnedNotebooks', JSON.stringify(state.pinnedNotebooks || []));
            localStorage.setItem('ultimateNotesAppNotebookSort', state.notebookSort || 'pinned');
            localStorage.setItem('ultimateNotesAppNotebookCustomOrder', JSON.stringify(state.notebookCustomOrder || []));
            localStorage.setItem('ultimateNotesAppSubNotebookSort', state.subNotebookSort || 'alphabetical');
            localStorage.setItem('ultimateNotesAppNotesSort', state.notesSort || 'recent');
            
            // Save all custom order keys (subnotebook and note orders per notebook)
            const customOrders = {};
            for (const key in state) {
                if (key.startsWith('subnotebook_order_') || key.startsWith('notes_order_')) {
                    customOrders[key] = state[key];
                }
            }
            localStorage.setItem('ultimateNotesAppCustomOrders', JSON.stringify(customOrders));
        }

        async function loadFromStorage() {
            // Initialize IndexedDB first
            try {
                await initMediaDB();
            } catch (e) {
                console.error('Failed to init IndexedDB:', e);
            }
            
            const saved = localStorage.getItem('ultimateNotesApp');
            if (saved) {
                state.notebooks = JSON.parse(saved);
            }
            const savedPinned = localStorage.getItem('ultimateNotesAppPinned');
            if (savedPinned) {
                state.pinnedNotes = JSON.parse(savedPinned);
            }
            const savedPinnedNotebooks = localStorage.getItem('ultimateNotesAppPinnedNotebooks');
            if (savedPinnedNotebooks) {
                state.pinnedNotebooks = JSON.parse(savedPinnedNotebooks);
            }
            const savedNotebookSort = localStorage.getItem('ultimateNotesAppNotebookSort');
            if (savedNotebookSort) {
                state.notebookSort = savedNotebookSort;
            }
            const savedNotebookCustomOrder = localStorage.getItem('ultimateNotesAppNotebookCustomOrder');
            if (savedNotebookCustomOrder) {
                state.notebookCustomOrder = JSON.parse(savedNotebookCustomOrder);
            }
            const savedSubNotebookSort = localStorage.getItem('ultimateNotesAppSubNotebookSort');
            if (savedSubNotebookSort) {
                state.subNotebookSort = savedSubNotebookSort;
            }
            const savedNotesSort = localStorage.getItem('ultimateNotesAppNotesSort');
            if (savedNotesSort) {
                state.notesSort = savedNotesSort;
            }
            // Load custom orders for subnotebooks and notes
            const savedCustomOrders = localStorage.getItem('ultimateNotesAppCustomOrders');
            if (savedCustomOrders) {
                const customOrders = JSON.parse(savedCustomOrders);
                for (const key in customOrders) {
                    state[key] = customOrders[key];
                }
            }
            // Load dark mode preference
            const darkMode = localStorage.getItem('ultimateNotesAppDarkMode');
            if (darkMode === 'true') {
                document.body.classList.add('dark-mode');
            }
            renderNotebooks();
            renderHomePage();
            // Make sure AI portal matches current theme on load
            try { updateAIPortalDarkMode(); } catch (e) { /* ignore */ }
            suppressNextAutoSave = true; // Prevent first auto-save from overwriting imported notes
        }

        // Dark Mode Toggle
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem('ultimateNotesAppDarkMode', isDark);
            
            // Update default ink color
            updateDefaultColor();
            
            // Update canvas background when toggling
            if (state.currentNote) {
                // Invert the canvas colors
                invertCanvasColors();
            }
            // Update AI portal colors for dark mode
            updateAIPortalDarkMode();
        }
        
        function isDarkMode() {
            return document.body.classList.contains('dark-mode');
        }
        
        function getCanvasBackground() {
            return isDarkMode() ? '#2a2a2a' : '#ffffff';
        }
        
        function getDefaultInkColor() {
            return isDarkMode() ? '#e0e0e0' : '#333333';
        }
        
        function getEraserColor() {
            return getCanvasBackground();
        }

        // Update AI portal styling for dark mode
        function updateAIPortalDarkMode() {
            const ta = document.getElementById('ai-prompt');
            const res = document.getElementById('ai-result');
            if (!ta || !res) return;
            if (isDarkMode()) {
                ta.style.background = '#1b1b1b';
                ta.style.color = '#e6e6e6';
                ta.style.border = '1px solid #333';
                res.style.background = 'transparent';
                res.style.color = '#e6e6e6';
            } else {
                ta.style.background = '';
                ta.style.color = '';
                ta.style.border = '';
                res.style.background = '';
                res.style.color = '';
            }
        }
        
        function invertCanvasColors() {
            // Define the ink colors for each mode
            const darkModeInk = { r: 224, g: 224, b: 224 }; // #e0e0e0 (light/white ink)
            const lightModeInk = { r: 51, g: 51, b: 51 };   // #333333 (dark/black ink)
            
            const switchingToDark = isDarkMode();
            
            // Helper to invert a single canvas
            function invertCanvas(ctx, width, height) {
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const a = data[i + 3]; // Alpha channel
                    
                    // Skip transparent pixels (background/erased areas)
                    if (a < 10) continue;
                    
                    // Any visible pixel is ink - convert to the appropriate mode's ink color
                    if (switchingToDark) {
                        data[i] = darkModeInk.r;
                        data[i + 1] = darkModeInk.g;
                        data[i + 2] = darkModeInk.b;
                    } else {
                        data[i] = lightModeInk.r;
                        data[i + 1] = lightModeInk.g;
                        data[i + 2] = lightModeInk.b;
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
            // Invert all layer canvases if layer system exists
            if (typeof canvasModule !== 'undefined' && canvasModule.manager?.layerManager) {
                const layerManager = canvasModule.manager.layerManager;
                const pixelRatio = canvasModule.manager.pixelRatio || 1;
                
                for (const layer of layerManager.layers) {
                    if (layer.ctx) {
                        const width = layer.canvas.width;
                        const height = layer.canvas.height;
                        invertCanvas(layer.ctx, width, height);
                    }
                }
            }
            
            // Also invert the main draw canvas (fallback for non-layer mode)
            invertCanvas(drawCtx, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Also invert text box colors
            document.querySelectorAll('.text-box').forEach(box => {
                const currentColor = box.style.color;
                if (currentColor) {
                    box.style.color = invertColor(currentColor);
                }
            });
            
            // Also update stored stroke colors so re-renders work correctly
            if (state.currentNote && state.currentNote.strokes) {
                const newColor = switchingToDark ? 
                    `rgb(${darkModeInk.r}, ${darkModeInk.g}, ${darkModeInk.b})` : 
                    `rgb(${lightModeInk.r}, ${lightModeInk.g}, ${lightModeInk.b})`;
                    
                state.currentNote.strokes.forEach(stroke => {
                    if (stroke.color) {
                        stroke.color = newColor;
                    }
                });
            }
            
            markUnsaved();
        }
        
        function invertColor(color) {
            // Handle hex colors
            if (color.startsWith('#')) {
                const hex = color.slice(1);
                const r = 255 - parseInt(hex.substr(0, 2), 16);
                const g = 255 - parseInt(hex.substr(2, 2), 16);
                const b = 255 - parseInt(hex.substr(4, 2), 16);
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }
            // Handle rgb colors
            if (color.startsWith('rgb')) {
                const match = color.match(/\d+/g);
                if (match) {
                    const r = 255 - parseInt(match[0]);
                    const g = 255 - parseInt(match[1]);
                    const b = 255 - parseInt(match[2]);
                    return `rgb(${r}, ${g}, ${b})`;
                }
            }
            return color;
        }

        // Debounce helper
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Initialize
        loadFromStorage();
        initCanvases();
        showHomePage();
        
        // Initialize tool state (ensure pointer events are set correctly)
        setTool(state.tool);
        
        // Initialize external modules
        if (typeof canvasModule !== 'undefined') {
            canvasModule.init({ width: CANVAS_WIDTH, height: CANVAS_HEIGHT });
            canvasModule.manager.setState(state);
            canvasModule.manager.onUnsaved = markUnsaved;
            canvasModule.manager.onSaveToUndo = saveToUndoStack;
            
            // Hide the original drawing canvas - we use it only for event capture
            // Actual drawing happens on layer canvases
            drawingCanvas.style.background = 'transparent';
            drawCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        }
        
        if (typeof evernoteModule !== 'undefined') {
            evernoteModule.init();
            evernoteModule.getState = () => state;
            evernoteModule.getDefaultInkColor = getDefaultInkColor;
            evernoteModule.renderNotebooks = renderNotebooks;
            evernoteModule.renderHomePage = renderHomePage;
        }
        
        // Toggle layer panel visibility
        function toggleLayerPanel() {
            if (typeof canvasModule !== 'undefined') {
                canvasModule.toggleLayerPanel();
                const btn = document.getElementById('layers-btn');
                const panel = document.getElementById('layer-panel');
                if (panel && panel.classList.contains('visible')) {
                    btn?.classList.add('active');
                } else {
                    btn?.classList.remove('active');
                }
            }
        }
        window.toggleLayerPanel = toggleLayerPanel;
        
        // Set initial color based on dark mode
        updateDefaultColor();
        
        function updateDefaultColor() {
            const defaultColor = getDefaultInkColor();
            state.color = defaultColor;
            document.getElementById('color-picker').value = defaultColor;
        }

        // Manual save
        function manualSave() {
            if (state.currentNote) {
                saveCurrentNote();
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.classList.contains('text-box') || e.target.classList.contains('modal-input')) {
                // Allow Ctrl+S even in text boxes
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    manualSave();
                }
                // Allow Ctrl+Z for undo in text boxes (but use our custom undo for canvas)
                return;
            }
            
            // Ctrl+S to save
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                manualSave();
                return;
            }
            
            // Ctrl+Z to undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
                return;
            }
            
            // Ctrl+Y or Ctrl+Shift+Z to redo
            if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
                return;
            }
            
            // Delete or Backspace to delete selected text box or media embed
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedTextBox) {
                e.preventDefault();
                deleteSelectedTextBox();
                return;
            }
            
            // Delete selected media embed
            if ((e.key === 'Delete' || e.key === 'Backspace')) {
                const selectedEmbed = document.querySelector('.media-embed.selected');
                if (selectedEmbed) {
                    e.preventDefault();
                    selectedEmbed.remove();
                    markUnsaved();
                    return;
                }
            }
            
            if (e.key === 'd') setTool('draw');
            if (e.key === 's') setTool('select');
            if (e.key === 'e') setTool('erase');
            if (e.key === 't') setTool('text');
            if (e.key === 'p') setTool('pan');
            if (e.key === 'g') toggleGrid();
            if (e.key === '+' || e.key === '=') zoomIn();
            if (e.key === '-') zoomOut();
            if (e.key === '0') resetZoom();
        });
    </script>
    <script>
        // Local AI helper: posts prompts to the local bridge at 127.0.0.1:3000
        async function askLocalAI(prompt) {
            try {
                const resp = await fetch('http://127.0.0.1:3000/api/ai', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt })
                });
                if (!resp.ok) {
                    const err = await resp.json().catch(() => ({}));
                    throw new Error(err.error || 'Local AI bridge error');
                }
                const data = await resp.json();
                return data.text;
            } catch (e) {
                console.error('askLocalAI error', e);
                // Provide a clearer message for common network failures
                const msg = (e && e.message) ? e.message.toLowerCase() : '';
                if (e instanceof TypeError || msg.includes('failed to fetch') || msg.includes('networkerror') || msg.includes('network request failed')) {
                    throw new Error('Failed to contact local AI bridge at http://127.0.0.1:3000.\nMake sure the bridge/server is running (run start-server.ps1) and that port 3000 is reachable.');
                }
                throw e;
            }
        }

        // Example usage:
        // askLocalAI('Summarize this note in 3 sentences').then(text => console.log(text)).catch(console.error);
    </script>
    <script>
        // AI portal helpers
        let lastAIResult = '';

        function showAIResult(text) {
            const out = document.getElementById('ai-result');
            if (!out) return;
            try {
                if (typeof text === 'string' && text.indexOf('Failed to contact local AI bridge') !== -1) {
                    const commands = `cd "C:\\Users\\emily\\Documents\\Notes-App"\n# Install deps\nnpm install\n# Start bridge\nnpm start\n# Serve UI\n.\\start-server.ps1`;
                    out.innerHTML = `
                        <div style="padding:8px;border:1px solid #f1c40f;background:#fff8e1;border-radius:6px;">
                            <div style="font-weight:700;color:#b36b00;margin-bottom:6px;">Cannot reach local AI bridge</div>
                            <div style="margin-bottom:8px;color:#333;white-space:pre-wrap;">${escapeHtml(text)}</div>
                            <div style="font-size:0.9rem;color:#444;margin-bottom:8px;">Quick fix  open PowerShell and run:</div>
                            <pre id="bridge-cmds" style="background:#f6f6f6;padding:8px;border-radius:6px;overflow:auto;margin-bottom:8px;">${escapeHtml(commands)}</pre>
                            <div style="display:flex;gap:8px;">
                                <button onclick="copyBridgeCommands()" style="padding:6px 10px;border-radius:6px;border:1px solid #ccc;background:white;cursor:pointer;">Copy commands</button>
                                <button onclick="showBridgeHelpDetails()" style="padding:6px 10px;border-radius:6px;border:1px solid #ccc;background:white;cursor:pointer;">How to install Node</button>
                            </div>
                        </div>
                    `;
                    return;
                }
            } catch (err) {
                console.error('showAIResult render error', err);
            }
            out.textContent = text;
        }

        function copyBridgeCommands() {
            const el = document.getElementById('bridge-cmds');
            if (!el) return;
            const txt = el.textContent || el.innerText || '';
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(txt).then(() => {
                    alert('Commands copied to clipboard');
                }).catch(() => {
                    prompt('Copy these commands manually:', txt);
                });
            } else {
                prompt('Copy these commands manually:', txt);
            }
        }

        function showBridgeHelpDetails() {
            const help = `Install Node.js (LTS) then run:\n\nwinget install OpenJS.NodeJS.LTS -e\n# or download from https://nodejs.org\n\nThen in project folder:\ncd "C:\\Users\\emily\\Documents\\Notes-App"\nnpm install\nnpm start`;
            alert(help);
        }

        function escapeHtml(str) {
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        async function summarizeCurrentNote() {
            if (!state.currentNote) return alert('Please open a note first');
            const content = textLayer.innerText.trim();
            if (!content) return alert('Current note appears to be empty');

            const userPrompt = document.getElementById('ai-prompt')?.value.trim();
            const prompt = userPrompt && userPrompt.length > 0
                ? userPrompt
                : `Summarize the following note in 3 concise sentences:\n\n${content}`;

            showAIResult('Thinking...');
            try {
                const text = await askLocalAI(prompt);
                lastAIResult = text;
                showAIResult(text);
            } catch (e) {
                showAIResult('Error: ' + (e.message || e));
            }
        }

        async function askCustomPrompt() {
            const p = document.getElementById('ai-prompt')?.value.trim();
            if (!p) return alert('Enter a prompt first');
            showAIResult('Thinking...');
            try {
                const text = await askLocalAI(p);
                lastAIResult = text;
                showAIResult(text);
            } catch (e) {
                showAIResult('Error: ' + (e.message || e));
            }
        }

        function insertAIResult() {
            if (!lastAIResult) return alert('No AI result to insert');

            const textBox = document.createElement('div');
            textBox.className = 'text-box placed';
            textBox.contentEditable = true;
            textBox.style.position = 'absolute';
            textBox.style.left = (200) + 'px';
            textBox.style.top = (200) + 'px';
            textBox.style.fontFamily = state.font;
            textBox.style.fontSize = state.fontSize + 'px';
            textBox.style.color = state.color;
            textBox.style.minWidth = '240px';
            textBox.style.minHeight = '40px';
            textBox.innerText = lastAIResult;
            addTextBoxSelectHandler(textBox);
            textLayer.appendChild(textBox);
            setTimeout(() => textBox.focus(), 10);
            saveToUndoStack();
            markUnsaved();
        }
    </script>
</body>
</html>
