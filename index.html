<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notes</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=Georgia&family=Courier+Prime&family=Comic+Neue&family=Playfair+Display&family=Roboto+Mono&family=Lora:ital,wght@0,400;0,600;1,400&family=Merriweather:ital,wght@0,400;0,700;1,400&family=Open+Sans:wght@300;400;600&family=Montserrat:wght@300;400;500;600&family=Poppins:wght@300;400;500;600&family=Raleway:wght@300;400;500;600&family=Source+Code+Pro:wght@400;500&family=Fira+Code:wght@400;500&family=Dancing+Script:wght@400;500;600&family=Pacifico&family=Caveat:wght@400;500;600&family=Architects+Daughter&family=Patrick+Hand&family=Shadows+Into+Light&family=Permanent+Marker&family=Satisfy&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            display: flex;
            height: 100vh;
            background: #fafafa;
            color: #333;
            overflow: hidden;
            transition: background 0.3s, color 0.3s;
        }

        /* Dark Mode Styles */
        body.dark-mode {
            background: #1a1a1a;
            color: #e0e0e0;
        }

        body.dark-mode .sidebar {
            background: #222;
            border-right-color: #333;
        }

        body.dark-mode .sidebar-header {
            border-bottom-color: #333;
        }

        body.dark-mode .sidebar-header h1 {
            color: #e0e0e0;
        }

        body.dark-mode .section-title {
            color: #888;
        }

        body.dark-mode .add-btn {
            color: #aaa;
            border-color: #444;
        }

        body.dark-mode .add-btn:hover {
            background: #e0e0e0;
            color: #222;
            border-color: #e0e0e0;
        }

        body.dark-mode .notebook-header:hover {
            background: #2a2a2a;
        }

        body.dark-mode .notebook-header.active {
            background: #333;
        }

        body.dark-mode .notebook-name {
            color: #e0e0e0;
        }

        body.dark-mode .note-item {
            color: #ccc;
        }

        body.dark-mode .note-item:hover {
            background: #2a2a2a;
        }

        body.dark-mode .note-item.active {
            background: #333;
            color: #fff;
        }

        body.dark-mode .main-content {
            background: #1a1a1a;
        }

        body.dark-mode .toolbar {
            background: #222;
            border-bottom-color: #333;
        }

        body.dark-mode .tool-btn {
            color: #ccc;
        }

        body.dark-mode .tool-btn:hover {
            background: #333;
        }

        body.dark-mode .tool-btn.active {
            background: #444;
            color: #fff;
        }

        body.dark-mode .toolbar-label {
            color: #888;
        }

        body.dark-mode .toolbar-divider {
            background: #333;
        }

        body.dark-mode .font-select {
            background: #333;
            border-color: #444;
            color: #e0e0e0;
        }

        body.dark-mode .canvas-container {
            background: #2a2a2a;
        }

        body.dark-mode .drawing-canvas {
            background: #2a2a2a;
        }

        body.dark-mode .grid-overlay {
            background-image: radial-gradient(circle, #555 1px, transparent 1px);
        }

        body.dark-mode .text-box {
            border-color: #666;
            color: #e0e0e0;
        }

        body.dark-mode .text-box:focus {
            border-color: #888;
        }

        body.dark-mode .text-box.selected {
            border-color: #007AFF !important;
            background: rgba(0, 122, 255, 0.1);
        }

        body.dark-mode .status-bar {
            background: #222;
            border-top-color: #333;
            color: #888;
        }

        body.dark-mode .modal-content,
        body.dark-mode .version-modal {
            background: #2a2a2a;
        }

        body.dark-mode .modal-content h2,
        body.dark-mode .version-modal-header h3 {
            color: #e0e0e0;
        }

        body.dark-mode .modal-input {
            background: #333;
            border-color: #444;
            color: #e0e0e0;
        }

        body.dark-mode .modal-btn.secondary {
            background: #444;
            color: #e0e0e0;
        }

        body.dark-mode .version-modal-header {
            border-bottom-color: #444;
        }

        body.dark-mode .version-item:hover {
            background: #333;
        }

        body.dark-mode .version-time {
            color: #e0e0e0;
        }

        body.dark-mode .home-page {
            background: #1a1a1a;
        }

        body.dark-mode .home-section-title {
            color: #e0e0e0;
        }

        body.dark-mode .pinned-note-card,
        body.dark-mode .notebook-card {
            background: #2a2a2a;
            border-color: #333;
        }

        body.dark-mode .pinned-note-card:hover,
        body.dark-mode .notebook-card:hover {
            border-color: #555;
            background: #333;
        }

        body.dark-mode .pinned-note-title,
        body.dark-mode .notebook-card-name {
            color: #e0e0e0;
        }

        body.dark-mode .pinned-note-notebook,
        body.dark-mode .notebook-card-count {
            color: #888;
        }

        body.dark-mode .nav-home {
            color: #ccc;
        }

        body.dark-mode .nav-home:hover {
            background: #333;
        }

        body.dark-mode .nav-home.active {
            background: #333;
            color: #fff;
        }

        body.dark-mode .eraser-cursor {
            background: rgba(42, 42, 42, 0.8);
            border-color: #666;
        }

        /* Status Badge Styles */
        .status-badge {
            display: inline-block;
            padding: 1px 6px;
            border-radius: 3px;
            font-size: 0.6rem;
            font-weight: 500;
            letter-spacing: 0.2px;
            margin-left: 8px;
            margin-right: 4px;
            vertical-align: middle;
            opacity: 0.85;
        }

        .status-badge.in-progress {
            background: rgba(245, 158, 11, 0.15);
            color: #D97706;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }

        .status-badge.finished {
            background: rgba(16, 185, 129, 0.15);
            color: #059669;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .status-badge.needs-review {
            background: rgba(59, 130, 246, 0.15);
            color: #2563EB;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        body.dark-mode .status-badge.in-progress {
            background: rgba(245, 158, 11, 0.15);
            color: #FBBF24;
            border-color: rgba(245, 158, 11, 0.4);
        }

        body.dark-mode .status-badge.finished {
            background: rgba(16, 185, 129, 0.15);
            color: #34D399;
            border-color: rgba(16, 185, 129, 0.4);
        }

        body.dark-mode .status-badge.needs-review {
            background: rgba(59, 130, 246, 0.15);
            color: #60A5FA;
            border-color: rgba(59, 130, 246, 0.4);
        }

        /* Status badge on pinned cards */
        .pinned-card .status-badge {
            display: block;
            margin-left: 0;
            margin-top: 8px;
            margin-bottom: 4px;
            font-size: 0.65rem;
            width: fit-content;
        }

        /* Status Selector */
        .status-select {
            background: #fff;
            color: #444;
            border: 1px solid #e0e0e0;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            font-family: inherit;
            min-width: 140px;
        }

        .status-select:focus {
            outline: none;
            border-color: #333;
        }

        body.dark-mode .status-select {
            background: #333;
            border-color: #444;
            color: #e0e0e0;
        }

        body.dark-mode .status-select:focus {
            border-color: #666;
        }

        /* Outline Sidebar */
        .outline-sidebar {
            position: absolute;
            right: 0;
            top: 0;
            width: 220px;
            height: 100%;
            background: #fafafa;
            border-left: 1px solid #e8e8e8;
            padding: 16px;
            overflow-y: auto;
            z-index: 10;
            display: none;
        }

        .outline-sidebar.visible {
            display: block;
        }

        .outline-header {
            font-size: 0.7rem;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
            margin-bottom: 12px;
        }

        .outline-item {
            padding: 6px 8px;
            font-size: 0.8rem;
            color: #666;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.15s ease;
            margin-bottom: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .outline-item:hover {
            background: #f0f0f0;
            color: #333;
        }

        .outline-item.h1 {
            font-size: 0.85rem;
            font-weight: 600;
            padding-left: 8px;
        }

        .outline-item.h2 {
            font-size: 0.8rem;
            font-weight: 500;
            padding-left: 20px;
        }

        .outline-item.h3 {
            font-size: 0.75rem;
            padding-left: 32px;
        }

        body.dark-mode .outline-sidebar {
            background: #1a1a1a;
            border-left-color: #333;
        }

        body.dark-mode .outline-header {
            color: #888;
        }

        body.dark-mode .outline-item {
            color: #ccc;
        }

        body.dark-mode .outline-item:hover {
            background: #2a2a2a;
            color: #fff;
        }

        /* Header text styles on canvas */
        .text-box.header-1 {
            font-size: 32px !important;
            font-weight: 700;
            line-height: 1.2;
        }

        .text-box.header-2 {
            font-size: 24px !important;
            font-weight: 600;
            line-height: 1.3;
        }

        .text-box.header-3 {
            font-size: 18px !important;
            font-weight: 600;
            line-height: 1.4;
        }

        /* Header nav sidebar (Notion-style, right side) */
        .header-nav {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: flex-end;
            pointer-events: auto;
            padding: 10px 6px;
            background: transparent;
        }

        .header-nav-item {
            height: 3px;
            border-radius: 2px;
            background: rgba(0,0,0,0.18);
            cursor: pointer;
            transition: background 0.15s, width 0.15s;
        }

        .header-nav-item.h1 {
            width: 28px;
        }

        .header-nav-item.h2 {
            width: 20px;
        }

        .header-nav-item.h3 {
            width: 12px;
        }

        .header-nav-item:hover {
            background: rgba(0,122,255,0.7);
        }

        .header-nav-item.active {
            background: #007AFF;
        }

        .header-preview {
            position: fixed;
            z-index: 30;
            max-width: 260px;
            background: #fff;
            color: #222;
            border: 1px solid #e0e0e0;
            padding: 8px 12px;
            border-radius: 6px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.12);
            font-size: 0.8rem;
            pointer-events: none;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        body.dark-mode .header-nav-item {
            background: rgba(255,255,255,0.18);
        }

        body.dark-mode .header-nav-item:hover {
            background: rgba(96,165,250,0.7);
        }

        body.dark-mode .header-nav-item.active {
            background: #60A5FA;
        }

        body.dark-mode .header-preview {
            background: #222;
            color: #e0e0e0;
            border-color: #333;
        }

        /* Import modal */
        .import-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .import-modal.active {
            display: flex;
        }

        .import-modal-content {
            background: #fff;
            border-radius: 12px;
            padding: 24px;
            min-width: 320px;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
        }

        .import-modal-content h3 {
            margin: 0 0 16px 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .import-progress {
            background: #f0f0f0;
            border-radius: 6px;
            height: 8px;
            overflow: hidden;
            margin: 12px 0;
        }

        .import-progress-bar {
            background: #007AFF;
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }

        .import-status {
            font-size: 0.85rem;
            color: #666;
            margin-top: 8px;
        }

        .import-modal-buttons {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            justify-content: flex-end;
        }

        .import-modal-btn {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .import-modal-btn.primary {
            background: #007AFF;
            color: #fff;
        }

        .import-modal-btn.secondary {
            background: #f0f0f0;
            color: #333;
        }

        body.dark-mode .import-modal-content {
            background: #2a2a2a;
        }

        body.dark-mode .import-modal-content h3 {
            color: #e0e0e0;
        }

        body.dark-mode .import-progress {
            background: #444;
        }

        body.dark-mode .import-status {
            color: #aaa;
        }

        body.dark-mode .import-modal-btn.secondary {
            background: #444;
            color: #e0e0e0;
        }

        /* Sidebar Styles */
        .sidebar {
            width: 260px;
            background: #fff;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #e8e8e8;
        }

        .sidebar-header {
            padding: 24px 20px;
            border-bottom: 1px solid #e8e8e8;
        }

        .sidebar-header h1 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
            letter-spacing: -0.3px;
        }

        .notebooks-section {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .section-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 4px;
            font-size: 0.7rem;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .add-btn {
            background: transparent;
            color: #666;
            border: 1px solid #e0e0e0;
            width: 22px;
            height: 22px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .add-btn:hover {
            background: #333;
            color: #fff;
            border-color: #333;
        }

        .notebook {
            margin-bottom: 2px;
        }

        .notebook-header {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            background: transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .notebook-header:hover {
            background: #f5f5f5;
        }

        .notebook-header.active {
            background: #f0f0f0;
        }

        .notebook-icon {
            margin-right: 10px;
            font-size: 0.9rem;
            opacity: 0.6;
        }

        .notebook-name {
            flex: 1;
            font-size: 0.875rem;
            font-weight: 450;
            color: #444;
        }

        .notebook-toggle {
            color: #bbb;
            transition: transform 0.2s ease;
            font-size: 0.7rem;
        }

        .notebook-toggle.open {
            transform: rotate(90deg);
        }

        .notes-list {
            margin-left: 12px;
            display: none;
            border-left: 1px solid #eee;
            margin-top: 2px;
        }

        .notes-list.open {
            display: block;
        }

        .note-item {
            padding: 5px 12px 5px 12px;
            margin: 0.5px 0;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            color: #666;
            transition: all 0.15s ease;
            display: block;
        }

        .note-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .note-item-status-row {
            display: flex;
            justify-content: center;
            margin-top: 3px;
            margin-bottom: 0;
        }

        .note-item-status-row .status-badge {
            margin: 0;
        }

        .note-item:hover {
            background: #f5f5f5;
            color: #333;
        }

        .note-item.active {
            background: #e8e8e8;
            color: #333;
            font-weight: 500;
        }

        .delete-btn {
            opacity: 0;
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.15s ease;
        }

        .delete-btn:hover {
            color: #e53935;
            background: rgba(229, 57, 53, 0.1);
        }

        .note-item:hover .delete-btn,
        .notebook-header:hover .delete-btn {
            opacity: 1;
        }

        /* Nested Notes */
        .note-item-container {
            position: relative;
        }

        .note-item .note-toggle {
            font-size: 0.75rem;
            margin-right: 8px;
            transition: transform 0.2s, color 0.15s, background 0.15s;
            color: #666;
            background: #f0f0f0;
            width: 18px;
            height: 18px;
            border-radius: 4px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .note-item .note-toggle:hover {
            background: #e0e0e0;
            color: #333;
        }

        .note-item .note-toggle.open {
            transform: rotate(90deg);
        }

        .note-item .note-toggle.hidden {
            visibility: hidden;
        }

        body.dark-mode .note-item .note-toggle {
            color: #aaa;
            background: #3a3a3a;
        }

        body.dark-mode .note-item .note-toggle:hover {
            background: #4a4a4a;
            color: #fff;
        }

        .sub-notes-list {
            display: none;
            padding-left: 16px;
            border-left: 1px solid #e0e0e0;
            margin-left: 12px;
        }

        .sub-notes-list.open {
            display: block;
        }

        body.dark-mode .sub-notes-list {
            border-left-color: #444;
        }

        .note-item .add-subnote-btn {
            opacity: 0;
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 0.7rem;
            padding: 2px 5px;
            border-radius: 4px;
            transition: all 0.15s ease;
            margin-right: 4px;
        }

        .note-item:hover .add-subnote-btn {
            opacity: 1;
        }

        .note-item .add-subnote-btn:hover {
            color: #333;
            background: rgba(0,0,0,0.05);
        }

        body.dark-mode .note-item .add-subnote-btn:hover {
            color: #fff;
            background: rgba(255,255,255,0.1);
        }

        /* Breadcrumb Navigation */
        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: #666;
            padding: 8px 16px;
            background: #f8f8f8;
            border-bottom: 1px solid #e8e8e8;
        }

        body.dark-mode .breadcrumb {
            background: #252525;
            border-bottom-color: #333;
            color: #888;
        }

        .breadcrumb-item {
            cursor: pointer;
            transition: color 0.15s;
        }

        .breadcrumb-item:hover {
            color: #333;
        }

        body.dark-mode .breadcrumb-item:hover {
            color: #fff;
        }

        .breadcrumb-separator {
            color: #ccc;
        }

        body.dark-mode .breadcrumb-separator {
            color: #555;
        }

        .breadcrumb-current {
            color: #333;
            font-weight: 500;
        }

        body.dark-mode .breadcrumb-current {
            color: #e0e0e0;
        }

        /* Sub-note Links on Canvas (Notion-style) */
        .subnote-block {
            position: absolute;
            display: flex;
            align-items: center;
            padding: 12px 16px;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
            pointer-events: auto;
            z-index: 5;
            min-width: 180px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        }

        .subnote-block:hover {
            background: #f8f8f8;
            border-color: #333;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            transform: translateY(-1px);
        }

        .subnote-block-icon {
            width: 24px;
            height: 24px;
            background: #f0f0f0;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-size: 14px;
        }

        .subnote-block-content {
            flex: 1;
            min-width: 0;
        }

        .subnote-block-name {
            font-size: 0.9rem;
            font-weight: 500;
            color: #333;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .subnote-block-hint {
            font-size: 0.7rem;
            color: #999;
            margin-top: 2px;
        }

        .subnote-block-arrow {
            color: #ccc;
            margin-left: 8px;
            font-size: 1rem;
        }

        body.dark-mode .subnote-block {
            background: #2a2a2a;
            border-color: #444;
        }

        body.dark-mode .subnote-block:hover {
            background: #333;
            border-color: #666;
        }

        body.dark-mode .subnote-block-icon {
            background: #3a3a3a;
        }

        body.dark-mode .subnote-block-name {
            color: #e0e0e0;
        }

        body.dark-mode .subnote-block-hint {
            color: #666;
        }

        body.dark-mode .subnote-block-arrow {
            color: #555;
        }

        /* Media Embed Blocks */
        .media-embed {
            position: absolute;
            background: #fff;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
            pointer-events: auto;
            z-index: 3;
            min-width: 200px;
            min-height: 80px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            resize: none;
        }

        .media-embed:hover {
            border-color: #999;
        }

        .media-embed.selected {
            border-color: #007AFF;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.2);
        }

        /* Resize handle */
        .media-embed-resize {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 50%, rgba(0,0,0,0.1) 50%);
            border-radius: 0 0 6px 0;
            z-index: 10;
        }

        .media-embed:hover .media-embed-resize {
            background: linear-gradient(135deg, transparent 50%, rgba(0,0,0,0.25) 50%);
        }

        .media-embed-resize::after {
            content: '';
            position: absolute;
            bottom: 3px;
            right: 3px;
            width: 8px;
            height: 8px;
            border-right: 2px solid rgba(0,0,0,0.3);
            border-bottom: 2px solid rgba(0,0,0,0.3);
        }

        body.dark-mode .media-embed-resize {
            background: linear-gradient(135deg, transparent 50%, rgba(255,255,255,0.1) 50%);
        }

        body.dark-mode .media-embed:hover .media-embed-resize {
            background: linear-gradient(135deg, transparent 50%, rgba(255,255,255,0.25) 50%);
        }

        body.dark-mode .media-embed-resize::after {
            border-right-color: rgba(255,255,255,0.4);
            border-bottom-color: rgba(255,255,255,0.4);
        }

        .media-embed-content {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            overflow: hidden;
        }

        .media-embed img {
            width: 100%;
            height: 100%;
            object-fit: fill;
            display: block;
        }

        .media-embed video {
            width: 100%;
            height: 100%;
            object-fit: fill;
        }

        .media-embed iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        .media-embed-controls {
            position: absolute;
            top: 4px;
            right: 4px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .media-embed:hover .media-embed-controls {
            opacity: 1;
        }

        .media-embed-btn {
            width: 24px;
            height: 24px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .media-embed-btn:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        .media-embed-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: #666;
            font-size: 0.85rem;
        }

        .media-embed-error {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: #e53935;
            font-size: 0.85rem;
        }

        body.dark-mode .media-embed {
            background: #2a2a2a;
            border-color: #444;
        }

        body.dark-mode .media-embed:hover {
            border-color: #666;
        }

        body.dark-mode .media-embed-content {
            background: #333;
        }

        body.dark-mode .media-embed-loading,
        body.dark-mode .media-embed-error {
            color: #999;
        }

        /* Audio embed styles */
        .media-embed audio {
            width: 100%;
            margin-top: 10px;
        }

        .media-embed-audio-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        /* Drag and drop overlay */
        .canvas-container.drag-over {
            position: relative;
        }

        .canvas-container.drag-over::after {
            content: 'Drop media here';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 122, 255, 0.1);
            border: 3px dashed #007AFF;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: #007AFF;
            font-weight: 500;
            z-index: 1000;
            pointer-events: none;
        }

        body.dark-mode .canvas-container.drag-over::after {
            background: rgba(0, 122, 255, 0.2);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #fafafa;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            align-items: center;
            padding: 12px 24px;
            background: #fff;
            border-bottom: 1px solid #e8e8e8;
            gap: 24px;
            flex-wrap: wrap;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: #e8e8e8;
            margin: 0 8px;
        }

        .tool-btn {
            background: transparent;
            border: 1px solid transparent;
            color: #666;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 0.8rem;
            font-weight: 450;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .tool-btn:hover {
            background: #f5f5f5;
            color: #333;
        }

        .tool-btn.active {
            background: #333;
            color: #fff;
        }

        .tool-btn svg {
            width: 16px;
            height: 16px;
        }

        .color-picker {
            width: 32px;
            height: 32px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            background: none;
            padding: 2px;
        }

        .thickness-slider {
            width: 80px;
            accent-color: #333;
            height: 4px;
        }

        .font-select {
            background: #fff;
            color: #444;
            border: 1px solid #e0e0e0;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            font-family: inherit;
        }

        .font-select:focus {
            outline: none;
            border-color: #333;
        }

        .zoom-display {
            background: #f5f5f5;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            min-width: 50px;
            text-align: center;
            color: #666;
            font-weight: 500;
        }

        .toolbar-label {
            font-size: 0.7rem;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            font-weight: 500;
        }

        /* Canvas Area */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #fff;
        }

        .canvas-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform-origin: center center;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
            visibility: hidden;
            background-image: radial-gradient(circle, #b0b0b0 1px, transparent 1px);
            background-size: 30px 30px;
        }

        .grid-overlay.visible {
            visibility: visible;
        }

        .grid-canvas {
            display: none;
        }

        .drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            background: #fff;
            z-index: 1;
        }

        .eraser-cursor {
            position: fixed;
            border-radius: 50%;
            border: 2px solid #999;
            background: rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 9999;
            transform: translate(-50%, -50%);
            display: none;
        }

        .eraser-cursor.visible {
            display: block;
        }

        /* Version History Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .modal-overlay.hidden {
            display: none;
        }

        .version-modal {
            background: #fff;
            border-radius: 12px;
            width: 400px;
            max-height: 70vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .version-modal-header {
            padding: 20px;
            border-bottom: 1px solid #e8e8e8;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .version-modal-header h3 {
            font-size: 1rem;
            font-weight: 600;
        }

        .modal-close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
            padding: 0;
            line-height: 1;
        }

        .modal-close-btn:hover {
            color: #333;
        }

        .version-list {
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
        }

        .version-item {
            padding: 12px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .version-item:hover {
            background: #f5f5f5;
        }

        .version-time {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .version-restore-btn {
            background: #333;
            color: #fff;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .version-item:hover .version-restore-btn {
            opacity: 1;
        }

        .version-restore-btn:hover {
            background: #555;
        }

        .no-versions {
            padding: 40px 20px;
            text-align: center;
            color: #999;
        }

        .tool-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Media Dropdown Menu */
        .media-dropdown {
            position: relative;
            display: inline-block;
        }

        .media-dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #fff;
            min-width: 140px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            z-index: 100;
            overflow: hidden;
            margin-top: 4px;
        }

        .media-dropdown-content.show {
            display: block;
        }

        .media-dropdown-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            cursor: pointer;
            font-size: 0.85rem;
            color: #333;
            transition: background 0.15s ease;
            border: none;
            background: transparent;
            width: 100%;
            text-align: left;
        }

        .media-dropdown-item:hover {
            background: #f5f5f5;
        }

        .media-dropdown-item svg {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }

        body.dark-mode .media-dropdown-content {
            background: #2a2a2a;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        body.dark-mode .media-dropdown-item {
            color: #e0e0e0;
        }

        body.dark-mode .media-dropdown-item:hover {
            background: #3a3a3a;
        }

        /* Link Embed Modal */
        .link-embed-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .link-embed-modal.show {
            display: flex;
        }

        .link-embed-dialog {
            background: #fff;
            border-radius: 12px;
            padding: 24px;
            width: 400px;
            max-width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .link-embed-dialog h3 {
            margin: 0 0 16px 0;
            font-size: 1.1rem;
            color: #333;
        }

        .link-embed-dialog input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 0.95rem;
            margin-bottom: 16px;
            box-sizing: border-box;
        }

        .link-embed-dialog input:focus {
            outline: none;
            border-color: #007AFF;
        }

        .link-embed-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .link-embed-btn {
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.15s ease;
        }

        .link-embed-btn.cancel {
            background: #e0e0e0;
            color: #333;
        }

        .link-embed-btn.cancel:hover {
            background: #d0d0d0;
        }

        .link-embed-btn.embed {
            background: #007AFF;
            color: #fff;
        }

        .link-embed-btn.embed:hover {
            background: #0066DD;
        }

        body.dark-mode .link-embed-dialog {
            background: #2a2a2a;
        }

        body.dark-mode .link-embed-dialog h3 {
            color: #e0e0e0;
        }

        body.dark-mode .link-embed-dialog input {
            background: #333;
            border-color: #444;
            color: #e0e0e0;
        }

        body.dark-mode .link-embed-dialog input:focus {
            border-color: #007AFF;
        }

        body.dark-mode .link-embed-btn.cancel {
            background: #444;
            color: #e0e0e0;
        }

        body.dark-mode .link-embed-btn.cancel:hover {
            background: #555;
        }

        .text-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }

        .text-box {
            position: absolute;
            background: transparent;
            border: 1.5px dashed #999;
            padding: 8px;
            min-width: 100px;
            min-height: 30px;
            outline: none;
            pointer-events: auto;
            resize: both;
            overflow: auto;
            border-radius: 4px;
            z-index: 2;
        }

        .text-box:focus {
            border-color: #333;
        }

        .text-box.placed {
            border: none;
        }

        .text-box.selected {
            border: 2px solid #007AFF !important;
            background: rgba(0, 122, 255, 0.05);
        }

        /* Status Bar */
        .status-bar {
            padding: 10px 24px;
            background: #fff;
            font-size: 0.75rem;
            color: #999;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid #e8e8e8;
        }

        .save-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .save-indicator.saving {
            color: #f59e0b;
            background: rgba(245, 158, 11, 0.1);
        }

        .save-indicator.saving .save-dot {
            animation: pulse 1s ease-in-out infinite;
        }

        .save-indicator.saved {
            color: #10b981;
        }

        .save-indicator.unsaved {
            color: #999;
        }

        .save-indicator.just-saved {
            color: #10b981;
            background: rgba(16, 185, 129, 0.1);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-2px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .save-indicator.just-saved {
            animation: fadeIn 0.3s ease;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(4px);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #fff;
            padding: 32px;
            border-radius: 16px;
            min-width: 340px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.15);
        }

        .modal-content h2 {
            margin-bottom: 24px;
            color: #333;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .modal-input {
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 24px;
            background: #fafafa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            color: #333;
            font-size: 0.9rem;
            font-family: inherit;
            transition: border-color 0.15s ease;
        }

        .modal-input:focus {
            outline: none;
            border-color: #333;
            background: #fff;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            font-family: inherit;
            transition: all 0.15s ease;
        }

        .modal-btn.primary {
            background: #333;
            color: white;
        }

        .modal-btn.primary:hover {
            background: #555;
        }

        .modal-btn.secondary {
            background: #f5f5f5;
            color: #666;
        }

        .modal-btn.secondary:hover {
            background: #e8e8e8;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #ddd;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #ccc;
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #999;
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 16px;
            opacity: 0.4;
        }

        .empty-state p {
            font-size: 0.9rem;
            font-weight: 400;
        }

        /* Sidebar Navigation */
        .sidebar-nav {
            padding: 16px;
            border-bottom: 1px solid #e8e8e8;
        }

        .nav-item {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.875rem;
            color: #666;
            transition: all 0.15s ease;
            gap: 10px;
        }

        .nav-item:hover {
            background: #f5f5f5;
            color: #333;
        }

        .nav-item.active {
            background: #333;
            color: #fff;
        }

        .nav-item svg {
            width: 16px;
            height: 16px;
        }

        /* Home Page */
        .home-page {
            flex: 1;
            overflow-y: auto;
            padding: 40px;
            background: #fafafa;
        }

        .home-page.hidden {
            display: none;
        }

        .home-header {
            margin-bottom: 32px;
        }

        .home-header h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .home-header p {
            color: #999;
            font-size: 0.9rem;
        }

        .home-section {
            margin-bottom: 40px;
        }

        .home-section-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #999;
            margin-bottom: 16px;
            font-weight: 500;
        }

        .pinned-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 16px;
        }

        .pinned-card {
            background: #fff;
            border: 1px solid #e8e8e8;
            border-radius: 12px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
        }

        .pinned-card:hover {
            border-color: #ddd;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        .pinned-card-preview {
            width: 100%;
            height: 100px;
            background: #f5f5f5;
            border-radius: 8px;
            margin-bottom: 12px;
            overflow: hidden;
        }

        .pinned-card-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .pinned-card-title {
            font-size: 0.9rem;
            font-weight: 500;
            color: #333;
            margin-bottom: 4px;
        }

        .pinned-card-notebook {
            font-size: 0.75rem;
            color: #999;
        }

        .unpin-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: all 0.15s ease;
            font-size: 0.8rem;
        }

        .pinned-card:hover .unpin-btn {
            opacity: 1;
        }

        .unpin-btn:hover {
            background: #fee2e2;
            border-color: #fecaca;
            color: #dc2626;
        }

        .notebooks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 16px;
        }

        .notebook-card {
            background: #fff;
            border: 1px solid #e8e8e8;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .notebook-card:hover {
            border-color: #ddd;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        .notebook-card-icon {
            font-size: 1.5rem;
            margin-bottom: 12px;
            opacity: 0.6;
        }

        .notebook-card-name {
            font-size: 0.9rem;
            font-weight: 500;
            color: #333;
            margin-bottom: 4px;
        }

        .notebook-card-count {
            font-size: 0.75rem;
            color: #999;
        }

        .empty-pinned {
            background: #f5f5f5;
            border: 2px dashed #e0e0e0;
            border-radius: 12px;
            padding: 32px;
            text-align: center;
            color: #999;
        }

        .empty-pinned p {
            font-size: 0.85rem;
        }

        /* Pin button in note item */
        .pin-btn {
            opacity: 0;
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 4px;
            transition: all 0.15s ease;
            margin-right: 4px;
        }

        .pin-btn:hover {
            color: #f59e0b;
            background: rgba(245, 158, 11, 0.1);
        }

        .pin-btn.pinned {
            opacity: 1;
            color: #f59e0b;
        }

        .note-item:hover .pin-btn {
            opacity: 1;
        }
    </style>
</head>
<body>
    <!-- Sidebar -->
    <div class="sidebar">
        <div class="sidebar-header">
            <h1>Notes</h1>
        </div>
        <div class="sidebar-nav">
            <div class="nav-item active" id="nav-home" onclick="showHomePage()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
                Home
            </div>
        </div>
        <div class="notebooks-section">
            <div class="section-title">
                <span>Notebooks</span>
                <button class="add-btn" onclick="triggerEvernoteImport()" title="Import from Evernote"></button>
                <button class="add-btn" onclick="showModal('notebook')" title="New Notebook">+</button>
            </div>
            <div id="notebooks-container"></div>
            <input type="file" id="evernote-import" accept=".enex" style="display:none" onchange="handleEvernoteImport(event)">
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Home Page -->
        <div class="home-page" id="home-page">
            <div class="home-header">
                <h2>Welcome back</h2>
                <p>Your notebooks and pinned notes</p>
            </div>
            
            <div class="home-section">
                <div class="home-section-title">Pinned Notes</div>
                <div id="pinned-container" class="pinned-grid"></div>
            </div>
            
            <div class="home-section">
                <div class="home-section-title">All Notebooks</div>
                <div id="notebooks-home-container" class="notebooks-grid"></div>
            </div>
        </div>
        <div class="toolbar" id="toolbar" style="display: none;">
            <div class="toolbar-group">
                <button class="tool-btn active" id="draw-btn" onclick="setTool('draw')" title="Draw">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/></svg>
                    Draw
                </button>
                <button class="tool-btn" id="select-btn" onclick="setTool('select')" title="Select (S)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/><path d="M13 13l6 6"/></svg>
                    Select
                </button>
                <button class="tool-btn" id="erase-btn" onclick="setTool('erase')" title="Eraser">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 20H7L3 16c-.6-.6-.6-1.5 0-2.1l10-10c.6-.6 1.5-.6 2.1 0l6 6c.6.6.6 1.5 0 2.1L13 20"/><path d="M6 11l8 8"/></svg>
                    Erase
                </button>
                <button class="tool-btn" id="text-btn" onclick="setTool('text')" title="Text">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 7V4h16v3"/><path d="M9 20h6"/><path d="M12 4v16"/></svg>
                    Text
                </button>
                <button class="tool-btn" id="pan-btn" onclick="setTool('pan')" title="Pan">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0"/><path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2"/><path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8"/><path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/></svg>
                    Pan
                </button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <span class="toolbar-label">Headers</span>
                <button class="tool-btn header-btn" id="header-1-btn" onclick="insertHeader(1)" title="Header 1 - Click then click canvas to place">H1</button>
                <button class="tool-btn header-btn" id="header-2-btn" onclick="insertHeader(2)" title="Header 2 - Click then click canvas to place">H2</button>
                <button class="tool-btn header-btn" id="header-3-btn" onclick="insertHeader(3)" title="Header 3 - Click then click canvas to place">H3</button>
                <button class="tool-btn" onclick="toggleOutline()" id="outline-btn" title="Toggle Outline">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px">
                        <line x1="8" y1="6" x2="21" y2="6"/>
                        <line x1="8" y1="12" x2="21" y2="12"/>
                        <line x1="8" y1="18" x2="21" y2="18"/>
                        <line x1="3" y1="6" x2="3.01" y2="6"/>
                        <line x1="3" y1="12" x2="3.01" y2="12"/>
                        <line x1="3" y1="18" x2="3.01" y2="18"/>
                    </svg>
                </button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <span class="toolbar-label">Color</span>
                <input type="color" class="color-picker" id="color-picker" value="#333333">
            </div>
            
            <div class="toolbar-group">
                <span class="toolbar-label">Size</span>
                <input type="range" class="thickness-slider" id="thickness-slider" min="1" max="50" value="3">
                <span id="thickness-value" style="font-size: 0.75rem; color: #666; min-width: 30px;">3px</span>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <span class="toolbar-label">Font</span>
                <select class="font-select" id="font-select">
                    <optgroup label="Sans Serif">
                        <option value="'Inter', sans-serif" style="font-family: 'Inter', sans-serif">Inter</option>
                        <option value="'Open Sans', sans-serif" style="font-family: 'Open Sans', sans-serif">Open Sans</option>
                        <option value="'Montserrat', sans-serif" style="font-family: 'Montserrat', sans-serif">Montserrat</option>
                        <option value="'Poppins', sans-serif" style="font-family: 'Poppins', sans-serif">Poppins</option>
                        <option value="'Raleway', sans-serif" style="font-family: 'Raleway', sans-serif">Raleway</option>
                    </optgroup>
                    <optgroup label="Serif">
                        <option value="Georgia, serif" style="font-family: Georgia, serif">Georgia</option>
                        <option value="'Playfair Display', serif" style="font-family: 'Playfair Display', serif">Playfair</option>
                        <option value="'Lora', serif" style="font-family: 'Lora', serif">Lora</option>
                        <option value="'Merriweather', serif" style="font-family: 'Merriweather', serif">Merriweather</option>
                    </optgroup>
                    <optgroup label="Monospace">
                        <option value="'Courier Prime', monospace" style="font-family: 'Courier Prime', monospace">Courier</option>
                        <option value="'Roboto Mono', monospace" style="font-family: 'Roboto Mono', monospace">Roboto Mono</option>
                        <option value="'Source Code Pro', monospace" style="font-family: 'Source Code Pro', monospace">Source Code Pro</option>
                        <option value="'Fira Code', monospace" style="font-family: 'Fira Code', monospace">Fira Code</option>
                    </optgroup>
                    <optgroup label="Handwriting">
                        <option value="'Comic Neue', cursive" style="font-family: 'Comic Neue', cursive">Comic Neue</option>
                        <option value="'Dancing Script', cursive" style="font-family: 'Dancing Script', cursive">Dancing Script</option>
                        <option value="'Pacifico', cursive" style="font-family: 'Pacifico', cursive">Pacifico</option>
                        <option value="'Caveat', cursive" style="font-family: 'Caveat', cursive">Caveat</option>
                        <option value="'Architects Daughter', cursive" style="font-family: 'Architects Daughter', cursive">Architects Daughter</option>
                        <option value="'Patrick Hand', cursive" style="font-family: 'Patrick Hand', cursive">Patrick Hand</option>
                        <option value="'Shadows Into Light', cursive" style="font-family: 'Shadows Into Light', cursive">Shadows Into Light</option>
                        <option value="'Permanent Marker', cursive" style="font-family: 'Permanent Marker', cursive">Permanent Marker</option>
                        <option value="'Satisfy', cursive" style="font-family: 'Satisfy', cursive">Satisfy</option>
                    </optgroup>
                </select>
                <select class="font-select" id="font-size-select">
                    <option value="12">12</option>
                    <option value="16" selected>16</option>
                    <option value="20">20</option>
                    <option value="24">24</option>
                    <option value="32">32</option>
                    <option value="48">48</option>
                </select>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <button class="tool-btn" onclick="zoomOut()"></button>
                <span class="zoom-display" id="zoom-display">100%</span>
                <button class="tool-btn" onclick="zoomIn()">+</button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <button class="tool-btn" id="grid-btn" onclick="toggleGrid()" title="Toggle Grid">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px">
                        <circle cx="4" cy="4" r="1"/><circle cx="12" cy="4" r="1"/><circle cx="20" cy="4" r="1"/>
                        <circle cx="4" cy="12" r="1"/><circle cx="12" cy="12" r="1"/><circle cx="20" cy="12" r="1"/>
                        <circle cx="4" cy="20" r="1"/><circle cx="12" cy="20" r="1"/><circle cx="20" cy="20" r="1"/>
                    </svg>
                    Grid
                </button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <button class="tool-btn" id="undo-btn" onclick="undo()" title="Undo (Ctrl+Z)" disabled>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px">
                        <path d="M3 10h10c4.4 0 8 3.6 8 8v0"/>
                        <polyline points="7 14 3 10 7 6"/>
                    </svg>
                </button>
                <button class="tool-btn" id="redo-btn" onclick="redo()" title="Redo (Ctrl+Y)" disabled>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px">
                        <path d="M21 10H11c-4.4 0-8 3.6-8 8v0"/>
                        <polyline points="17 14 21 10 17 6"/>
                    </svg>
                </button>
                <button class="tool-btn" onclick="showVersionHistory()" title="Version History">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12 6 12 12 16 14"/>
                    </svg>
                </button>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <div class="media-dropdown">
                    <button class="tool-btn" onclick="toggleMediaDropdown(event)" title="Add Media">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                            <circle cx="8.5" cy="8.5" r="1.5"/>
                            <polyline points="21 15 16 10 5 21"/>
                        </svg>
                        Media
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:12px;height:12px;margin-left:2px">
                            <polyline points="6 9 12 15 18 9"/>
                        </svg>
                    </button>
                    <div class="media-dropdown-content" id="media-dropdown">
                        <button class="media-dropdown-item" onclick="showYouTubeDialog()">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                            </svg>
                            YouTube Video
                        </button>
                        <button class="media-dropdown-item" onclick="showLinkEmbedDialog()">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
                                <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
                            </svg>
                            Embed Link
                        </button>
                        <button class="media-dropdown-item" onclick="triggerMediaUpload()">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                <polyline points="17 8 12 3 7 8"/>
                                <line x1="12" y1="3" x2="12" y2="15"/>
                            </svg>
                            Upload File
                        </button>
                    </div>
                </div>
                <input type="file" id="media-upload" accept="image/*,video/*,audio/*" multiple style="display:none" onchange="handleFileUpload(event)">
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <span class="toolbar-label">Status</span>
                <select class="status-select" id="status-select" onchange="updateNoteStatus()">
                    <option value="none">No Status</option>
                    <option value="in-progress"> In Progress</option>
                    <option value="finished"> Finished</option>
                    <option value="needs-review"> Needs Review</option>
                </select>
            </div>
            
            <div class="toolbar-divider"></div>
            
            <div class="toolbar-group">
                <button class="tool-btn" onclick="manualSave()" title="Save (Ctrl+S)">Save</button>
                <button class="tool-btn" onclick="clearCanvas()">Clear</button>
                <button class="tool-btn" onclick="exportNote()">Export</button>
                <button class="tool-btn" id="dark-mode-btn" onclick="toggleDarkMode()" title="Toggle Dark Mode">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                </button>
            </div>
        </div>

        <div class="canvas-container" id="canvas-container" style="display: none;">
            <div class="outline-sidebar" id="outline-sidebar">
                <div class="outline-header">Outline</div>
                <div id="outline-content"></div>
            </div>
            <!-- Header navigation sidebar (Notion-style) -->
            <div class="header-nav" id="header-nav"></div>
            <div class="header-preview" id="header-preview"></div>
            <div class="eraser-cursor" id="eraser-cursor"></div>
            <div class="empty-state" id="empty-state" style="display: none;">
                <div class="empty-state-icon"></div>
                <p>Create a notebook to get started</p>
            </div>
            <div class="canvas-wrapper" id="canvas-wrapper" style="display: none;">
                <canvas class="grid-canvas" id="grid-canvas"></canvas>
                <canvas class="drawing-canvas" id="drawing-canvas"></canvas>
                <div class="grid-overlay" id="grid-overlay"></div>
                <div class="text-layer" id="text-layer"></div>
            </div>
        </div>

        <!-- Link Embed Modal -->
        <div class="link-embed-modal" id="link-embed-modal">
            <div class="link-embed-dialog">
                <h3 id="link-embed-title">Embed Media Link</h3>
                <input type="text" id="link-embed-input" placeholder="Paste YouTube, Vimeo, or media URL..." autocomplete="off">
                <div class="link-embed-buttons">
                    <button class="link-embed-btn cancel" onclick="closeLinkEmbedDialog()">Cancel</button>
                    <button class="link-embed-btn embed" onclick="embedLinkFromDialog()">Embed</button>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <span id="note-info">No note selected</span>
            <span class="save-indicator saved" id="save-indicator">
                <span class="save-dot"></span> <span class="save-text">Saved</span>
            </span>
        </div>
    </div>

    <!-- Import Modal -->
    <div class="import-modal" id="import-modal">
        <div class="import-modal-content">
            <h3>Import from Evernote</h3>
            <div class="import-status" id="import-status">Preparing to import...</div>
            <div class="import-progress">
                <div class="import-progress-bar" id="import-progress-bar"></div>
            </div>
            <div class="import-modal-buttons">
                <button class="import-modal-btn secondary" onclick="closeImportModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Modal -->
    <div class="modal" id="modal">
        <div class="modal-content">
            <h2 id="modal-title">New Notebook</h2>
            <input type="text" class="modal-input" id="modal-input" placeholder="Name">
            <div class="modal-buttons">
                <button class="modal-btn secondary" onclick="hideModal()">Cancel</button>
                <button class="modal-btn primary" id="modal-confirm" onclick="confirmModal()">Create</button>
            </div>
        </div>
    </div>

    <!-- Version History Modal -->
    <div class="modal-overlay hidden" id="version-modal-overlay" onclick="hideVersionHistory(event)">
        <div class="version-modal" onclick="event.stopPropagation()">
            <div class="version-modal-header">
                <h3>Version History</h3>
                <button class="modal-close-btn" onclick="hideVersionHistory()">&times;</button>
            </div>
            <div class="version-list" id="version-list">
                <div class="no-versions">No versions saved yet</div>
            </div>
        </div>
    </div>

    <script>
        // CHECK IF RUNNING FROM FILE SYSTEM - YOUTUBE WON'T WORK
        if (window.location.protocol === 'file:') {
            const warningDiv = document.createElement('div');
            warningDiv.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#ff3b30;color:white;padding:16px;text-align:center;z-index:99999;font-family:Inter,sans-serif;font-size:14px;box-shadow:0 4px 12px rgba(0,0,0,0.3);';
            warningDiv.innerHTML = `
                <strong> YouTube videos won't work!</strong> You're opening this file directly.<br>
                <strong>Solution:</strong> Run <code style="background:rgba(0,0,0,0.2);padding:2px 8px;border-radius:4px;font-family:monospace;">start-server.ps1</code> and open <strong>http://localhost:8000/index.html</strong> instead.
                <button onclick="this.parentElement.remove()" style="margin-left:12px;background:white;color:#ff3b30;border:none;padding:6px 12px;border-radius:6px;cursor:pointer;font-weight:600;">Dismiss</button>
            `;
            document.body.insertBefore(warningDiv, document.body.firstChild);
        }
        
        // App State
        let state = {
            notebooks: [],
            pinnedNotes: [], // Array of {notebookId, noteId}
            currentNotebook: null,
            currentNote: null,
            currentView: 'home', // 'home' or 'editor'
            tool: 'draw',
            color: '#333333',
            thickness: 3,
            font: "'Inter', sans-serif",
            fontSize: 16,
            zoom: 1,
            panOffset: { x: 0, y: 0 },
            gridVisible: false,
            parentNoteForSubnote: null, // For creating sub-notes
            pendingHeaderLevel: null // For header insertion mode
        };

        // Undo/Redo History
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STACK = 50;

        // Version History
        let versionHistory = [];
        let versionHistoryInterval = null;
        const VERSION_INTERVAL = 5 * 60 * 1000; // 5 minutes

        // Canvas Setup
        const canvasContainer = document.getElementById('canvas-container');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const gridCanvas = document.getElementById('grid-canvas');
        const drawingCanvas = document.getElementById('drawing-canvas');
        const textLayer = document.getElementById('text-layer');
        const gridCtx = gridCanvas.getContext('2d');
        const drawCtx = drawingCanvas.getContext('2d');

        const CANVAS_WIDTH = 4000;
        const CANVAS_HEIGHT = 4000;

        // Initialize canvases
        function initCanvases() {
            gridCanvas.width = CANVAS_WIDTH;
            gridCanvas.height = CANVAS_HEIGHT;
            drawingCanvas.width = CANVAS_WIDTH;
            drawingCanvas.height = CANVAS_HEIGHT;
            
            // Set text layer, grid overlay, and wrapper dimensions
            textLayer.style.width = CANVAS_WIDTH + 'px';
            textLayer.style.height = CANVAS_HEIGHT + 'px';
            canvasWrapper.style.width = CANVAS_WIDTH + 'px';
            canvasWrapper.style.height = CANVAS_HEIGHT + 'px';
            
            const gridOverlay = document.getElementById('grid-overlay');
            if (gridOverlay) {
                gridOverlay.style.width = CANVAS_WIDTH + 'px';
                gridOverlay.style.height = CANVAS_HEIGHT + 'px';
            }
            
            // Center the canvas wrapper
            canvasWrapper.style.marginLeft = (-CANVAS_WIDTH / 2) + 'px';
            canvasWrapper.style.marginTop = (-CANVAS_HEIGHT / 2) + 'px';
            
            updateGridVisibility();
        }

        // Draw dotted grid
        function drawGrid() {
            gridCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            gridCtx.fillStyle = '#c0c0c0';
            const spacing = 30;
            const dotSize = 2;
            
            for (let x = 0; x < CANVAS_WIDTH; x += spacing) {
                for (let y = 0; y < CANVAS_HEIGHT; y += spacing) {
                    gridCtx.fillRect(x, y, dotSize, dotSize);
                }
            }
        }
        
        // Toggle grid visibility
        function toggleGrid() {
            state.gridVisible = !state.gridVisible;
            updateGridVisibility();
        }
        
        function updateGridVisibility() {
            const gridBtn = document.getElementById('grid-btn');
            const gridOverlay = document.getElementById('grid-overlay');
            if (state.gridVisible) {
                gridOverlay?.classList.add('visible');
                gridBtn?.classList.add('active');
            } else {
                gridOverlay?.classList.remove('visible');
                gridBtn?.classList.remove('active');
            }
        }

        // Drawing State
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };

        // Get canvas coordinates
        function getCanvasCoords(e) {
            const rect = drawingCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / state.zoom;
            const y = (e.clientY - rect.top) / state.zoom;
            return { x, y };
        }

        // Drawing functions
        function startDrawing(e) {
            // Deselect any selected media embeds
            document.querySelectorAll('.media-embed.selected').forEach(el => {
                el.classList.remove('selected');
            });
            
            if (state.tool === 'pan') {
                isPanning = true;
                panStart = { x: e.clientX - state.panOffset.x, y: e.clientY - state.panOffset.y };
                return;
            }

            // Check if we're in header insertion mode
            if (state.pendingHeaderLevel) {
                const headerLevel = state.pendingHeaderLevel;
                state.pendingHeaderLevel = null;
                // Clear active state from header buttons
                document.querySelectorAll('.header-btn').forEach(btn => btn.classList.remove('active'));
                createTextBox(e, headerLevel);
                return;
            }

            if (state.tool === 'text') {
                // Don't create new text box if there's currently a focused text box
                // (this click is just to deselect/blur the current one)
                const activeElement = document.activeElement;
                if (activeElement && activeElement.classList.contains('text-box')) {
                    return;
                }
                createTextBox(e);
                return;
            }

            // Save state before drawing starts (for undo)
            saveToUndoStack();
            
            isDrawing = true;
            const coords = getCanvasCoords(e);
            lastX = coords.x;
            lastY = coords.y;
        }

        function draw(e) {
            if (isPanning) {
                state.panOffset.x = e.clientX - panStart.x;
                state.panOffset.y = e.clientY - panStart.y;
                updateCanvasTransform();
                return;
            }

            if (!isDrawing) return;

            const coords = getCanvasCoords(e);
            
            drawCtx.beginPath();
            drawCtx.moveTo(lastX, lastY);
            drawCtx.lineTo(coords.x, coords.y);
            drawCtx.strokeStyle = state.tool === 'erase' ? getCanvasBackground() : state.color;
            drawCtx.lineWidth = state.tool === 'erase' ? state.thickness * 3 : state.thickness;
            drawCtx.lineCap = 'round';
            drawCtx.lineJoin = 'round';
            drawCtx.stroke();

            lastX = coords.x;
            lastY = coords.y;
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                markUnsaved();
            }
            if (isPanning) {
                isPanning = false;
            }
        }

        // Text box creation
        function createTextBox(e, headerLevel = null) {
            const coords = getCanvasCoords(e);
            const textBox = document.createElement('div');
            textBox.className = 'text-box';
            if (headerLevel) {
                textBox.className += ` header-${headerLevel}`;
                textBox.setAttribute('data-header-level', headerLevel);
            }
            textBox.contentEditable = 'true';
            textBox.style.position = 'absolute';
            textBox.style.left = coords.x + 'px';
            textBox.style.top = coords.y + 'px';
            textBox.style.fontFamily = state.font;
            if (!headerLevel) {
                textBox.style.fontSize = state.fontSize + 'px';
            }
            textBox.style.color = state.color;
            textBox.style.minWidth = '100px';
            textBox.style.minHeight = '30px';
            
            textLayer.appendChild(textBox);
            
            // Small delay to ensure DOM is updated before focusing
            setTimeout(() => {
                textBox.focus();
            }, 10);

            textBox.addEventListener('blur', () => {
                if (textBox.textContent.trim() === '') {
                    textBox.remove();
                } else {
                    textBox.classList.add('placed');
                    saveToUndoStack();
                }
                updateOutline();
                markUnsaved();
            });

            textBox.addEventListener('input', debounce(() => {
                updateOutline();
                markUnsaved();
            }, 500));
            
            // Add click handler for select tool
            addTextBoxSelectHandler(textBox);
        }

        // Insert header - set mode to place on next click
        function insertHeader(level) {
            if (state.currentView !== 'editor' || !state.currentNote) {
                alert('Please open a note first');
                return;
            }
            
            // Toggle header mode
            if (state.pendingHeaderLevel === level) {
                // Cancel if clicking same header button
                state.pendingHeaderLevel = null;
                document.querySelectorAll('.header-btn').forEach(btn => btn.classList.remove('active'));
            } else {
                // Set new header level
                state.pendingHeaderLevel = level;
                // Update button states
                document.querySelectorAll('.header-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`header-${level}-btn`)?.classList.add('active');
                // Change cursor to indicate header mode
                canvasContainer.style.cursor = 'text';
            }
        }

        // Toggle outline sidebar
        function toggleOutline() {
            const outline = document.getElementById('outline-sidebar');
            const btn = document.getElementById('outline-btn');
            outline.classList.toggle('visible');
            btn.classList.toggle('active');
            if (outline.classList.contains('visible')) {
                updateOutline();
            }
        }

        // Update outline with all headers
        function updateOutline() {
            const outlineContent = document.getElementById('outline-content');
            if (!outlineContent) return;
            
            const headers = textLayer.querySelectorAll('[data-header-level]');
            
            if (headers.length === 0) {
                outlineContent.innerHTML = '<div style="color:#999;font-size:0.75rem;padding:8px 0;">No headers yet</div>';
                return;
            }
            
            let html = '';
            headers.forEach((header, index) => {
                const level = header.getAttribute('data-header-level');
                const text = header.textContent.trim() || `Header ${level}`;
                const shortText = text.length > 30 ? text.substring(0, 30) + '...' : text;
                html += `<div class="outline-item h${level}" onclick="scrollToHeader(${index})" title="${text}">${shortText}</div>`;
            });
            
            outlineContent.innerHTML = html;
            // Also update the header nav (top bar)
            updateHeaderNav(headers);
        }

        // Scroll to header when clicked in outline
        function scrollToHeader(index) {
            const headers = textLayer.querySelectorAll('[data-header-level]');
            if (headers[index]) {
                const header = headers[index];
                
                // Highlight briefly
                header.style.transition = 'background 0.3s ease';
                header.style.background = 'rgba(0, 122, 255, 0.1)';
                setTimeout(() => {
                    header.style.background = '';
                }, 500);
                
                // Scroll into view
                header.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // Update header nav sidebar (Notion-style small lines)
        function updateHeaderNav(headers) {
            const nav = document.getElementById('header-nav');
            const preview = document.getElementById('header-preview');
            if (!nav || !preview) return;

            nav.innerHTML = '';
            preview.style.display = 'none';

            if (!headers || headers.length === 0) {
                nav.style.display = 'none';
                return;
            }

            headers.forEach((header, index) => {
                const level = header.getAttribute('data-header-level');
                const text = header.textContent.trim() || `Header ${level}`;

                const item = document.createElement('div');
                item.className = `header-nav-item h${level}`;
                item.dataset.index = index;

                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Remove active from others
                    nav.querySelectorAll('.header-nav-item').forEach(i => i.classList.remove('active'));
                    item.classList.add('active');
                    scrollToHeader(index);
                });

                item.addEventListener('mouseenter', (e) => {
                    preview.textContent = text;
                    preview.style.display = 'block';
                    const rect = item.getBoundingClientRect();
                    // Position preview to the left of the line
                    preview.style.top = rect.top + 'px';
                    preview.style.left = (rect.left - preview.offsetWidth - 10) + 'px';
                });

                item.addEventListener('mouseleave', () => {
                    preview.style.display = 'none';
                });

                nav.appendChild(item);
            });

            nav.style.display = 'flex';
        }

        function addTextBoxSelectHandler(textBox) {
            textBox.addEventListener('mousedown', (e) => {
                if (state.tool === 'select') {
                    e.preventDefault();
                    e.stopPropagation();
                    selectTextBox(textBox);
                }
            });
        }

        // Event listeners
        drawingCanvas.addEventListener('mousedown', startDrawing);
        drawingCanvas.addEventListener('mousemove', (e) => {
            draw(e);
            // Update eraser cursor position
            if (state.tool === 'erase') {
                const eraserCursor = document.getElementById('eraser-cursor');
                eraserCursor.style.left = e.clientX + 'px';
                eraserCursor.style.top = e.clientY + 'px';
                eraserCursor.classList.add('visible');
            }
        });
        drawingCanvas.addEventListener('mouseup', stopDrawing);
        drawingCanvas.addEventListener('mouseout', (e) => {
            stopDrawing();
            // Hide eraser cursor when leaving canvas
            const eraserCursor = document.getElementById('eraser-cursor');
            eraserCursor.classList.remove('visible');
        });
        drawingCanvas.addEventListener('mouseenter', (e) => {
            // Show eraser cursor when entering canvas
            if (state.tool === 'erase') {
                const eraserCursor = document.getElementById('eraser-cursor');
                eraserCursor.style.left = e.clientX + 'px';
                eraserCursor.style.top = e.clientY + 'px';
                eraserCursor.classList.add('visible');
            }
        });
        
        // Click on canvas to deselect text boxes
        drawingCanvas.addEventListener('click', () => {
            if (state.tool === 'select') {
                clearTextBoxSelection();
            }
        });

        // Touch support
        let lastTouchDistance = 0;
        let isTouchZooming = false;
        let touchStartPoints = [];

        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getTouchCenter(touches) {
            return {
                x: (touches[0].clientX + touches[1].clientX) / 2,
                y: (touches[0].clientY + touches[1].clientY) / 2
            };
        }

        canvasContainer.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                // Two finger touch - start pinch zoom
                e.preventDefault();
                isTouchZooming = true;
                lastTouchDistance = getTouchDistance(e.touches);
                touchStartPoints = [
                    { x: e.touches[0].clientX, y: e.touches[0].clientY },
                    { x: e.touches[1].clientX, y: e.touches[1].clientY }
                ];
            } else if (e.touches.length === 1 && !isTouchZooming) {
                // Single touch - drawing or panning
                e.preventDefault();
                const touch = e.touches[0];
                startDrawing({ clientX: touch.clientX, clientY: touch.clientY });
            }
        }, { passive: false });

        canvasContainer.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && isTouchZooming) {
                // Pinch zoom
                e.preventDefault();
                const currentDistance = getTouchDistance(e.touches);
                const scale = currentDistance / lastTouchDistance;
                
                // Calculate new zoom
                const newZoom = Math.max(0.25, Math.min(4, state.zoom * scale));
                
                // Get pinch center for zoom origin
                const center = getTouchCenter(e.touches);
                const rect = canvasContainer.getBoundingClientRect();
                const centerX = center.x - rect.left;
                const centerY = center.y - rect.top;
                
                // Adjust pan offset to zoom toward pinch center
                if (newZoom !== state.zoom) {
                    const zoomDelta = newZoom / state.zoom;
                    state.panOffset.x = centerX - (centerX - state.panOffset.x) * zoomDelta;
                    state.panOffset.y = centerY - (centerY - state.panOffset.y) * zoomDelta;
                    state.zoom = newZoom;
                    updateCanvasTransform();
                    updateZoomDisplay();
                }
                
                lastTouchDistance = currentDistance;
            } else if (e.touches.length === 1 && !isTouchZooming) {
                // Single touch drawing
                e.preventDefault();
                const touch = e.touches[0];
                draw({ clientX: touch.clientX, clientY: touch.clientY });
            }
        }, { passive: false });

        canvasContainer.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) {
                isTouchZooming = false;
                lastTouchDistance = 0;
            }
            if (e.touches.length === 0) {
                stopDrawing();
            }
        });

        canvasContainer.addEventListener('touchcancel', () => {
            isTouchZooming = false;
            lastTouchDistance = 0;
            stopDrawing();
        });

        // Zoom with mouse wheel
        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            state.zoom = Math.max(0.25, Math.min(4, state.zoom + delta));
            updateCanvasTransform();
            updateZoomDisplay();
        });

        // Tool functions
        let selectedTextBox = null;

        function setTool(tool) {
            state.tool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`${tool}-btn`).classList.add('active');
            
            // Clear selection when switching tools
            if (tool !== 'select') {
                clearTextBoxSelection();
            }
            
            const eraserCursor = document.getElementById('eraser-cursor');
            if (tool === 'erase') {
                drawingCanvas.style.cursor = 'none';
                updateEraserCursor();
            } else {
                eraserCursor.classList.remove('visible');
                drawingCanvas.style.cursor = tool === 'pan' ? 'grab' : 
                                             tool === 'text' ? 'text' :
                                             tool === 'select' ? 'default' : 'crosshair';
            }
        }

        function selectTextBox(textBox) {
            clearTextBoxSelection();
            selectedTextBox = textBox;
            textBox.classList.add('selected');
        }

        function clearTextBoxSelection() {
            if (selectedTextBox) {
                selectedTextBox.classList.remove('selected');
                selectedTextBox = null;
            }
        }

        function deleteSelectedTextBox() {
            if (selectedTextBox) {
                saveToUndoStack();
                selectedTextBox.remove();
                selectedTextBox = null;
                markUnsaved();
            }
        }
        
        function updateEraserCursor() {
            const eraserCursor = document.getElementById('eraser-cursor');
            const size = state.thickness * 3 * state.zoom;
            eraserCursor.style.width = size + 'px';
            eraserCursor.style.height = size + 'px';
        }

        // Undo/Redo Functions
        function saveToUndoStack() {
            const canvasState = drawingCanvas.toDataURL();
            const textBoxes = Array.from(textLayer.querySelectorAll('.text-box')).map(box => ({
                content: box.innerHTML,
                left: box.style.left,
                top: box.style.top,
                width: box.style.width,
                height: box.style.height,
                fontFamily: box.style.fontFamily,
                fontSize: box.style.fontSize,
                color: box.style.color
            }));
            
            undoStack.push({ canvasState, textBoxes });
            
            // Limit stack size
            if (undoStack.length > MAX_UNDO_STACK) {
                undoStack.shift();
            }
            
            // Clear redo stack when new action is performed
            redoStack = [];
            
            updateUndoRedoButtons();
        }

        function undo() {
            if (undoStack.length === 0) return;
            
            // Save current state to redo stack
            const currentState = {
                canvasState: drawingCanvas.toDataURL(),
                textBoxes: Array.from(textLayer.querySelectorAll('.text-box')).map(box => ({
                    content: box.innerHTML,
                    left: box.style.left,
                    top: box.style.top,
                    width: box.style.width,
                    height: box.style.height,
                    fontFamily: box.style.fontFamily,
                    fontSize: box.style.fontSize,
                    color: box.style.color
                }))
            };
            redoStack.push(currentState);
            
            // Restore previous state
            const previousState = undoStack.pop();
            restoreState(previousState);
            
            updateUndoRedoButtons();
            markUnsaved();
        }

        function redo() {
            if (redoStack.length === 0) return;
            
            // Save current state to undo stack
            const currentState = {
                canvasState: drawingCanvas.toDataURL(),
                textBoxes: Array.from(textLayer.querySelectorAll('.text-box')).map(box => ({
                    content: box.innerHTML,
                    left: box.style.left,
                    top: box.style.top,
                    width: box.style.width,
                    height: box.style.height,
                    fontFamily: box.style.fontFamily,
                    fontSize: box.style.fontSize,
                    color: box.style.color
                }))
            };
            undoStack.push(currentState);
            
            // Restore redo state
            const redoState = redoStack.pop();
            restoreState(redoState);
            
            updateUndoRedoButtons();
            markUnsaved();
        }

        function restoreState(stateData) {
            // Restore canvas
            const img = new Image();
            img.onload = () => {
                drawCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                drawCtx.drawImage(img, 0, 0);
            };
            img.src = stateData.canvasState;
            
            // Restore text boxes
            textLayer.innerHTML = '';
            stateData.textBoxes.forEach(boxData => {
                const textBox = document.createElement('div');
                    textBox.className = 'text-box placed';
                    // Restore header class if this textbox was a header when saved
                    if (boxData.headerLevel) {
                        textBox.className += ` header-${boxData.headerLevel}`;
                        textBox.setAttribute('data-header-level', boxData.headerLevel);
                    }
                    textBox.contentEditable = true;
                    // Use textContent for plain imports, innerHTML for saved notes with formatting
                    if (boxData.content && boxData.content.includes('<')) {
                        textBox.innerHTML = boxData.content;
                    } else {
                        textBox.textContent = boxData.content || '';
                    }
                    textBox.style.position = 'absolute';
                    textBox.style.left = boxData.left;
                    textBox.style.top = boxData.top;
                    textBox.style.minWidth = '50px';
                    textBox.style.minHeight = '20px';
                    if (boxData.width && boxData.width !== 'auto' && boxData.width !== '') {
                        textBox.style.width = boxData.width;
                    }
                    if (boxData.height && boxData.height !== 'auto' && boxData.height !== '') {
                        textBox.style.height = boxData.height;
                    }
                    if (boxData.fontFamily) textBox.style.fontFamily = boxData.fontFamily;
                    // For headers, prefer CSS header sizing  avoid setting inline fontSize
                    if (!boxData.headerLevel) {
                        if (boxData.fontSize) textBox.style.fontSize = boxData.fontSize;
                    } else {
                        textBox.style.fontSize = '';
                    }
                    if (boxData.color) textBox.style.color = boxData.color;
                
                textBox.addEventListener('blur', () => {
                    if (textBox.textContent.trim() === '') {
                        textBox.remove();
                    }
                    saveToUndoStack();
                    markUnsaved();
                });

                textBox.addEventListener('input', debounce(() => markUnsaved(), 500));
                
                // Add click handler for select tool
                addTextBoxSelectHandler(textBox);
                
                textLayer.appendChild(textBox);
            });
            
            // Re-render subnote blocks
            if (state.currentNote) {
                renderSubnoteBlocks(state.currentNote);
            }
        }

        function updateUndoRedoButtons() {
            document.getElementById('undo-btn').disabled = undoStack.length === 0;
            document.getElementById('redo-btn').disabled = redoStack.length === 0;
        }

        function clearUndoHistory() {
            undoStack = [];
            redoStack = [];
            updateUndoRedoButtons();
        }

        // Save the initial state when a note is first loaded
        function saveInitialState() {
            const canvasState = drawingCanvas.toDataURL();
            const textBoxes = Array.from(textLayer.querySelectorAll('.text-box')).map(box => ({
                content: box.innerHTML,
                left: box.style.left,
                top: box.style.top,
                width: box.style.width,
                height: box.style.height,
                fontFamily: box.style.fontFamily,
                fontSize: box.style.fontSize,
                color: box.style.color
            }));
            
            // This is the base state - it goes in the undo stack
            // but won't be cleared by saveToUndoStack's redo clear
            undoStack = [{ canvasState, textBoxes }];
            redoStack = [];
            updateUndoRedoButtons();
        }

        // Version History Functions
        function saveVersionSnapshot() {
            if (!state.currentNote) return;
            
            const snapshot = {
                timestamp: Date.now(),
                canvasState: drawingCanvas.toDataURL(),
                textBoxes: Array.from(textLayer.querySelectorAll('.text-box')).map(box => ({
                    content: box.innerHTML,
                    left: box.style.left,
                    top: box.style.top,
                    width: box.style.width,
                    height: box.style.height,
                    fontFamily: box.style.fontFamily,
                    fontSize: box.style.fontSize,
                    color: box.style.color
                }))
            };
            
            versionHistory.push(snapshot);
            
            // Keep max 20 versions per session
            if (versionHistory.length > 20) {
                versionHistory.shift();
            }
            
            // Save to note data
            const note = findCurrentNote();
            if (note) {
                note.versionHistory = versionHistory;
                saveToStorage();
            }
        }

        function startVersionHistoryTimer() {
            if (versionHistoryInterval) {
                clearInterval(versionHistoryInterval);
            }
            // Save initial version
            setTimeout(() => saveVersionSnapshot(), 1000);
            // Save every 5 minutes
            versionHistoryInterval = setInterval(saveVersionSnapshot, VERSION_INTERVAL);
        }

        function stopVersionHistoryTimer() {
            if (versionHistoryInterval) {
                clearInterval(versionHistoryInterval);
                versionHistoryInterval = null;
            }
        }

        function showVersionHistory() {
            const modal = document.getElementById('version-modal-overlay');
            const versionList = document.getElementById('version-list');
            
            if (versionHistory.length === 0) {
                versionList.innerHTML = '<div class="no-versions">No versions saved yet</div>';
            } else {
                versionList.innerHTML = versionHistory.map((version, index) => {
                    const date = new Date(version.timestamp);
                    const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    const dateStr = date.toLocaleDateString([], { month: 'short', day: 'numeric' });
                    return `
                        <div class="version-item" onclick="previewVersion(${index})">
                            <span class="version-time">${dateStr} at ${timeStr}</span>
                            <button class="version-restore-btn" onclick="event.stopPropagation(); restoreVersion(${index})">Restore</button>
                        </div>
                    `;
                }).reverse().join('');
            }
            
            modal.classList.remove('hidden');
        }

        function hideVersionHistory(e) {
            if (e && e.target !== e.currentTarget) return;
            document.getElementById('version-modal-overlay').classList.add('hidden');
        }

        function restoreVersion(index) {
            const version = versionHistory[index];
            if (!version) return;
            
            // Save current state to undo stack before restoring
            saveToUndoStack();
            
            restoreState(version);
            hideVersionHistory();
            markUnsaved();
        }

        function previewVersion(index) {
            // For now, just restore. Could add preview functionality later.
            restoreVersion(index);
        }

        function findCurrentNote() {
            if (!state.currentNotebook || !state.currentNote) return null;
            const notebook = state.notebooks.find(n => n.id === state.currentNotebook);
            if (!notebook) return null;
            return notebook.notes.find(n => n.id === state.currentNote);
        }

        function zoomIn() {
            state.zoom = Math.min(4, state.zoom + 0.25);
            updateCanvasTransform();
            updateZoomDisplay();
            updateEraserCursor();
        }

        function zoomOut() {
            state.zoom = Math.max(0.25, state.zoom - 0.25);
            updateCanvasTransform();
            updateZoomDisplay();
            updateEraserCursor();
        }

        function resetZoom() {
            state.zoom = 1;
            state.panOffset = { x: 0, y: 0 };
            updateCanvasTransform();
            updateZoomDisplay();
            updateEraserCursor();
        }

        function updateCanvasTransform() {
            canvasWrapper.style.transform = `translate(${state.panOffset.x}px, ${state.panOffset.y}px) scale(${state.zoom})`;
        }

        function updateZoomDisplay() {
            document.getElementById('zoom-display').textContent = Math.round(state.zoom * 100) + '%';
        }

        // Color picker
        document.getElementById('color-picker').addEventListener('change', (e) => {
            state.color = e.target.value;
        });

        // Thickness slider
        document.getElementById('thickness-slider').addEventListener('input', (e) => {
            state.thickness = parseInt(e.target.value);
            document.getElementById('thickness-value').textContent = state.thickness + 'px';
            if (state.tool === 'erase') {
                updateEraserCursor();
            }
        });

        // Font select
        // Changing the font now only affects future text boxes.
        document.getElementById('font-select').addEventListener('change', (e) => {
            state.font = e.target.value;
            // Do not overwrite font on existing text boxes; preserve previously-typed text.
            // New text boxes created after this will use `state.font` (see createTextBox).
            if (state.currentNote) saveNoteData();
        });

        document.getElementById('font-size-select').addEventListener('change', (e) => {
            state.fontSize = parseInt(e.target.value);
        });

        // Clear canvas
        function clearCanvas() {
            if (confirm('Are you sure you want to clear the canvas?')) {
                drawCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                drawCtx.fillStyle = getCanvasBackground();
                drawCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                textLayer.innerHTML = '';
                
                // Re-render subnote blocks
                if (state.currentNote) {
                    renderSubnoteBlocks(state.currentNote);
                }
                
                saveCurrentNote();
            }
        }

        // Export notes to Evernote ENEX format (replaces previous PNG export)
        async function exportNote() {
            try {
                const enex = await buildENEXFromState();
                const blob = new Blob([enex], { type: 'application/xml' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                const now = new Date();
                const filename = `ultimateNotes-export-${now.getFullYear()}-${now.getMonth()+1}-${now.getDate()}.enex`;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                link.remove();
                URL.revokeObjectURL(url);
            } catch (e) {
                console.error('Export to ENEX failed:', e);
                alert('Export failed. See console for details.');
            }
        }

        // Build ENEX content from current app state
        async function buildENEXFromState() {
            // Simple MD5 implementation (adapted) for computing resource hashes
            function md5cycle(x, k) {
                var a = x[0], b = x[1], c = x[2], d = x[3];
                a = ff(a, b, c, d, k[0], 7, -680876936);
                d = ff(d, a, b, c, k[1], 12, -389564586);
                c = ff(c, d, a, b, k[2], 17, 606105819);
                b = ff(b, c, d, a, k[3], 22, -1044525330);
                a = ff(a, b, c, d, k[4], 7, -176418897);
                d = ff(d, a, b, c, k[5], 12, 1200080426);
                c = ff(c, d, a, b, k[6], 17, -1473231341);
                b = ff(b, c, d, a, k[7], 22, -45705983);
                a = ff(a, b, c, d, k[8], 7, 1770035416);
                d = ff(d, a, b, c, k[9], 12, -1958414417);
                c = ff(c, d, a, b, k[10], 17, -42063);
                b = ff(b, c, d, a, k[11], 22, -1990404162);
                a = ff(a, b, c, d, k[12], 7, 1804603682);
                d = ff(d, a, b, c, k[13], 12, -40341101);
                c = ff(c, d, a, b, k[14], 17, -1502002290);
                b = ff(b, c, d, a, k[15], 22, 1236535329);
                a = gg(a, b, c, d, k[1], 5, -165796510);
                d = gg(d, a, b, c, k[6], 9, -1069501632);
                c = gg(c, d, a, b, k[11], 14, 643717713);
                b = gg(b, c, d, a, k[0], 20, -373897302);
                a = gg(a, b, c, d, k[5], 5, -701558691);
                d = gg(d, a, b, c, k[10], 9, 38016083);
                c = gg(c, d, a, b, k[15], 14, -660478335);
                b = gg(b, c, d, a, k[4], 20, -405537848);
                a = gg(a, b, c, d, k[9], 5, 568446438);
                d = gg(d, a, b, c, k[14], 9, -1019803690);
                c = gg(c, d, a, b, k[3], 14, -187363961);
                b = gg(b, c, d, a, k[8], 20, 1163531501);
                a = gg(a, b, c, d, k[13], 5, -1444681467);
                d = gg(d, a, b, c, k[2], 9, -51403784);
                c = gg(c, d, a, b, k[7], 14, 1735328473);
                b = gg(b, c, d, a, k[12], 20, -1926607734);
                a = hh(a, b, c, d, k[5], 4, -378558);
                d = hh(d, a, b, c, k[8], 11, -2022574463);
                c = hh(c, d, a, b, k[11], 16, 1839030562);
                b = hh(b, c, d, a, k[14], 23, -35309556);
                a = hh(a, b, c, d, k[1], 4, -1530992060);
                d = hh(d, a, b, c, k[4], 11, 1272893353);
                c = hh(c, d, a, b, k[7], 16, -155497632);
                b = hh(b, c, d, a, k[10], 23, -1094730640);
                a = hh(a, b, c, d, k[13], 4, 681279174);
                d = hh(d, a, b, c, k[0], 11, -358537222);
                c = hh(c, d, a, b, k[3], 16, -722521979);
                b = hh(b, c, d, a, k[6], 23, 76029189);
                a = hh(a, b, c, d, k[9], 4, -640364487);
                d = hh(d, a, b, c, k[12], 11, -421815835);
                c = hh(c, d, a, b, k[15], 16, 530742520);
                b = hh(b, c, d, a, k[2], 23, -995338651);
                a = ii(a, b, c, d, k[0], 6, -198630844);
                d = ii(d, a, b, c, k[7], 10, 1126891415);
                c = ii(c, d, a, b, k[14], 15, -1416354905);
                b = ii(b, c, d, a, k[5], 21, -57434055);
                a = ii(a, b, c, d, k[12], 6, 1700485571);
                d = ii(d, a, b, c, k[3], 10, -1894986606);
                c = ii(c, d, a, b, k[10], 15, -1051523);
                b = ii(b, c, d, a, k[1], 21, -2054922799);
                a = ii(a, b, c, d, k[8], 6, 1873313359);
                d = ii(d, a, b, c, k[15], 10, -30611744);
                c = ii(c, d, a, b, k[6], 15, -1560198380);
                b = ii(b, c, d, a, k[13], 21, 1309151649);
                a = ii(a, b, c, d, k[4], 6, -145523070);
                d = ii(d, a, b, c, k[11], 10, -1120210379);
                c = ii(c, d, a, b, k[2], 15, 718787259);
                b = ii(b, c, d, a, k[9], 21, -343485551);
                x[0] = add32(a, x[0]);
                x[1] = add32(b, x[1]);
                x[2] = add32(c, x[2]);
                x[3] = add32(d, x[3]);
            }
            function cmn(q, a, b, x, s, t) {
                a = add32(add32(a, q), add32(x, t));
                return add32((a << s) | (a >>> (32 - s)), b);
            }
            function ff(a, b, c, d, x, s, t) { return cmn((b & c) | (~b & d), a, b, x, s, t); }
            function gg(a, b, c, d, x, s, t) { return cmn((b & d) | (c & ~d), a, b, x, s, t); }
            function hh(a, b, c, d, x, s, t) { return cmn(b ^ c ^ d, a, b, x, s, t); }
            function ii(a, b, c, d, x, s, t) { return cmn(c ^ (b | ~d), a, b, x, s, t); }
            function md51(s) {
                var txt = '';
                var n = s.length,
                    state = [1732584193, -271733879, -1732584194, 271733878],
                    i;
                for (i = 64; i <= s.length; i += 64) {
                    md5cycle(state, md5blk(s.substring(i - 64, i)));
                }
                s = s.substring(i - 64);
                var tail = new Array(16).fill(0);
                for (i = 0; i < s.length; i++) tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
                tail[i >> 2] |= 0x80 << ((i % 4) << 3);
                if (i > 55) {
                    md5cycle(state, tail);
                    tail = new Array(16).fill(0);
                }
                tail[14] = n * 8;
                md5cycle(state, tail);
                return state;
            }
            function md5blk(s) {
                var md5blks = [], i;
                for (i = 0; i < 64; i += 4) {
                    md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
                }
                return md5blks;
            }
            var hex_chr = '0123456789abcdef'.split('');
            function rhex(n) {
                var s = '', j = 0;
                for (; j < 4; j++) s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
                return s;
            }
            function hex(x) {
                for (var i = 0; i < x.length; i++) x[i] = rhex(x[i]);
                return x.join('');
            }
            function md5(s) { return hex(md51(s)); }
            function add32(a, b) { return (a + b) & 0xFFFFFFFF; }

            // Helper: decode base64 to binary string
            function b64ToBinaryString(b64) {
                try {
                    return atob(b64);
                } catch (e) {
                    // fallback
                    return decodeURIComponent(escape(window.atob(b64)));
                }
            }

            // Build ENEX header
            const exportDate = new Date().toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
            let enex = '<?xml version="1.0" encoding="UTF-8"?>\n';
            enex += '<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export2.dtd">\n';
            enex += `<en-export export-date="${exportDate}" application="UltimateNotesApp" version="1.0">\n`;

            // Iterate notebooks and notes
            const notebooks = state.notebooks || [];
            for (const nb of notebooks) {
                for (const note of nb.notes || []) {
                    enex += '  <note>\n';
                    enex += `    <title>${escapeHTML(note.name || 'Untitled')}</title>\n`;

                    // Collect resources for this note
                    const resources = [];

                    // Map mediaEmbeds to resources/en-media or links
                    let noteHtml = '<en-note>';

                    // Add text boxes as simple divs, preserving order
                    const textBoxes = note.textBoxes || [];
                    for (let tb of textBoxes) {
                        let t = escapeHTML(tb.content || '');
                        // Replace any media placeholders like [media:ID]
                        t = t.replace(/\[media:([^\]]+)\]/g, function(_, mid) {
                            const m = (note.mediaEmbeds || []).find(x => x.id === mid);
                            if (m) {
                                if (m.url && m.url.startsWith('data:')) {
                                    const parts = m.url.split(',');
                                    const meta = parts[0];
                                    const b64 = parts[1] || '';
                                    const mime = (meta.split(':')[1] || '').split(';')[0];
                                    const bin = b64ToBinaryString(b64);
                                    const hash = md5(bin);
                                    resources.push({ mime, data: b64, hash, fileName: m.fileName || 'resource' });
                                    return `<en-media type="${mime}" hash="${hash}"/>`;
                                } else if (m.url) {
                                    // External link  convert to anchor
                                    return `<a href="${escapeHTML(m.url)}">${escapeHTML(m.url)}</a>`;
                                }
                            }
                            return '';
                        });
                        noteHtml += `<div>${t}</div>`;
                    }

                    noteHtml += '</en-note>';

                    enex += '    <content><![CDATA[' + noteHtml + ']]></content>\n';

                    // Append resources
                    for (const r of resources) {
                        enex += '    <resource>\n';
                        enex += `      <data encoding="base64">${r.data}</data>\n`;
                        enex += `      <mime>${r.mime}</mime>\n`;
                        enex += '      <resource-attributes>\n';
                        enex += `        <file-name>${escapeHTML(r.fileName || 'resource')}</file-name>\n`;
                        enex += '      </resource-attributes>\n';
                        enex += '    </resource>\n';
                    }

                    enex += '  </note>\n';
                }
            }

            enex += '</en-export>\n';
            return enex;
        }

        // Evernote Import
        function triggerEvernoteImport() {
            document.getElementById('evernote-import').click();
        }

        function handleEvernoteImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Show import modal
            const modal = document.getElementById('import-modal');
            const status = document.getElementById('import-status');
            const progressBar = document.getElementById('import-progress-bar');
            modal.classList.add('active');
            status.textContent = 'Reading file...';
            progressBar.style.width = '10%';

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    status.textContent = 'Parsing Evernote notes...';
                    progressBar.style.width = '30%';
                    
                    const parser = new DOMParser();
                    const xml = parser.parseFromString(e.target.result, 'text/xml');
                    const notes = xml.querySelectorAll('note');
                    
                    if (notes.length === 0) {
                        status.textContent = 'No notes found in file.';
                        progressBar.style.width = '100%';
                        return;
                    }

                    // Create a new notebook for the import
                    const notebookName = file.name.replace('.enex', '') || 'Evernote Import';
                    const notebook = {
                        id: Date.now().toString(),
                        name: notebookName,
                        notes: [],
                        isOpen: true
                    };

                    status.textContent = `Importing ${notes.length} notes...`;
                    progressBar.style.width = '50%';

                    let imported = 0;
                    notes.forEach((noteEl, index) => {
                        const title = noteEl.querySelector('title')?.textContent || `Note ${index + 1}`;
                        const contentEl = noteEl.querySelector('content');
                        let content = '';
                        let extractedMedia = [];
                        
                        if (contentEl) {
                            // Extract ENML content robustly from the XML node.
                            // In an XMLDocument, `innerHTML` is not reliable. Prefer CDATA node value,
                            // then serialize child nodes to preserve markup for parseENML.
                            let rawContent = '';

                            try {
                                // If the first child is a CDATA section, use its nodeValue
                                const first = contentEl.firstChild;
                                if (first && first.nodeType === 4 && first.nodeValue) { // CDATA_SECTION_NODE === 4
                                    rawContent = first.nodeValue;
                                } else {
                                    // Serialize child nodes to a string (preserves any markup)
                                    const serializer = new XMLSerializer();
                                    rawContent = Array.from(contentEl.childNodes).map(n => serializer.serializeToString(n)).join('');
                                }
                            } catch (xmlErr) {
                                console.warn('XML extraction error, falling back to textContent:', xmlErr);
                                rawContent = contentEl.textContent || '';
                            }

                            console.log('Extracted raw ENML for "' + title + '" (first 200 chars):', rawContent.substring(0, 200));

                            // Some ENML exports HTML-encode entities inside the CDATA; decode them safely
                            try {
                                const ta = document.createElement('textarea');
                                ta.innerHTML = rawContent;
                                rawContent = ta.value;
                            } catch (decodeErr) {
                                console.warn('Failed to decode HTML entities for imported content:', decodeErr);
                            }

                            // Build a list of resources for this note so we can map inline <en-media> tags
                            const resourceEls = Array.from(noteEl.querySelectorAll('resource') || []);
                            const resourcesList = resourceEls.map(res => {
                                const dataEl = res.querySelector('data');
                                const mimeEl = res.querySelector('mime');
                                const fileName = res.querySelector('resource-attributes > file-name')?.textContent || '';
                                const b64 = (dataEl?.textContent || '').replace(/\s+/g, '');
                                const mime = (mimeEl?.textContent || '').trim() || '';
                                return { b64, mime, fileName };
                            });

                            // Transform any <en-media> and special <img> placeholders into real <img> tags
                            // and collect extracted media info for later placement as mediaEmbeds.
                            try {
                                const mediaDoc = new DOMParser().parseFromString(rawContent, 'text/html');

                                // Select en-media tags and img tags that might reference en-media URIs
                                const mediaEls = Array.from(mediaDoc.querySelectorAll('en-media, img'))
                                    .filter(el => el.tagName.toLowerCase() === 'en-media' || (el.tagName.toLowerCase() === 'img' && (el.getAttribute('src') || '').startsWith('en-media')));

                                let mapIdx = 0;
                                mediaEls.forEach((mEl, mi) => {
                                    const res = resourcesList[mapIdx];
                                    if (res && res.b64) {
                                        const url = `data:${res.mime};base64,${res.b64}`;
                                        const img = mediaDoc.createElement('img');
                                        const importId = `import-${index}-${mi}`;
                                        img.setAttribute('src', url);
                                        img.setAttribute('data-import-id', importId);
                                        // Replace the original element with a normal img (so later HTML->text parsing can see it)
                                        mEl.parentNode.replaceChild(img, mEl);

                                        const type = res.mime.startsWith('image/') ? 'image' : res.mime.startsWith('video/') ? 'video' : res.mime.startsWith('audio/') ? 'audio' : 'file';
                                        extractedMedia.push({ id: importId, type, url, fileName: res.fileName });
                                        mapIdx++;
                                    }
                                });

                                // Serialize back to string for parseENML
                                rawContent = mediaDoc.body.innerHTML || rawContent;
                            } catch (transformErr) {
                                console.warn('ENML media transform failed:', transformErr);
                            }

                            // Replace image tags with short placeholders so parseENML keeps a visible marker
                            try {
                                rawContent = rawContent.replace(/<img[^>]*data-import-id=["']([^"']+)["'][^>]*>/gi, '\n[media:$1]\n');
                            } catch (phErr) {
                                console.warn('Failed to add image placeholders:', phErr);
                            }

                            content = parseENML(rawContent);

                            // Log transformed/parsing results and media extracted for debugging
                            console.log('Transformed ENML (first 300 chars):', rawContent.substring(0, 300));
                            console.log('Parsed content (first 300 chars):', content.substring(0, 300));
                            console.log('Extracted media for note', extractedMedia);
                            console.log('Parsed content for "' + title + '":', content.substring(0, 200));
                        } else {
                            console.log('No content element found for "' + title + '"');
                        }

                        const created = noteEl.querySelector('created')?.textContent;
                        const createdDate = created ? parseEvernoteDate(created) : Date.now();

                        const note = {
                            id: (Date.now() + index).toString(),
                            name: title,
                            canvasData: null,
                            textBoxes: [],
                            mediaEmbeds: [],
                            status: 'none',
                            children: [],
                            versionHistory: [],
                            createdAt: createdDate
                        };

                        // Add content as text boxes on canvas
                        // Canvas is 4000x4000, centered, so place content near center (around 1800-2000)
                        const startX = 1800;
                        const startY = 1800;
                        
                        // Always add the title as a header first
                        note.textBoxes.push({
                            content: title,
                            left: startX + 'px',
                            top: startY + 'px',
                            width: '',
                            height: '',
                            fontFamily: 'Inter',
                            fontSize: '24px',
                            color: getDefaultInkColor(),
                            headerLevel: '1'
                        });
                        console.log('Added title textBox for "' + title + '", textBoxes count:', note.textBoxes.length);
                        
                        if (content) {
                            const lines = content.split('\n').filter(l => l.trim());
                            console.log('Content lines for "' + title + '":', lines.length, lines);
                            let yPos = startY + 60;
                            
                            lines.forEach((line, lineIndex) => {
                                if (line.trim()) {
                                    note.textBoxes.push({
                                        content: line.trim(),
                                        left: startX + 'px',
                                        top: yPos + 'px',
                                        width: '',
                                        height: '',
                                        fontFamily: 'Inter',
                                        fontSize: '16px',
                                        color: getDefaultInkColor(),
                                        headerLevel: null
                                    });
                                    yPos += 36;
                                }
                            });
                        }
                        
                        console.log('Final textBoxes for "' + title + '":', note.textBoxes.length, note.textBoxes);

                        // Extract any embedded resources (images/audio/video) and add as media embeds
                        note.mediaEmbeds = note.mediaEmbeds || [];
                        try {
                            if (extractedMedia && extractedMedia.length) {
                                extractedMedia.forEach((m, mi) => {
                                    note.mediaEmbeds.push({
                                        id: m.id,
                                        type: m.type,
                                        url: m.url,
                                        fileName: m.fileName,
                                        left: (startX + 300 + mi * 220) + 'px',
                                        top: (startY + 30) + 'px',
                                        width: '200px',
                                        height: '150px'
                                    });
                                });
                            } else {
                                const resources = noteEl.querySelectorAll('resource');
                                resources.forEach((res, rIndex) => {
                                    const dataEl = res.querySelector('data');
                                    const mimeEl = res.querySelector('mime');
                                    if (dataEl && mimeEl) {
                                        const b64 = (dataEl.textContent || '').replace(/\s+/g, '');
                                        const mime = (mimeEl.textContent || '').trim();
                                        if (b64) {
                                            const url = `data:${mime};base64,${b64}`;
                                            const type = mime.startsWith('image/') ? 'image' : mime.startsWith('video/') ? 'video' : mime.startsWith('audio/') ? 'audio' : 'file';
                                            // Place resources near the note start; offset multiple resources
                                            note.mediaEmbeds.push({
                                                id: `import-${note.id}-${rIndex}`,
                                                type: type,
                                                url: url,
                                                fileName: res.querySelector('resource-attributes > file-name')?.textContent || '',
                                                left: (startX + 300 + rIndex * 220) + 'px',
                                                top: (startY + 30) + 'px',
                                                width: '200px',
                                                height: '150px'
                                            });
                                        }
                                    }
                                });
                            }
                        } catch (resErr) {
                            console.warn('Error extracting resources from ENEX note:', resErr);
                        }

                            // If one of the embedded resources looks like the main drawing (image/png, or filename contains 'draw'/'sketch'),
                            // use it as the canvas image (note.canvasData) and remove it from mediaEmbeds so it doesn't appear twice.
                            try {
                                if ((!note.canvasData || note.canvasData === null) && note.mediaEmbeds && note.mediaEmbeds.length) {
                                    let candidateIdx = note.mediaEmbeds.findIndex(m => m.type === 'image' && /draw|sketch|canvas|drawing/i.test(m.fileName || ''));
                                    if (candidateIdx === -1) {
                                        // If only a single image resource exists, assume it's the canvas drawing
                                        const imageCount = note.mediaEmbeds.filter(m => m.type === 'image').length;
                                        if (imageCount === 1) {
                                            candidateIdx = note.mediaEmbeds.findIndex(m => m.type === 'image');
                                        }
                                    }
                                    if (candidateIdx !== -1) {
                                        const c = note.mediaEmbeds[candidateIdx];
                                        note.canvasData = c.url;
                                        // Remove from media embeds to avoid duplicate rendering
                                        note.mediaEmbeds.splice(candidateIdx, 1);
                                    }
                                }
                            } catch (canvasErr) {
                                console.warn('Error assigning canvasData from resources:', canvasErr);
                            }

                        notebook.notes.push(note);
                        imported++;
                        
                        const progress = 50 + (imported / notes.length) * 45;
                        progressBar.style.width = progress + '%';
                        status.textContent = `Imported ${imported} of ${notes.length} notes...`;
                    });

                    state.notebooks.push(notebook);
                    console.log('About to save. Notebook notes:', notebook.notes.map(n => ({name: n.name, textBoxes: n.textBoxes.length})));
                    
                    // Check storage size before saving
                    const dataToSave = JSON.stringify(state.notebooks);
                    console.log('Data size to save:', dataToSave.length, 'chars');
                    
                    try {
                        localStorage.setItem('ultimateNotesApp', dataToSave);
                        console.log('Save successful!');
                        
                        // Verify save
                        const saved = JSON.parse(localStorage.getItem('ultimateNotesApp'));
                        const importedNb = saved.find(nb => nb.id === notebook.id);
                        console.log('Verified save - notebook notes:', importedNb?.notes.map(n => ({name: n.name, textBoxes: n.textBoxes?.length})));
                    } catch (saveErr) {
                        console.error('Save failed:', saveErr);
                        status.textContent = 'Import failed: Storage is full! Clear some old notes first.';
                        // Remove the notebook we just added since save failed
                        state.notebooks.pop();
                        return;
                    }
                    
                    renderNotebooks();
                    renderHomePage();

                    progressBar.style.width = '100%';
                    status.textContent = `Successfully imported ${imported} notes into "${notebookName}"!`;

                    // Prevent immediate auto-save from overwriting imported content
                    suppressNextAutoSave = true;

                } catch (err) {
                    console.error('Import error:', err);
                    status.textContent = 'Error importing file. Please check it\'s a valid .enex file.';
                    progressBar.style.width = '100%';
                }
            };

            reader.onerror = () => {
                status.textContent = 'Error reading file.';
                progressBar.style.width = '100%';
            };

            reader.readAsText(file);
            event.target.value = ''; // Reset input
        }

        // Parse ENML (Evernote Markup Language) to plain text
        function parseENML(enml) {
            if (!enml || typeof enml !== 'string') {
                return '';
            }
            
            try {
                let content = enml.trim();
                
                // If it looks like it has XML/HTML tags, parse it
                if (content.includes('<')) {
                    // Remove XML declaration and DOCTYPE
                    content = content.replace(/<\?xml[^>]*\?>/gi, '');
                    content = content.replace(/<!DOCTYPE[^>]*>/gi, '');
                    
                    // Remove en-note wrapper tags (Evernote's root element)
                    content = content.replace(/<\/?en-note[^>]*>/gi, '');
                    
                    // Convert common tags to text with line breaks
                    content = content.replace(/<br\s*\/?>/gi, '\n');
                    content = content.replace(/<\/div>/gi, '\n');
                    content = content.replace(/<\/p>/gi, '\n\n');
                    content = content.replace(/<\/li>/gi, '\n');
                    content = content.replace(/<\/h[1-6]>/gi, '\n\n');
                    content = content.replace(/<\/tr>/gi, '\n');
                    
                    // Remove all remaining HTML tags
                    content = content.replace(/<[^>]+>/g, '');
                    
                    // Decode HTML entities
                    const textarea = document.createElement('textarea');
                    textarea.innerHTML = content;
                    content = textarea.value;
                }
                
                // Clean up whitespace
                content = content.replace(/\r\n/g, '\n');
                content = content.replace(/[ \t]+/g, ' ');
                content = content.replace(/\n /g, '\n');
                content = content.replace(/ \n/g, '\n');
                content = content.replace(/\n{3,}/g, '\n\n');
                
                return content.trim();
            } catch (e) {
                console.error('ENML parse error:', e);
                // Fallback: just strip all tags
                return enml.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
            }
        }

        // Parse Evernote date format (yyyyMMddTHHmmssZ)
        function parseEvernoteDate(dateStr) {
            try {
                const year = dateStr.substring(0, 4);
                const month = dateStr.substring(4, 6);
                const day = dateStr.substring(6, 8);
                const hour = dateStr.substring(9, 11);
                const min = dateStr.substring(11, 13);
                const sec = dateStr.substring(13, 15);
                return new Date(`${year}-${month}-${day}T${hour}:${min}:${sec}Z`).getTime();
            } catch (e) {
                return Date.now();
            }
        }

        // Escape HTML for safe insertion
        function escapeHTML(str) {
            return str.replace(/&/g, '&amp;')
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;')
                      .replace(/"/g, '&quot;');
        }

        function closeImportModal() {
            document.getElementById('import-modal').classList.remove('active');
        }

        // Modal functions
        let modalMode = 'notebook';

        function showModal(mode) {
            modalMode = mode;
            const modal = document.getElementById('modal');
            const title = document.getElementById('modal-title');
            const input = document.getElementById('modal-input');
            
            if (mode === 'notebook') {
                title.textContent = 'New Notebook';
            } else if (mode === 'subnote') {
                title.textContent = 'New Sub-Note';
            } else {
                title.textContent = 'New Note';
            }
            input.placeholder = 'Name';
            input.value = '';
            modal.classList.add('active');
            input.focus();
        }

        function hideModal() {
            document.getElementById('modal').classList.remove('active');
            state.parentNoteForSubnote = null;
        }

        function confirmModal() {
            const input = document.getElementById('modal-input');
            const name = input.value.trim();
            
            if (!name) return;

            if (modalMode === 'notebook') {
                createNotebook(name);
            } else if (modalMode === 'subnote') {
                createNote(name, state.parentNoteForSubnote);
            } else {
                createNote(name);
            }
            
            hideModal();
        }

        // Handle Enter key in modal
        document.getElementById('modal-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') confirmModal();
            if (e.key === 'Escape') hideModal();
        });

        // Notebook functions
        function createNotebook(name) {
            const notebook = {
                id: Date.now().toString(),
                name: name,
                notes: [],
                isOpen: true
            };
            state.notebooks.push(notebook);
            state.currentNotebook = notebook;
            renderNotebooks();
            saveToStorage();
        }

        function createNote(name, parentNote = null) {
            if (!state.currentNotebook) return;

            const note = {
                id: Date.now().toString(),
                name: name,
                canvasData: null,
                textBoxes: [],
                mediaEmbeds: [],
                children: [],
                parentId: parentNote ? parentNote.id : null,
                isOpen: false,
                status: 'none' // none, in-progress, finished, needs-review
            };
            
            if (parentNote) {
                // Add as child of parent note
                if (!parentNote.children) parentNote.children = [];
                parentNote.children.push(note);
            } else {
                // Add to notebook root
                state.currentNotebook.notes.push(note);
            }
            
            selectNote(state.currentNotebook, note);
            renderNotebooks();
            saveToStorage();
        }

        // Create sub-note
        function createSubNote(notebookIndex, noteId, e) {
            e.stopPropagation();
            const notebook = state.notebooks[notebookIndex];
            const parentNote = findNoteById(notebook, noteId);
            if (parentNote) {
                state.currentNotebook = notebook;
                state.parentNoteForSubnote = parentNote;
                showModal('subnote');
            }
        }

        // Find note by ID (recursive)
        function findNoteById(notebook, noteId, notes = null) {
            const searchNotes = notes || notebook.notes;
            for (const note of searchNotes) {
                if (note.id === noteId) return note;
                if (note.children && note.children.length > 0) {
                    const found = findNoteById(notebook, noteId, note.children);
                    if (found) return found;
                }
            }
            return null;
        }

        // Find parent note
        function findParentNote(notebook, noteId, notes = null, parent = null) {
            const searchNotes = notes || notebook.notes;
            for (const note of searchNotes) {
                if (note.id === noteId) return parent;
                if (note.children && note.children.length > 0) {
                    const found = findParentNote(notebook, noteId, note.children, note);
                    if (found !== undefined) return found;
                }
            }
            return undefined;
        }

        // Get note path (breadcrumb)
        function getNotePath(notebook, noteId) {
            const path = [];
            let currentId = noteId;
            
            while (currentId) {
                const note = findNoteById(notebook, currentId);
                if (note) {
                    path.unshift(note);
                    currentId = note.parentId;
                } else {
                    break;
                }
            }
            
            return path;
        }

        function selectNote(notebook, note) {
            // Save current note before switching
            if (state.currentNote) {
                saveNoteData();
            }

            state.currentNotebook = notebook;
            state.currentNote = note;
            
            // Switch to editor view
            showEditor();
            
            // Show canvas
            document.getElementById('empty-state').style.display = 'none';
            document.getElementById('canvas-wrapper').style.display = 'block';
            document.getElementById('toolbar').style.display = 'flex';
            
            // Always initialize canvases first
            initCanvases();
            // Apply current canvas transform (zoom / pan) to ensure wrapper matches state
            updateCanvasTransform();
            
            // Load note data or create blank canvas
            if (note.canvasData) {
                loadNoteData(note);
            } else {
                // Clear text layer for new note
                textLayer.innerHTML = '';
                drawCtx.fillStyle = getCanvasBackground();
                drawCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                // Clear undo history and start version timer
                clearUndoHistory();
                versionHistory = note.versionHistory || [];
                startVersionHistoryTimer();
                saveInitialState();
            }

            // Update UI with breadcrumb path
            updateBreadcrumb(notebook, note);
            
            // Update status selector
            const statusSelect = document.getElementById('status-select');
            if (statusSelect) {
                statusSelect.value = note.status || 'none';
            }
            
            // Render sub-note blocks on canvas
            renderSubnoteBlocks(note);
            
            renderNotebooks();
        }

        // Render sub-note links on canvas (Notion-style blocks)
        function renderSubnoteBlocks(note) {
            // Remove existing sub-note blocks
            const existingBlocks = document.querySelectorAll('.subnote-block');
            existingBlocks.forEach(block => block.remove());
            
            if (!note || !note.children || note.children.length === 0) return;
            
            const textLayer = document.getElementById('text-layer');
            
            // Position sub-notes starting from a default location
            // Store positions in note.subnotePositions if they exist
            if (!note.subnotePositions) {
                note.subnotePositions = {};
            }
            
            note.children.forEach((child, index) => {
                // Get stored position or calculate default (center of canvas)
                const pos = note.subnotePositions[child.id] || {
                    x: 1800,
                    y: 1800 + (index * 80)
                };
                
                const block = document.createElement('div');
                block.className = 'subnote-block';
                block.style.left = pos.x + 'px';
                block.style.top = pos.y + 'px';
                block.setAttribute('data-subnote-id', child.id);
                
                block.innerHTML = `
                    <div class="subnote-block-icon"></div>
                    <div class="subnote-block-content">
                        <div class="subnote-block-name">${child.name}</div>
                        <div class="subnote-block-hint">Click to open</div>
                    </div>
                    <div class="subnote-block-arrow"></div>
                `;
                
                // Click to navigate
                block.addEventListener('click', (e) => {
                    if (!block.classList.contains('dragging')) {
                        selectNoteById(state.currentNotebook.id, child.id);
                    }
                });
                
                // Make draggable
                makeSubnoteBlockDraggable(block, child.id);
                
                textLayer.appendChild(block);
            });
        }

        // Make sub-note block draggable
        function makeSubnoteBlockDraggable(block, childId) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            block.addEventListener('mousedown', (e) => {
                if (e.target.closest('.subnote-block-arrow')) return;
                
                isDragging = false;
                startX = e.clientX;
                startY = e.clientY;
                initialX = parseInt(block.style.left) || 0;
                initialY = parseInt(block.style.top) || 0;
                
                const onMouseMove = (e) => {
                    const dx = (e.clientX - startX) / state.zoom;
                    const dy = (e.clientY - startY) / state.zoom;
                    
                    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                        isDragging = true;
                        block.classList.add('dragging');
                    }
                    
                    if (isDragging) {
                        block.style.left = (initialX + dx) + 'px';
                        block.style.top = (initialY + dy) + 'px';
                    }
                };
                
                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    
                    if (isDragging) {
                        // Save new position
                        if (!state.currentNote.subnotePositions) {
                            state.currentNote.subnotePositions = {};
                        }
                        state.currentNote.subnotePositions[childId] = {
                            x: parseInt(block.style.left),
                            y: parseInt(block.style.top)
                        };
                        markUnsaved();
                        
                        // Remove dragging class after a short delay
                        setTimeout(() => {
                            block.classList.remove('dragging');
                        }, 100);
                    }
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        // ==================== MEDIA EMBED FUNCTIONS ====================
        
        // Detect media type from URL
        function detectMediaType(url) {
            const urlLower = url.toLowerCase();
            
            // Image extensions
            if (/\.(jpg|jpeg|png|gif|webp|svg|bmp|ico)(\?.*)?$/i.test(url)) {
                return 'image';
            }
            
            // Video extensions
            if (/\.(mp4|webm|ogg|mov|avi|mkv)(\?.*)?$/i.test(url)) {
                return 'video';
            }
            
            // Audio extensions
            if (/\.(mp3|wav|ogg|m4a|flac|aac|wma)(\?.*)?$/i.test(url)) {
                return 'audio';
            }
            
            // YouTube
            if (urlLower.includes('youtube.com/watch') || urlLower.includes('youtu.be/')) {
                return 'youtube';
            }
            
            // Vimeo
            if (urlLower.includes('vimeo.com/')) {
                return 'vimeo';
            }
            
            // Twitter/X
            if (urlLower.includes('twitter.com/') || urlLower.includes('x.com/')) {
                return 'twitter';
            }
            
            // Spotify
            if (urlLower.includes('spotify.com/')) {
                return 'spotify';
            }
            
            // SoundCloud
            if (urlLower.includes('soundcloud.com/')) {
                return 'soundcloud';
            }
            
            // Google Maps
            if (urlLower.includes('google.com/maps') || urlLower.includes('goo.gl/maps')) {
                return 'maps';
            }
            
            // Generic iframe for other URLs
            if (url.startsWith('http://') || url.startsWith('https://')) {
                return 'iframe';
            }
            
            // Data URLs (for uploaded files)
            if (url.startsWith('data:image/')) {
                return 'image';
            }
            if (url.startsWith('data:video/')) {
                return 'video';
            }
            if (url.startsWith('data:audio/')) {
                return 'audio';
            }
            
            return null;
        }

        // Get embed URL for various services
        function getEmbedUrl(url, type) {
            switch (type) {
                case 'youtube': {
                    let videoId = '';
                    if (url.includes('youtu.be/')) {
                        // Handle youtu.be/VIDEO_ID format
                        videoId = url.split('youtu.be/')[1].split(/[?&#]/)[0];
                    } else if (url.includes('youtube.com/watch')) {
                        // Handle youtube.com/watch?v=VIDEO_ID format
                        try {
                            const urlObj = new URL(url);
                            videoId = urlObj.searchParams.get('v');
                        } catch (e) {
                            // Fallback parsing
                            const match = url.match(/[?&]v=([^&]+)/);
                            videoId = match ? match[1] : '';
                        }
                    } else if (url.includes('youtube.com/embed/')) {
                        // Already an embed URL
                        videoId = url.split('youtube.com/embed/')[1].split(/[?&#]/)[0];
                    } else if (url.includes('youtube.com/v/')) {
                        // Old style embed URL
                        videoId = url.split('youtube.com/v/')[1].split(/[?&#]/)[0];
                    }
                    if (!videoId) {
                        return url; // Return original if parsing failed
                    }
                    // Use youtube-nocookie.com for better privacy and fewer errors
                    return `https://www.youtube-nocookie.com/embed/${videoId}?rel=0`;
                }
                case 'vimeo': {
                    const videoId = url.split('vimeo.com/')[1].split(/[?&/]/)[0];
                    return `https://player.vimeo.com/video/${videoId}`;
                }
                case 'spotify': {
                    // Convert spotify URL to embed URL
                    const spotifyPath = url.split('spotify.com/')[1];
                    return `https://open.spotify.com/embed/${spotifyPath}`;
                }
                default:
                    return url;
            }
        }

        // Create media embed element
        function createMediaEmbed(url, type, options = {}) {
            const textLayer = document.getElementById('text-layer');
            
            const embed = document.createElement('div');
            embed.className = 'media-embed';
            embed.setAttribute('data-embed-id', options.id || Date.now().toString());
            embed.setAttribute('data-embed-type', type);
            embed.setAttribute('data-embed-url', url);
            
            // Set position - default to center of canvas
            embed.style.left = options.left || '1800px';
            embed.style.top = options.top || '1800px';
            
            // Set size - use provided dimensions or auto-size later
            if (options.width) embed.style.width = options.width;
            if (options.height) embed.style.height = options.height;
            
            // For new embeds without saved dimensions, start with auto sizing
            const autoSize = !options.width && !options.height;
            
            // Create content container
            const content = document.createElement('div');
            content.className = 'media-embed-content';
            
            // Create controls
            const controls = document.createElement('div');
            controls.className = 'media-embed-controls';
            controls.innerHTML = `
                <button class="media-embed-btn" onclick="deleteMediaEmbed(this.closest('.media-embed'))" title="Delete"></button>
            `;
            
            // Create resize handle
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'media-embed-resize';
            
            // Add loading state
            content.innerHTML = '<div class="media-embed-loading">Loading...</div>';
            
            embed.appendChild(content);
            embed.appendChild(controls);
            embed.appendChild(resizeHandle);
            textLayer.appendChild(embed);
            
            // Add resize functionality
            makeMediaEmbedResizable(embed, resizeHandle);
            
            // Load the actual content based on type
            switch (type) {
                case 'image':
                    loadImageEmbed(embed, content, url, autoSize);
                    break;
                case 'video':
                    loadVideoEmbed(embed, content, url, autoSize);
                    break;
                case 'audio':
                    loadAudioEmbed(embed, content, url);
                    if (autoSize) {
                        embed.style.width = '320px';
                        embed.style.height = '120px';
                    }
                    break;
                case 'youtube':
                    loadYouTubeEmbed(content, url);
                    if (autoSize) {
                        embed.style.width = '560px';
                        embed.style.height = '315px';
                    }
                    break;
                case 'vimeo':
                    loadVimeoEmbed(content, url);
                    if (autoSize) {
                        embed.style.width = '560px';
                        embed.style.height = '315px';
                    }
                    break;
                case 'spotify':
                    loadIframeEmbed(content, getEmbedUrl(url, type));
                    if (autoSize) {
                        embed.style.width = '400px';
                        embed.style.height = '152px';
                    }
                    break;
                case 'iframe':
                    loadIframeEmbed(content, url);
                    if (autoSize) {
                        embed.style.width = '500px';
                        embed.style.height = '400px';
                    }
                    break;
                default:
                    content.innerHTML = '<div class="media-embed-error">Unsupported media type</div>';
                    if (autoSize) {
                        embed.style.width = '200px';
                        embed.style.height = '100px';
                    }
            }
            
            // Make draggable
            makeMediaEmbedDraggable(embed);
            
            // Add select handler
            addMediaEmbedSelectHandler(embed);
            
            markUnsaved();
            return embed;
        }

        function loadImageEmbed(embed, container, url, autoSize) {
            const img = new Image();
            img.onload = () => {
                container.innerHTML = '';
                container.appendChild(img);
                
                // Auto-size embed to fit image (with max constraints)
                if (autoSize) {
                    const maxWidth = 800;
                    const maxHeight = 600;
                    let width = img.naturalWidth;
                    let height = img.naturalHeight;
                    
                    // Scale down if too large
                    if (width > maxWidth) {
                        height = height * (maxWidth / width);
                        width = maxWidth;
                    }
                    if (height > maxHeight) {
                        width = width * (maxHeight / height);
                        height = maxHeight;
                    }
                    
                    // Minimum size
                    width = Math.max(width, 100);
                    height = Math.max(height, 80);
                    
                    embed.style.width = width + 'px';
                    embed.style.height = height + 'px';
                }
            };
            img.onerror = () => {
                container.innerHTML = '<div class="media-embed-error">Failed to load image</div>';
                if (autoSize) {
                    embed.style.width = '200px';
                    embed.style.height = '100px';
                }
            };
            img.src = url;
            img.style.pointerEvents = 'none';
        }

        function loadVideoEmbed(embed, container, url, autoSize) {
            const video = document.createElement('video');
            video.controls = true;
            video.src = url;
            video.onloadedmetadata = () => {
                container.innerHTML = '';
                container.appendChild(video);
                
                // Auto-size embed to fit video (with max constraints)
                if (autoSize) {
                    const maxWidth = 800;
                    const maxHeight = 600;
                    let width = video.videoWidth;
                    let height = video.videoHeight;
                    
                    // Scale down if too large
                    if (width > maxWidth) {
                        height = height * (maxWidth / width);
                        width = maxWidth;
                    }
                    if (height > maxHeight) {
                        width = width * (maxHeight / height);
                        height = maxHeight;
                    }
                    
                    // Minimum size
                    width = Math.max(width, 200);
                    height = Math.max(height, 150);
                    
                    embed.style.width = width + 'px';
                    embed.style.height = height + 'px';
                }
            };
            video.onerror = () => {
                container.innerHTML = '<div class="media-embed-error">Failed to load video</div>';
                if (autoSize) {
                    embed.style.width = '300px';
                    embed.style.height = '200px';
                }
            };
        }

        function loadAudioEmbed(embed, container, url) {
            container.innerHTML = '';
            container.style.flexDirection = 'column';
            container.style.padding = '15px';
            
            const icon = document.createElement('div');
            icon.className = 'media-embed-audio-icon';
            icon.textContent = '';
            
            const audio = document.createElement('audio');
            audio.controls = true;
            audio.src = url;
            audio.style.width = '100%';
            
            container.appendChild(icon);
            container.appendChild(audio);
            
            audio.onerror = () => {
                container.innerHTML = '<div class="media-embed-error">Failed to load audio</div>';
            };
        }

        function loadIframeEmbed(container, url) {
            const iframe = document.createElement('iframe');
            iframe.src = url;
            iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
            iframe.allowFullscreen = true;
            iframe.setAttribute('frameborder', '0');
            iframe.setAttribute('referrerpolicy', 'strict-origin-when-cross-origin');
            iframe.onload = () => {
                container.innerHTML = '';
                container.appendChild(iframe);
            };
            iframe.onerror = () => {
                container.innerHTML = '<div class="media-embed-error">Failed to load content</div>';
            };
            // Add iframe immediately since onload may not fire for cross-origin
            container.innerHTML = '';
            container.appendChild(iframe);
        }

        // Extract YouTube video ID from URL
        function getYouTubeVideoId(url) {
            let videoId = '';
            if (url.includes('youtu.be/')) {
                videoId = url.split('youtu.be/')[1].split(/[?&#]/)[0];
            } else if (url.includes('youtube.com/watch')) {
                try {
                    const urlObj = new URL(url);
                    videoId = urlObj.searchParams.get('v');
                } catch (e) {
                    const match = url.match(/[?&]v=([^&]+)/);
                    videoId = match ? match[1] : '';
                }
            } else if (url.includes('youtube.com/embed/')) {
                videoId = url.split('youtube.com/embed/')[1].split(/[?&#]/)[0];
            } else if (url.includes('youtube.com/v/')) {
                videoId = url.split('youtube.com/v/')[1].split(/[?&#]/)[0];
            }
            return videoId;
        }

        // Load YouTube embed - loads iframe directly to avoid Error 153
        function loadYouTubeEmbed(container, url) {
            const videoId = getYouTubeVideoId(url);
            if (!videoId) {
                container.innerHTML = '<div class="media-embed-error"> Invalid YouTube URL<br><small>Please check the URL and try again</small></div>';
                return;
            }
            
            // Create iframe without origin parameter (works better for local files)
            // Using minimal parameters to maximize compatibility
            const iframe = document.createElement('iframe');
            iframe.src = `https://www.youtube.com/embed/${videoId}?rel=0&modestbranding=1&playsinline=1`;
            iframe.setAttribute('frameborder', '0');
            iframe.setAttribute('allowfullscreen', 'true');
            iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share');
            iframe.setAttribute('referrerpolicy', 'no-referrer-when-downgrade');
            iframe.setAttribute('sandbox', 'allow-same-origin allow-scripts allow-popups allow-forms allow-presentation');
            iframe.style.cssText = 'width:100%;height:100%;border:none;display:block;background:#000;';
            
            // Detect if embedding failed (Error 153) and show fallback
            let embedFailed = false;
            const errorTimeout = setTimeout(() => {
                embedFailed = true;
            }, 5000);
            
            iframe.onload = () => {
                clearTimeout(errorTimeout);
                // Try to detect if iframe loaded properly
                try {
                    if (iframe.contentWindow) {
                        // Successfully loaded
                    }
                } catch (e) {
                    // Cross-origin, but that's expected
                }
            };
            
            // Fallback: Create a thumbnail with "Watch on YouTube" button
            const createFallback = () => {
                const thumbnailUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;
                const fallback = document.createElement('div');
                fallback.style.cssText = 'position:relative;width:100%;height:100%;background:#000 url(' + thumbnailUrl + ') center/cover;display:flex;align-items:center;justify-content:center;cursor:pointer;';
                fallback.innerHTML = `
                    <div style="background:rgba(0,0,0,0.85);padding:24px 32px;border-radius:12px;text-align:center;color:white;backdrop-filter:blur(8px);border:2px solid rgba(255,255,255,0.1);">
                        <div style="font-size:48px;margin-bottom:12px;"></div>
                        <div style="font-size:16px;font-weight:600;margin-bottom:8px;">Video Embedding Restricted</div>
                        <div style="font-size:13px;color:#ccc;margin-bottom:16px;">This video can't be embedded</div>
                        <button style="background:#FF0000;color:white;border:none;padding:12px 24px;border-radius:8px;font-size:14px;font-weight:600;cursor:pointer;font-family:inherit;box-shadow:0 4px 12px rgba(255,0,0,0.3);" onmouseover="this.style.background='#CC0000'" onmouseout="this.style.background='#FF0000'">
                            Watch on YouTube
                        </button>
                    </div>
                `;
                fallback.onclick = () => {
                    window.open('https://youtube.com/watch?v=' + videoId, '_blank');
                };
                return fallback;
            };
            
            container.innerHTML = '<div class="media-embed-loading"> Loading video...</div>';
            
            // Replace loading with iframe
            setTimeout(() => {
                container.innerHTML = '';
                container.appendChild(iframe);
                
                // Check if we're on file:// protocol
                if (window.location.protocol === 'file:') {
                    // Replace with fallback immediately on file://
                    setTimeout(() => {
                        container.innerHTML = '';
                        container.appendChild(createFallback());
                    }, 1000);
                }
            }, 100);
        }

        // Load Vimeo embed with thumbnail fallback
        function loadVimeoEmbed(container, url) {
            const videoId = url.split('vimeo.com/')[1]?.split(/[?&/]/)[0];
            if (!videoId) {
                container.innerHTML = '<div class="media-embed-error">Invalid Vimeo URL</div>';
                return;
            }
            
            const watchUrl = `https://vimeo.com/${videoId}`;
            
            // Create a preview that links to Vimeo
            const wrapper = document.createElement('div');
            wrapper.className = 'vimeo-preview';
            wrapper.style.cssText = 'position:relative;width:100%;height:100%;cursor:pointer;background:linear-gradient(135deg,#1ab7ea,#162221);display:flex;align-items:center;justify-content:center;flex-direction:column;';
            
            const playBtn = document.createElement('div');
            playBtn.innerHTML = `<svg viewBox="0 0 24 24" style="width:64px;height:64px;fill:#fff;opacity:0.9;"><path d="M8 5v14l11-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/></svg>`;
            
            const label = document.createElement('div');
            label.textContent = 'Click to watch on Vimeo';
            label.style.cssText = 'color:#fff;font-size:14px;margin-top:10px;opacity:0.8;';
            
            wrapper.appendChild(playBtn);
            wrapper.appendChild(label);
            
            wrapper.onclick = (e) => {
                e.stopPropagation();
                window.open(watchUrl, '_blank');
            };
            
            container.innerHTML = '';
            container.appendChild(wrapper);
        }

        function deleteMediaEmbed(embed) {
            if (confirm('Delete this media?')) {
                embed.remove();
                markUnsaved();
            }
        }

        function makeMediaEmbedDraggable(embed) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            
            embed.addEventListener('mousedown', (e) => {
                // Don't drag if clicking on controls, resize handle, or iframe
                if (e.target.closest('.media-embed-controls') || 
                    e.target.closest('.media-embed-resize') ||
                    e.target.closest('.media-embed-content iframe')) return;
                
                isDragging = false;
                startX = e.clientX;
                startY = e.clientY;
                initialX = parseInt(embed.style.left) || 0;
                initialY = parseInt(embed.style.top) || 0;
                
                const onMouseMove = (e) => {
                    const dx = (e.clientX - startX) / state.zoom;
                    const dy = (e.clientY - startY) / state.zoom;
                    
                    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                        isDragging = true;
                        embed.classList.add('dragging');
                    }
                    
                    if (isDragging) {
                        embed.style.left = (initialX + dx) + 'px';
                        embed.style.top = (initialY + dy) + 'px';
                    }
                };
                
                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    
                    if (isDragging) {
                        markUnsaved();
                        setTimeout(() => embed.classList.remove('dragging'), 100);
                    }
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        function makeMediaEmbedResizable(embed, handle) {
            handle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                const startX = e.clientX;
                const startY = e.clientY;
                const startWidth = embed.offsetWidth;
                const startHeight = embed.offsetHeight;
                
                // Check if this is an image or video (lock aspect ratio for these)
                const embedType = embed.getAttribute('data-embed-type');
                const lockRatio = (embedType === 'image' || embedType === 'video');
                
                // Get actual aspect ratio from the media element
                let aspectRatio = startWidth / startHeight;
                if (lockRatio) {
                    const img = embed.querySelector('img');
                    const video = embed.querySelector('video');
                    if (img && img.naturalWidth && img.naturalHeight) {
                        aspectRatio = img.naturalWidth / img.naturalHeight;
                    } else if (video && video.videoWidth && video.videoHeight) {
                        aspectRatio = video.videoWidth / video.videoHeight;
                    }
                }
                
                const onMouseMove = (e) => {
                    // Calculate diagonal distance from start point
                    const dx = (e.clientX - startX) / state.zoom;
                    const dy = (e.clientY - startY) / state.zoom;
                    
                    let newWidth, newHeight;
                    
                    if (lockRatio) {
                        // Use diagonal movement for proportional resize
                        const diagonalDelta = (dx + dy) / 2;
                        newWidth = Math.max(100, startWidth + diagonalDelta);
                        newHeight = newWidth / aspectRatio;
                        
                        // Ensure minimum height
                        if (newHeight < 80) {
                            newHeight = 80;
                            newWidth = newHeight * aspectRatio;
                        }
                    } else {
                        newWidth = Math.max(100, startWidth + dx);
                        newHeight = Math.max(80, startHeight + dy);
                    }
                    
                    embed.style.width = newWidth + 'px';
                    embed.style.height = newHeight + 'px';
                };
                
                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    markUnsaved();
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }

        function addMediaEmbedSelectHandler(embed) {
            embed.addEventListener('click', (e) => {
                if (state.tool === 'select') {
                    // Deselect all other embeds and text boxes
                    document.querySelectorAll('.media-embed.selected, .text-box.selected').forEach(el => {
                        el.classList.remove('selected');
                    });
                    embed.classList.add('selected');
                    e.stopPropagation();
                }
            });
        }

        // Handle paste event for media URLs
        function handlePaste(e) {
            // Don't intercept paste if typing in a text box
            if (document.activeElement.classList.contains('text-box') || 
                document.activeElement.tagName === 'INPUT' ||
                document.activeElement.tagName === 'TEXTAREA') {
                return;
            }
            
            // Only handle paste in editor view
            if (state.currentView !== 'editor' || !state.currentNote) return;
            
            const clipboardData = e.clipboardData || window.clipboardData;
            
            // Check for image data first
            const items = clipboardData.items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    e.preventDefault();
                    const blob = items[i].getAsFile();
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        createMediaEmbed(event.target.result, 'image');
                    };
                    reader.readAsDataURL(blob);
                    return;
                }
            }
            
            // Check for text (URL)
            const text = clipboardData.getData('text').trim();
            if (text) {
                const mediaType = detectMediaType(text);
                if (mediaType) {
                    e.preventDefault();
                    createMediaEmbed(text, mediaType);
                }
            }
        }

        // Add paste event listener
        document.addEventListener('paste', handlePaste);

        // Toggle media dropdown
        function toggleMediaDropdown(e) {
            e.stopPropagation();
            const dropdown = document.getElementById('media-dropdown');
            dropdown.classList.toggle('show');
        }

        // Close media dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('media-dropdown');
            if (dropdown && !e.target.closest('.media-dropdown')) {
                dropdown.classList.remove('show');
            }
        });

        // Show link embed dialog
        function showLinkEmbedDialog() {
            if (state.currentView !== 'editor' || !state.currentNote) {
                alert('Please open a note first to add media');
                return;
            }
            document.getElementById('media-dropdown')?.classList.remove('show');
            const modal = document.getElementById('link-embed-modal');
            const title = document.getElementById('link-embed-title');
            const input = document.getElementById('link-embed-input');
            
            title.textContent = 'Embed Media Link';
            input.placeholder = 'Paste YouTube, Vimeo, or media URL...';
            modal.classList.add('show');
            input.value = '';
            input.focus();
        }
        
        // Show YouTube-specific dialog
        function showYouTubeDialog() {
            if (state.currentView !== 'editor' || !state.currentNote) {
                alert('Please open a note first to embed a video');
                return;
            }
            document.getElementById('media-dropdown')?.classList.remove('show');
            const modal = document.getElementById('link-embed-modal');
            const title = document.getElementById('link-embed-title');
            const input = document.getElementById('link-embed-input');
            
            title.textContent = ' Embed YouTube Video';
            input.placeholder = 'Paste YouTube URL (e.g., https://youtube.com/watch?v=...)';
            modal.classList.add('show');
            input.value = '';
            input.focus();
        }

        // Close link embed dialog
        function closeLinkEmbedDialog() {
            document.getElementById('link-embed-modal').classList.remove('show');
        }

        // Embed link from dialog
        function embedLinkFromDialog() {
            const input = document.getElementById('link-embed-input');
            const url = input.value.trim();
            
            if (!url) {
                alert('Please enter a URL');
                return;
            }
            
            const type = detectMediaType(url);
            if (!type) {
                alert('Could not detect media type. Please enter a valid image, video, or audio URL.');
                return;
            }
            
            createMediaEmbed(url, type, {
                left: '1800px',
                top: '1800px'
            });
            
            closeLinkEmbedDialog();
        }

        // Handle Enter key in link embed dialog
        document.addEventListener('keydown', (e) => {
            const modal = document.getElementById('link-embed-modal');
            if (modal && modal.classList.contains('show')) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    embedLinkFromDialog();
                } else if (e.key === 'Escape') {
                    closeLinkEmbedDialog();
                }
            }
        });

        // Close modal when clicking backdrop
        document.getElementById('link-embed-modal')?.addEventListener('click', (e) => {
            if (e.target.classList.contains('link-embed-modal')) {
                closeLinkEmbedDialog();
            }
        });

        // Trigger file upload dialog
        function triggerMediaUpload() {
            if (state.currentView !== 'editor' || !state.currentNote) {
                alert('Please open a note first to add media');
                return;
            }
            document.getElementById('media-dropdown').classList.remove('show');
            document.getElementById('media-upload').click();
        }

        // Handle file upload from file input
        function handleFileUpload(e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;
            
            Array.from(files).forEach((file, index) => {
                embedLocalFile(file, index);
            });
            
            // Reset file input so same file can be selected again
            e.target.value = '';
        }

        // Embed a local file
        function embedLocalFile(file, offsetIndex = 0) {
            const reader = new FileReader();
            
            reader.onload = (event) => {
                const dataUrl = event.target.result;
                let type = 'image';
                
                if (file.type.startsWith('video/')) {
                    type = 'video';
                } else if (file.type.startsWith('audio/')) {
                    type = 'audio';
                } else if (file.type.startsWith('image/')) {
                    type = 'image';
                }
                
                // Offset each file slightly so they don't stack exactly on top of each other
                const options = {
                    left: (1800 + offsetIndex * 30) + 'px',
                    top: (1800 + offsetIndex * 30) + 'px'
                };
                
                createMediaEmbed(dataUrl, type, options);
            };
            
            reader.onerror = () => {
                alert('Failed to load file: ' + file.name);
            };
            
            reader.readAsDataURL(file);
        }

        // Handle drag and drop of files onto canvas
        function setupDragAndDrop() {
            const canvasContainer = document.getElementById('canvas-container');
            
            canvasContainer.addEventListener('dragover', (e) => {
                if (state.currentView !== 'editor' || !state.currentNote) return;
                e.preventDefault();
                e.stopPropagation();
                canvasContainer.classList.add('drag-over');
            });
            
            canvasContainer.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                canvasContainer.classList.remove('drag-over');
            });
            
            canvasContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                canvasContainer.classList.remove('drag-over');
                
                if (state.currentView !== 'editor' || !state.currentNote) return;
                
                const files = e.dataTransfer.files;
                if (files && files.length > 0) {
                    Array.from(files).forEach((file, index) => {
                        // Check if it's an acceptable file type
                        if (file.type.startsWith('image/') || file.type.startsWith('video/') || file.type.startsWith('audio/')) {
                            embedLocalFile(file, index);
                        }
                    });
                }
                
                // Also check for dropped URLs (text/uri-list or text/plain)
                const url = e.dataTransfer.getData('text/uri-list') || e.dataTransfer.getData('text/plain');
                if (url && !files.length) {
                    const mediaType = detectMediaType(url);
                    if (mediaType) {
                        createMediaEmbed(url, mediaType);
                    }
                }
            });
        }

        // Initialize drag and drop
        setupDragAndDrop();

        // ==================== END MEDIA EMBED FUNCTIONS ====================

        function updateBreadcrumb(notebook, note) {
            const path = getNotePath(notebook, note.id);
            let breadcrumb = `<span class="breadcrumb-item" onclick="showHomePage()">Home</span>`;
            breadcrumb += `<span class="breadcrumb-separator"> / </span>`;
            breadcrumb += `<span class="breadcrumb-item" onclick="toggleNotebook(state.notebooks.find(n => n.id === '${notebook.id}'))">${notebook.name}</span>`;
            
            path.forEach((pathNote, index) => {
                breadcrumb += `<span class="breadcrumb-separator"> / </span>`;
                if (index === path.length - 1) {
                    breadcrumb += `<span class="breadcrumb-current">${pathNote.name}</span>`;
                } else {
                    breadcrumb += `<span class="breadcrumb-item" onclick="selectNoteById('${notebook.id}', '${pathNote.id}')">${pathNote.name}</span>`;
                }
            });
            
            document.getElementById('note-info').innerHTML = breadcrumb;
        }

        function deleteNote(notebook, note, e) {
            e.stopPropagation();
            if (confirm(`Delete "${note.name}"?`)) {
                const index = notebook.notes.indexOf(note);
                notebook.notes.splice(index, 1);
                
                // Remove from pinned if pinned
                const pinnedIndex = state.pinnedNotes.findIndex(p => p.notebookId === notebook.id && p.noteId === note.id);
                if (pinnedIndex > -1) {
                    state.pinnedNotes.splice(pinnedIndex, 1);
                    savePinnedToStorage();
                }
                
                if (state.currentNote === note) {
                    state.currentNote = null;
                    showHomePage();
                }
                
                renderNotebooks();
                renderHomePage();
                saveToStorage();
            }
        }

        function deleteNotebook(notebook, e) {
            e.stopPropagation();
            if (confirm(`Delete notebook "${notebook.name}" and all its notes?`)) {
                const index = state.notebooks.indexOf(notebook);
                state.notebooks.splice(index, 1);
                
                // Remove all pinned notes from this notebook
                state.pinnedNotes = state.pinnedNotes.filter(p => p.notebookId !== notebook.id);
                savePinnedToStorage();
                
                if (state.currentNotebook === notebook) {
                    state.currentNotebook = null;
                    state.currentNote = null;
                    showHomePage();
                }
                
                renderNotebooks();
                renderHomePage();
                saveToStorage();
            }
        }

        function toggleNotebook(notebook) {
            notebook.isOpen = !notebook.isOpen;
            renderNotebooks();
        }

        function toggleNoteChildren(notebookIndex, noteId, e) {
            e.stopPropagation();
            const notebook = state.notebooks[notebookIndex];
            const note = findNoteById(notebook, noteId);
            if (note) {
                note.isOpen = !note.isOpen;
                renderNotebooks();
                saveToStorage();
            }
        }

        // Get status label for badge
        function getStatusLabel(status, short = false) {
            if (short) {
                switch(status) {
                    case 'in-progress': return '';
                    case 'finished': return '';
                    case 'needs-review': return '';
                    default: return '';
                }
            }
            switch(status) {
                case 'in-progress': return 'In Progress';
                case 'finished': return 'Done';
                case 'needs-review': return 'Review';
                default: return '';
            }
        }

        // Update note status from toolbar
        function updateNoteStatus() {
            if (!state.currentNote) return;
            
            const statusSelect = document.getElementById('status-select');
            const newStatus = statusSelect.value;
            
            state.currentNote.status = newStatus;
            renderNotebooks();
            renderHomePage();
            saveToStorage();
            markUnsaved();
        }

        // Render a single note item with its children recursively
        function renderNoteItem(notebook, note, notebookIndex, depth = 0) {
            const isPinned = isNotePinned(notebook.id, note.id);
            const hasChildren = note.children && note.children.length > 0;
            const isActive = state.currentNote && state.currentNote.id === note.id;
            const statusBadge = note.status && note.status !== 'none' ? `<div class="note-item-status-row"><span class="status-badge ${note.status}">${getStatusLabel(note.status)}</span></div>` : '';
            
            let html = `
                <div class="note-item-container">
                    <div class="note-item ${isActive ? 'active' : ''}" onclick="selectNoteById('${notebook.id}', '${note.id}')">
                        <div class="note-item-header">
                            <span>
                                <span class="note-toggle ${hasChildren ? (note.isOpen ? 'open' : '') : 'hidden'}" onclick="toggleNoteChildren(${notebookIndex}, '${note.id}', event)"></span>
                                ${note.name}
                            </span>
                            <div>
                                <button class="add-subnote-btn" onclick="createSubNote(${notebookIndex}, '${note.id}', event)" title="Add sub-note">+</button>
                                <button class="pin-btn ${isPinned ? 'pinned' : ''}" onclick="togglePin(event, '${notebook.id}', '${note.id}')" title="${isPinned ? 'Unpin' : 'Pin'}">${isPinned ? '' : ''}</button>
                                <button class="delete-btn" onclick="deleteNoteById('${notebook.id}', '${note.id}', event)"></button>
                            </div>
                        </div>
                        ${statusBadge}
                    </div>
            `;
            
            if (hasChildren) {
                html += `<div class="sub-notes-list ${note.isOpen ? 'open' : ''}">`;
                note.children.forEach(childNote => {
                    html += renderNoteItem(notebook, childNote, notebookIndex, depth + 1);
                });
                html += `</div>`;
            }
            
            html += `</div>`;
            return html;
        }

        // Render notebooks
        function renderNotebooks() {
            const container = document.getElementById('notebooks-container');
            container.innerHTML = '';

            state.notebooks.forEach((notebook, notebookIndex) => {
                const notebookEl = document.createElement('div');
                notebookEl.className = 'notebook';
                
                let notesHtml = '';
                notebook.notes.forEach(note => {
                    notesHtml += renderNoteItem(notebook, note, notebookIndex);
                });
                
                notebookEl.innerHTML = `
                    <div class="notebook-header ${state.currentNotebook && state.currentNotebook.id === notebook.id ? 'active' : ''}" onclick="toggleNotebook(state.notebooks[${notebookIndex}])">
                        <span class="notebook-icon"></span>
                        <span class="notebook-name">${notebook.name}</span>
                        <button class="add-btn" onclick="event.stopPropagation(); state.currentNotebook = state.notebooks[${notebookIndex}]; showModal('note');" style="margin-right: 8px; width: 18px; height: 18px; font-size: 0.75rem;">+</button>
                        <button class="delete-btn" onclick="deleteNotebook(state.notebooks[${notebookIndex}], event)"></button>
                        <span class="notebook-toggle ${notebook.isOpen ? 'open' : ''}"></span>
                    </div>
                    <div class="notes-list ${notebook.isOpen ? 'open' : ''}">
                        ${notesHtml}
                    </div>
                `;
                container.appendChild(notebookEl);
            });
        }

        // Select note by ID
        function selectNoteById(notebookId, noteId) {
            const notebook = state.notebooks.find(n => n.id === notebookId);
            if (notebook) {
                const note = findNoteById(notebook, noteId);
                if (note) {
                    selectNote(notebook, note);
                }
            }
        }

        // Delete note by ID (handles nested notes)
        function deleteNoteById(notebookId, noteId, e) {
            e.stopPropagation();
            const notebook = state.notebooks.find(n => n.id === notebookId);
            if (!notebook) return;
            
            const note = findNoteById(notebook, noteId);
            if (!note) return;
            
            const childCount = countAllChildren(note);
            const message = childCount > 0 
                ? `Delete "${note.name}" and its ${childCount} sub-note(s)?`
                : `Delete "${note.name}"?`;
            
            if (confirm(message)) {
                removeNoteFromTree(notebook, noteId);
                
                // Remove from pinned if pinned
                const pinnedIndex = state.pinnedNotes.findIndex(p => p.notebookId === notebook.id && p.noteId === noteId);
                if (pinnedIndex > -1) {
                    state.pinnedNotes.splice(pinnedIndex, 1);
                    savePinnedToStorage();
                }
                
                if (state.currentNote && state.currentNote.id === noteId) {
                    state.currentNote = null;
                    showHomePage();
                }
                
                renderNotebooks();
                renderHomePage();
                saveToStorage();
            }
        }

        // Count all children recursively
        function countAllChildren(note) {
            if (!note.children || note.children.length === 0) return 0;
            return note.children.reduce((count, child) => count + 1 + countAllChildren(child), 0);
        }

        // Remove note from tree
        function removeNoteFromTree(notebook, noteId, notes = null) {
            const searchNotes = notes || notebook.notes;
            for (let i = 0; i < searchNotes.length; i++) {
                if (searchNotes[i].id === noteId) {
                    searchNotes.splice(i, 1);
                    return true;
                }
                if (searchNotes[i].children && removeNoteFromTree(notebook, noteId, searchNotes[i].children)) {
                    return true;
                }
            }
            return false;
        }

        // Pin/Unpin functions
        function isNotePinned(notebookId, noteId) {
            return state.pinnedNotes.some(p => p.notebookId === notebookId && p.noteId === noteId);
        }

        function togglePin(e, notebookId, noteId) {
            e.stopPropagation();
            const index = state.pinnedNotes.findIndex(p => p.notebookId === notebookId && p.noteId === noteId);
            if (index > -1) {
                state.pinnedNotes.splice(index, 1);
            } else {
                state.pinnedNotes.push({ notebookId, noteId });
            }
            renderNotebooks();
            renderHomePage();
            savePinnedToStorage();
        }

        function unpinNote(notebookId, noteId) {
            const index = state.pinnedNotes.findIndex(p => p.notebookId === notebookId && p.noteId === noteId);
            if (index > -1) {
                state.pinnedNotes.splice(index, 1);
                renderNotebooks();
                renderHomePage();
                savePinnedToStorage();
            }
        }

        // Home page functions
        function showHomePage() {
            // Save current note if any
            if (state.currentNote && hasUnsavedChanges) {
                saveNoteData();
                saveToStorage();
            }
            
            // Stop version history timer
            stopVersionHistoryTimer();
            
            // Clear undo/redo history
            clearUndoHistory();
            
            state.currentView = 'home';
            state.currentNote = null;
            
            document.getElementById('home-page').style.display = 'block';
            document.getElementById('canvas-container').style.display = 'none';
            document.getElementById('toolbar').style.display = 'none';
            document.getElementById('nav-home').classList.add('active');
            document.getElementById('note-info').textContent = 'Home';
            
            // Remove sub-note blocks from canvas
            const existingBlocks = document.querySelectorAll('.subnote-block');
            existingBlocks.forEach(block => block.remove());
            
            const indicator = document.getElementById('save-indicator');
            indicator.className = 'save-indicator saved';
            indicator.innerHTML = '<span class="save-dot"></span> <span class="save-text">Saved</span>';
            
            renderHomePage();
            renderNotebooks();
        }

        function showEditor() {
            state.currentView = 'editor';
            document.getElementById('home-page').style.display = 'none';
            document.getElementById('canvas-container').style.display = 'block';
            document.getElementById('nav-home').classList.remove('active');
        }

        function renderHomePage() {
            // Render pinned notes
            const pinnedContainer = document.getElementById('pinned-container');
            if (state.pinnedNotes.length === 0) {
                pinnedContainer.innerHTML = `
                    <div class="empty-pinned">
                        <p>No pinned notes yet. Click  on a note to pin it here.</p>
                    </div>
                `;
            } else {
                pinnedContainer.innerHTML = state.pinnedNotes.map(pin => {
                    const notebook = state.notebooks.find(n => n.id === pin.notebookId);
                    if (!notebook) return '';
                    const note = notebook.notes.find(n => n.id === pin.noteId);
                    if (!note) return '';
                    const statusBadge = note.status && note.status !== 'none' ? `<span class="status-badge ${note.status}">${getStatusLabel(note.status)}</span>` : '';
                    
                    return `
                        <div class="pinned-card" onclick="openPinnedNote('${pin.notebookId}', '${pin.noteId}')">
                            <button class="unpin-btn" onclick="event.stopPropagation(); unpinNote('${pin.notebookId}', '${pin.noteId}')" title="Unpin"></button>
                            <div class="pinned-card-preview">
                                ${note.canvasData ? `<img src="${note.canvasData}" alt="Preview">` : ''}
                            </div>
                            <div class="pinned-card-title">${note.name}${statusBadge}</div>
                            <div class="pinned-card-notebook">${notebook.name}</div>
                        </div>
                    `;
                }).join('');
            }
            
            // Render notebooks
            const notebooksContainer = document.getElementById('notebooks-home-container');
            if (state.notebooks.length === 0) {
                notebooksContainer.innerHTML = `
                    <div class="empty-pinned">
                        <p>No notebooks yet. Create one to get started!</p>
                    </div>
                `;
            } else {
                notebooksContainer.innerHTML = state.notebooks.map(notebook => `
                    <div class="notebook-card" onclick="openNotebook('${notebook.id}')">
                        <div class="notebook-card-icon"></div>
                        <div class="notebook-card-name">${notebook.name}</div>
                        <div class="notebook-card-count">${notebook.notes.length} note${notebook.notes.length !== 1 ? 's' : ''}</div>
                    </div>
                `).join('');
            }
        }

        function openPinnedNote(notebookId, noteId) {
            const notebook = state.notebooks.find(n => n.id === notebookId);
            if (!notebook) return;
            const note = notebook.notes.find(n => n.id === noteId);
            if (!note) return;
            selectNote(notebook, note);
        }

        function openNotebook(notebookId) {
            const notebook = state.notebooks.find(n => n.id === notebookId);
            if (!notebook) return;
            notebook.isOpen = true;
            state.currentNotebook = notebook;
            if (notebook.notes.length > 0) {
                selectNote(notebook, notebook.notes[0]);
            } else {
                showEditor();
                document.getElementById('empty-state').style.display = 'flex';
                document.getElementById('canvas-wrapper').style.display = 'none';
                document.getElementById('toolbar').style.display = 'none';
                document.getElementById('note-info').textContent = notebook.name;
            }
            renderNotebooks();
        }

        // Save/Load functions
        function saveNoteData() {
            if (!state.currentNote) return;
            
            state.currentNote.canvasData = drawingCanvas.toDataURL();
            state.currentNote.textBoxes = Array.from(textLayer.querySelectorAll('.text-box')).map(box => ({
                content: box.innerHTML,
                left: box.style.left,
                top: box.style.top,
                width: box.style.width,
                height: box.style.height,
                fontFamily: box.style.fontFamily,
                fontSize: box.style.fontSize,
                color: box.style.color,
                headerLevel: box.getAttribute('data-header-level') || null
            }));
            
            // Save media embeds
            state.currentNote.mediaEmbeds = Array.from(textLayer.querySelectorAll('.media-embed')).map(embed => ({
                id: embed.getAttribute('data-embed-id'),
                type: embed.getAttribute('data-embed-type'),
                url: embed.getAttribute('data-embed-url'),
                left: embed.style.left,
                top: embed.style.top,
                width: embed.style.width,
                height: embed.style.height
            }));
        }

        function loadNoteData(note) {
            initCanvases();
            
            // Clear undo/redo history for new note
            clearUndoHistory();
            
            // Load version history
            versionHistory = note.versionHistory || [];
            
            // Start version history timer
            startVersionHistoryTimer();
            
            if (note.canvasData) {
                const img = new Image();
                img.onload = () => {
                    drawCtx.drawImage(img, 0, 0);
                    // Save initial state after canvas is loaded
                    saveInitialState();
                };
                img.src = note.canvasData;
            } else {
                drawCtx.fillStyle = getCanvasBackground();
                drawCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                // Save initial state for blank canvas
                saveInitialState();
            }

            // Load text boxes
            textLayer.innerHTML = '';
            console.log('Loading note:', note.name, 'textBoxes:', note.textBoxes?.length || 0);
            if (note.textBoxes && note.textBoxes.length > 0) {
                note.textBoxes.forEach((boxData, idx) => {
                    console.log('Creating text box', idx, ':', boxData.content?.substring(0, 50), 'at', boxData.left, boxData.top);
                    const textBox = document.createElement('div');
                    textBox.className = 'text-box placed';
                    // Restore header class if this textbox was a header when saved
                    if (boxData.headerLevel) {
                        textBox.className += ` header-${boxData.headerLevel}`;
                        textBox.setAttribute('data-header-level', boxData.headerLevel);
                    }
                    textBox.contentEditable = true;
                    // Use innerHTML when content contains markup, otherwise preserve newlines
                    if (boxData.content && boxData.content.includes('<')) {
                        textBox.innerHTML = boxData.content;
                    } else if (boxData.content && boxData.content.indexOf('\n') !== -1) {
                        // Escape HTML then convert newlines to <br>
                        textBox.innerHTML = escapeHTML(boxData.content).replace(/\n/g, '<br>');
                    } else {
                        textBox.textContent = boxData.content || '';
                    }
                    textBox.style.position = 'absolute';
                    textBox.style.left = boxData.left;
                    textBox.style.top = boxData.top;
                    textBox.style.minWidth = '50px';
                    textBox.style.minHeight = '20px';
                    if (boxData.width && boxData.width !== 'auto' && boxData.width !== '') {
                        textBox.style.width = boxData.width;
                    }
                    if (boxData.height && boxData.height !== 'auto' && boxData.height !== '') {
                        textBox.style.height = boxData.height;
                    }
                    if (boxData.fontFamily) textBox.style.fontFamily = boxData.fontFamily;
                    // For headers, prefer CSS header sizing  avoid setting inline fontSize
                    if (!boxData.headerLevel) {
                        if (boxData.fontSize) textBox.style.fontSize = boxData.fontSize;
                    } else {
                        textBox.style.fontSize = '';
                    }
                    if (boxData.color) textBox.style.color = boxData.color;
                    
                    textBox.addEventListener('blur', () => {
                        if (textBox.textContent.trim() === '') {
                            textBox.remove();
                        }
                        saveToUndoStack();
                        markUnsaved();
                    });

                    textBox.addEventListener('input', debounce(() => markUnsaved(), 500));
                    
                    // Add click handler for select tool
                    addTextBoxSelectHandler(textBox);
                    
                    textLayer.appendChild(textBox);
                    console.log('Appended text box, textLayer children:', textLayer.children.length);
                });
            }
            console.log('Final textLayer innerHTML length:', textLayer.innerHTML.length);
            
            // Load media embeds
            if (note.mediaEmbeds) {
                note.mediaEmbeds.forEach(embedData => {
                    createMediaEmbed(embedData.url, embedData.type, {
                        id: embedData.id,
                        left: embedData.left,
                        top: embedData.top,
                        width: embedData.width,
                        height: embedData.height
                    });
                });
            }

            // Update outline and header nav after loading text boxes
            updateOutline();

            // Ensure canvas wrapper transform is applied after loading content
            updateCanvasTransform();
        }

        // Auto-save
        let saveTimeout = null;
        let debounceSaveTimeout = null;
        let hasUnsavedChanges = false;
        let suppressNextAutoSave = false;
        const SAVE_DELAY = 2000; // Save 2 seconds after user stops making changes
        
        function markUnsaved() {
            if (!hasUnsavedChanges) {
                hasUnsavedChanges = true;
                const indicator = document.getElementById('save-indicator');
                indicator.className = 'save-indicator unsaved';
                indicator.innerHTML = '<span class="save-dot"></span> <span class="save-text">Unsaved changes</span>';
            }
            
            // Debounce: save after user stops making changes
            if (debounceSaveTimeout) clearTimeout(debounceSaveTimeout);
            debounceSaveTimeout = setTimeout(() => {
                if (hasUnsavedChanges && state.currentNote) {
                    saveCurrentNote();
                }
            }, SAVE_DELAY);
        }
        
        function saveCurrentNote() {
            if (!state.currentNote) return;
            
            // Prevent immediate auto-save from overwriting imported content
            if (suppressNextAutoSave) {
                suppressNextAutoSave = false;
                return;
            }
            
            const indicator = document.getElementById('save-indicator');
            
            // Show saving state
            indicator.className = 'save-indicator saving';
            indicator.innerHTML = '<span class="save-dot"></span> <span class="save-text">Saving...</span>';
            
            saveNoteData();
            saveToStorage();
            hasUnsavedChanges = false;

            // Clear any existing timeout
            if (saveTimeout) clearTimeout(saveTimeout);
            
            // Show "just saved" state briefly
            setTimeout(() => {
                indicator.className = 'save-indicator just-saved';
                indicator.innerHTML = '<span class="save-dot"></span> <span class="save-text">Saved just now</span>';
                
                // Then fade to normal saved state
                saveTimeout = setTimeout(() => {
                    indicator.className = 'save-indicator saved';
                    indicator.innerHTML = '<span class="save-dot"></span> <span class="save-text">Saved</span>';
                }, 2000);
            }, 400);
        }
        
        // Save before leaving page
        window.addEventListener('beforeunload', (e) => {
            if (hasUnsavedChanges && state.currentNote) {
                saveNoteData();
                saveToStorage();
            }
        });

        function saveToStorage() {
            try {
                localStorage.setItem('ultimateNotesApp', JSON.stringify(state.notebooks));
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    console.error('Storage quota exceeded! Trying to free space...');
                    // Try to free space by clearing version history
                    state.notebooks.forEach(nb => nb.notes.forEach(n => { 
                        n.versionHistory = []; 
                    }));
                    try {
                        localStorage.setItem('ultimateNotesApp', JSON.stringify(state.notebooks));
                        console.log('Saved after clearing version history');
                    } catch (e2) {
                        alert('Storage is full! Consider exporting and deleting some notes.');
                    }
                }
            }
        }

        function savePinnedToStorage() {
            localStorage.setItem('ultimateNotesAppPinned', JSON.stringify(state.pinnedNotes));
        }

        function loadFromStorage() {
            const saved = localStorage.getItem('ultimateNotesApp');
            if (saved) {
                state.notebooks = JSON.parse(saved);
            }
            const savedPinned = localStorage.getItem('ultimateNotesAppPinned');
            if (savedPinned) {
                state.pinnedNotes = JSON.parse(savedPinned);
            }
            // Load dark mode preference
            const darkMode = localStorage.getItem('ultimateNotesAppDarkMode');
            if (darkMode === 'true') {
                document.body.classList.add('dark-mode');
            }
            renderNotebooks();
            renderHomePage();
            suppressNextAutoSave = true; // Prevent first auto-save from overwriting imported notes
        }

        // Dark Mode Toggle
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem('ultimateNotesAppDarkMode', isDark);
            
            // Update default ink color
            updateDefaultColor();
            
            // Update canvas background when toggling
            if (state.currentNote) {
                // Invert the canvas colors
                invertCanvasColors();
            }
        }
        
        function isDarkMode() {
            return document.body.classList.contains('dark-mode');
        }
        
        function getCanvasBackground() {
            return isDarkMode() ? '#2a2a2a' : '#ffffff';
        }
        
        function getDefaultInkColor() {
            return isDarkMode() ? '#e0e0e0' : '#333333';
        }
        
        function getEraserColor() {
            return getCanvasBackground();
        }
        
        function invertCanvasColors() {
            const imageData = drawCtx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                // Invert RGB values
                data[i] = 255 - data[i];       // Red
                data[i + 1] = 255 - data[i + 1]; // Green
                data[i + 2] = 255 - data[i + 2]; // Blue
                // Alpha stays the same
            }
            
            drawCtx.putImageData(imageData, 0, 0);
            
            // Also invert text box colors
            document.querySelectorAll('.text-box').forEach(box => {
                const currentColor = box.style.color;
                if (currentColor) {
                    box.style.color = invertColor(currentColor);
                }
            });
            
            markUnsaved();
        }
        
        function invertColor(color) {
            // Handle hex colors
            if (color.startsWith('#')) {
                const hex = color.slice(1);
                const r = 255 - parseInt(hex.substr(0, 2), 16);
                const g = 255 - parseInt(hex.substr(2, 2), 16);
                const b = 255 - parseInt(hex.substr(4, 2), 16);
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }
            // Handle rgb colors
            if (color.startsWith('rgb')) {
                const match = color.match(/\d+/g);
                if (match) {
                    const r = 255 - parseInt(match[0]);
                    const g = 255 - parseInt(match[1]);
                    const b = 255 - parseInt(match[2]);
                    return `rgb(${r}, ${g}, ${b})`;
                }
            }
            return color;
        }

        // Debounce helper
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Initialize
        loadFromStorage();
        initCanvases();
        showHomePage();
        
        // Set initial color based on dark mode
        updateDefaultColor();
        
        function updateDefaultColor() {
            const defaultColor = getDefaultInkColor();
            state.color = defaultColor;
            document.getElementById('color-picker').value = defaultColor;
        }

        // Manual save
        function manualSave() {
            if (state.currentNote) {
                saveCurrentNote();
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.classList.contains('text-box') || e.target.classList.contains('modal-input')) {
                // Allow Ctrl+S even in text boxes
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    manualSave();
                }
                // Allow Ctrl+Z for undo in text boxes (but use our custom undo for canvas)
                return;
            }
            
            // Ctrl+S to save
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                manualSave();
                return;
            }
            
            // Ctrl+Z to undo
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
                return;
            }
            
            // Ctrl+Y or Ctrl+Shift+Z to redo
            if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
                return;
            }
            
            // Delete or Backspace to delete selected text box or media embed
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedTextBox) {
                e.preventDefault();
                deleteSelectedTextBox();
                return;
            }
            
            // Delete selected media embed
            if ((e.key === 'Delete' || e.key === 'Backspace')) {
                const selectedEmbed = document.querySelector('.media-embed.selected');
                if (selectedEmbed) {
                    e.preventDefault();
                    selectedEmbed.remove();
                    markUnsaved();
                    return;
                }
            }
            
            if (e.key === 'd') setTool('draw');
            if (e.key === 's') setTool('select');
            if (e.key === 'e') setTool('erase');
            if (e.key === 't') setTool('text');
            if (e.key === 'p') setTool('pan');
            if (e.key === 'g') toggleGrid();
            if (e.key === '+' || e.key === '=') zoomIn();
            if (e.key === '-') zoomOut();
            if (e.key === '0') resetZoom();
        });
    </script>
</body>
</html>
